// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use std::env;
use std::fs;
use std::io::{Read, Write};
use std::path::Path;
use toml::value::Table;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("link_metrics.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // Identify crates that use #[metric_doc]
    // We scan sibling directories in `datafusion/`
    let core_crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let datafusion_dir = Path::new(&core_crate_dir).parent().unwrap();

    let mut crates_with_metrics = Vec::new();

    // Read Cargo.toml to check dependencies
    let cargo_toml_path = Path::new(&core_crate_dir).join("Cargo.toml");
    let cargo_toml_content =
        fs::read_to_string(&cargo_toml_path).expect("core Cargo.toml must be readable");
    let cargo_manifest: toml::Value =
        toml::from_str(&cargo_toml_content).expect("core Cargo.toml must be valid TOML");
    let dependencies = manifest_table(&cargo_manifest, "dependencies");
    let dev_dependencies = manifest_table(&cargo_manifest, "dev-dependencies");
    let features = manifest_table(&cargo_manifest, "features");

    if let Ok(entries) = fs::read_dir(datafusion_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                // Check if it's a crate (has Cargo.toml)
                if path.join("Cargo.toml").exists() {
                    let dir_name = path.file_name().unwrap().to_str().unwrap();
                    let crate_name = format!("datafusion-{dir_name}");

                    // Skip self (core), macros (definition only), and doc (dev-dep only)
                    if dir_name == "core" || dir_name == "macros" || dir_name == "doc" {
                        continue;
                    }

                    let is_dependency = dependencies.contains_key(&crate_name)
                        || dev_dependencies.contains_key(&crate_name);
                    if !is_dependency {
                        continue;
                    }

                    if has_metric_doc(&path) {
                        crates_with_metrics.push(crate_name);
                    }
                }
            }
        }
    }

    // Sort for deterministic output
    crates_with_metrics.sort();

    writeln!(
        f,
        "/// Automatically generated by build.rs to link crates with metrics"
    )
    .unwrap();
    writeln!(f, "pub fn link_metrics() {{").unwrap();
    for krate in crates_with_metrics {
        let krate_snake = krate.replace("-", "_");

        if is_optional_dependency(&dependencies, &krate) {
            let feature = dependency_feature(&features, &krate);
            writeln!(f, "    #[cfg(feature = \"{feature}\")]").unwrap();
        }

        writeln!(f, "    {{").unwrap();
        writeln!(f, "        // Force link {krate}").unwrap();
        writeln!(f, "        use {krate_snake} as _;").unwrap();
        writeln!(f, "    }}").unwrap();
    }
    writeln!(f, "}}").unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.toml");
}

fn manifest_table(manifest: &toml::Value, key: &str) -> Table {
    manifest
        .get(key)
        .and_then(|value| value.as_table())
        .cloned()
        .unwrap_or_default()
}

fn is_optional_dependency(dependencies: &Table, crate_name: &str) -> bool {
    dependencies
        .get(crate_name)
        .and_then(|dep| dep.as_table())
        .and_then(|dep| dep.get("optional"))
        .and_then(|value| value.as_bool())
        .unwrap_or(false)
}

fn dependency_feature(features: &Table, crate_name: &str) -> String {
    let dep_feature = format!("dep:{crate_name}");
    for (feature, deps) in features {
        if let Some(array) = deps.as_array() {
            for dep in array {
                if let Some(dep_str) = dep.as_str()
                    && (dep_str == crate_name || dep_str == dep_feature)
                {
                    return feature.clone();
                }
            }
        }
    }
    crate_name.to_string()
}

fn has_metric_doc(dir: &Path) -> bool {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                // Skip target, .git, etc
                if let Some(name) = path.file_name().and_then(|n| n.to_str())
                    && (name == "target" || name.starts_with('.'))
                {
                    continue;
                }
                if has_metric_doc(&path) {
                    return true;
                }
            } else if let Some(ext) = path.extension()
                && ext == "rs"
                && let Ok(mut file) = fs::File::open(&path)
            {
                let mut content = String::new();
                if file.read_to_string(&mut content).is_ok()
                    && content.contains("#[metric_doc")
                {
                    return true;
                }
            }
        }
    }
    false
}
