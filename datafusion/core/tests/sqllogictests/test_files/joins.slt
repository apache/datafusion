# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


####
# Configuration
####

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 4096;

statement ok
set datafusion.explain.logical_plan_only = true;


####
# Data Setup
####

statement ok
set datafusion.execution.target_partitions = 1;

statement ok
CREATE TABLE join_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4);

statement ok
CREATE TABLE join_t2(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3);

# Left semi anti join

statement ok
CREATE TABLE lsaj_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4),
(NULL, 'e', 0);

statement ok
CREATE TABLE lsaj_t2(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3),
(NULL, 'v', 0);

statement ok
set datafusion.execution.target_partitions = 2;

##########
## Joins Tests
##########

# create table t1
statement ok
CREATE TABLE t1(a INT, b INT, c INT) AS VALUES
(1, 10, 50),
(2, 20, 60),
(3, 30, 70),
(4, 40, 80)

# create table t2
statement ok
CREATE TABLE t2(a INT, b INT, c INT) AS VALUES
(1, 100, 500),
(2, 200, 600),
(9, 300, 700),
(4, 400, 800)

# equijoin
query II nosort
SELECT t1.a, t2.b FROM t1 INNER JOIN t2 ON t1.a = t2.a ORDER BY t1.a
----
1 100
2 200
4 400

query II nosort
SELECT t1.a, t2.b FROM t1 INNER JOIN t2 ON t2.a = t1.a ORDER BY t1.a
----
1 100
2 200
4 400

# inner_join_nulls
query ??
SELECT * FROM (SELECT null AS id1) t1
INNER JOIN (SELECT null AS id2) t2 ON id1 = id2
----

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2


# create table a
statement ok
CREATE TABLE a(a INT, b INT, c INT) AS VALUES
(1, 10, 50),
(2, 20, 60),
(3, 30, 70),
(4, 40, 80)

# create table b
statement ok
CREATE TABLE b(a INT, b INT, c INT) AS VALUES
(1, 100, 500),
(2, 200, 600),
(9, 300, 700),
(4, 400, 800)

# issue_3002
#    // repro case for https://github.com/apache/arrow-datafusion/issues/3002

query II
select a.a, b.b from a join b on a.a = b.b
----

statement ok
DROP TABLE a

statement ok
DROP TABLE b

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR) AS VALUES
(11, 'a'),
(22, 'b'),
(33, 'c'),
(44, 'd'),
(77, 'e')

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR) AS VALUES
(11, 'z'),
(22, 'y'),
(44, 'x'),
(55, 'w')

# left_join_unbalanced
#     // the t1_id is larger than t2_id so the join_selection optimizer should kick in
query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id ORDER BY t1_id
----
11 a z
22 b y
33 c NULL
44 d x
77 e NULL

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 LEFT JOIN t2 ON t2_id = t1_id ORDER BY t1_id
----
11 a z
22 b y
33 c NULL
44 d x
77 e NULL


# cross_join_unbalanced
query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z
77 e w
77 e x
77 e y
77 e z

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR) AS VALUES
(11, 'a'),
(22, 'b'),
(33, 'c'),
(44, 'd'),
(77, 'e'),
(88, NULL),
(99, NULL)

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR) AS VALUES
(11, 'z'),
(22, NULL),
(44, 'x'),
(55, 'w'),
(99, 'u')

# left_join_null_filter
#    // Since t2 is the non-preserved side of the join, we cannot push down a NULL filter.
#   // Note that this is only true because IS NULL does not remove nulls. For filters that
#   // remove nulls, we can rewrite the join as an inner join and then push down the filter.
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_name IS NULL ORDER BY t1_id
----
22 22 NULL
33 NULL NULL
77 NULL NULL
88 NULL NULL

# left_join_null_filter_on_join_column
#    // Again, since t2 is the non-preserved side of the join, we cannot push down a NULL filter.
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_id IS NULL ORDER BY t1_id
----
33 NULL NULL
77 NULL NULL
88 NULL NULL

# left_join_not_null_filter
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_name IS NOT NULL ORDER BY t1_id
----
11 11 z
44 44 x
99 99 u

# left_join_not_null_filter_on_join_column
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_id IS NOT NULL ORDER BY t1_id
----
11 11 z
22 22 NULL
44 44 x
99 99 u

# self_join_non_equijoin
query II nosort
SELECT x.t1_id, y.t1_id FROM t1 x JOIN t1 y ON x.t1_id = 11 AND y.t1_id = 44
----
11 44

# right_join_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_name IS NULL ORDER BY t2_id
----
NULL NULL 55
99 NULL 99

# right_join_null_filter_on_join_column
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_id IS NULL ORDER BY t2_id
----
NULL NULL 55

# right_join_not_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_name IS NOT NULL ORDER BY t2_id
----
11 a 11
22 b 22
44 d 44

# right_join_not_null_filter_on_join_column
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_id IS NOT NULL ORDER BY t2_id
----
11 a 11
22 b 22
44 d 44
99 NULL 99

# full_join_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 FULL OUTER JOIN t2 ON t1_id = t2_id WHERE t1_name IS NULL ORDER BY t1_id
----
88 NULL NULL
99 NULL 99
NULL NULL 55

# full_join_not_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 FULL OUTER JOIN t2 ON t1_id = t2_id WHERE t1_name IS NOT NULL ORDER BY t1_id
----
11 a 11
22 b 22
33 c NULL
44 d 44
77 e NULL

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(id INT, t1_name VARCHAR, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4)

# create table t2
statement ok
CREATE TABLE t2(id INT, t2_name VARCHAR, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3)

# left_join_using

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = true

query ITT nosort
SELECT id, t1_name, t2_name FROM t1 LEFT JOIN t2 USING (id) ORDER BY id
----
11 a z
22 b y
33 c NULL
44 d x

# set repartition_joins to false
statement ok
set datafusion.optimizer.repartition_joins = false

query ITT nosort
SELECT id, t1_name, t2_name FROM t1 LEFT JOIN t2 USING (id) ORDER BY id
----
11 a z
22 b y
33 c NULL
44 d x

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4)

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3)

# cross_join

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = true

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 WHERE 1=1 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITITI rowsort
SELECT * FROM (SELECT t1_id, t1_name FROM t1 UNION ALL SELECT t1_id, t1_name FROM t1) AS t1 CROSS JOIN t2
----
11 a 11 z 3
11 a 11 z 3
11 a 22 y 1
11 a 22 y 1
11 a 44 x 3
11 a 44 x 3
11 a 55 w 3
11 a 55 w 3
22 b 11 z 3
22 b 11 z 3
22 b 22 y 1
22 b 22 y 1
22 b 44 x 3
22 b 44 x 3
22 b 55 w 3
22 b 55 w 3
33 c 11 z 3
33 c 11 z 3
33 c 22 y 1
33 c 22 y 1
33 c 44 x 3
33 c 44 x 3
33 c 55 w 3
33 c 55 w 3
44 d 11 z 3
44 d 11 z 3
44 d 22 y 1
44 d 22 y 1
44 d 44 x 3
44 d 44 x 3
44 d 55 w 3
44 d 55 w 3

query ITT rowsort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN (SELECT t2_name FROM t2 UNION ALL SELECT t2_name FROM t2) AS t2_data
----
11 a w
11 a w
11 a x
11 a x
11 a y
11 a y
11 a z
11 a z
22 b w
22 b w
22 b x
22 b x
22 b y
22 b y
22 b z
22 b z
33 c w
33 c w
33 c x
33 c x
33 c y
33 c y
33 c z
33 c z
44 d w
44 d w
44 d x
44 d x
44 d y
44 d y
44 d z
44 d z

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = false

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 WHERE 1=1 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id
----
11 a z
11 a y
11 a x
11 a w
22 b z
22 b y
22 b x
22 b w
33 c z
33 c y
33 c x
33 c w
44 d z
44 d y
44 d x
44 d w

query ITITI rowsort
SELECT * FROM (SELECT t1_id, t1_name FROM t1 UNION ALL SELECT t1_id, t1_name FROM t1) AS t1 CROSS JOIN t2
----
11 a 11 z 3
11 a 11 z 3
11 a 22 y 1
11 a 22 y 1
11 a 44 x 3
11 a 44 x 3
11 a 55 w 3
11 a 55 w 3
22 b 11 z 3
22 b 11 z 3
22 b 22 y 1
22 b 22 y 1
22 b 44 x 3
22 b 44 x 3
22 b 55 w 3
22 b 55 w 3
33 c 11 z 3
33 c 11 z 3
33 c 22 y 1
33 c 22 y 1
33 c 44 x 3
33 c 44 x 3
33 c 55 w 3
33 c 55 w 3
44 d 11 z 3
44 d 11 z 3
44 d 22 y 1
44 d 22 y 1
44 d 44 x 3
44 d 44 x 3
44 d 55 w 3
44 d 55 w 3

query ITT rowsort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN (SELECT t2_name FROM t2 UNION ALL SELECT t2_name FROM t2) AS t2_data
----
11 a w
11 a w
11 a x
11 a x
11 a y
11 a y
11 a z
11 a z
22 b w
22 b w
22 b x
22 b x
22 b y
22 b y
22 b z
22 b z
33 c w
33 c w
33 c x
33 c x
33 c y
33 c y
33 c z
33 c z
44 d w
44 d w
44 d x
44 d x
44 d y
44 d y
44 d z
44 d z

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# Join timestamp

statement ok
CREATE TABLE timestamp(time TIMESTAMP) AS VALUES
    (131964190213133),
    (131964190213134),
    (131964190213135);

query PP
SELECT *
FROM timestamp as a
JOIN (SELECT * FROM timestamp) as b
ON a.time = b.time
ORDER BY a.time
----
1970-01-02T12:39:24.190213133 1970-01-02T12:39:24.190213133
1970-01-02T12:39:24.190213134 1970-01-02T12:39:24.190213134
1970-01-02T12:39:24.190213135 1970-01-02T12:39:24.190213135

statement ok
DROP TABLE timestamp;

# Join float32

statement ok
CREATE TABLE population(city VARCHAR, population FLOAT) AS VALUES
    ('a', 838.698),
    ('b', 1778.934),
    ('c', 626.443);

query TRTR
SELECT *
FROM population as a
JOIN (SELECT * FROM population) as b
ON a.population = b.population
ORDER BY a.population
----
c 626.443 c 626.443
a 838.698 a 838.698
b 1778.934 b 1778.934

statement ok
DROP TABLE population;

# Join float64

statement ok
CREATE TABLE population(city VARCHAR, population DOUBLE) AS VALUES
    ('a', 838.698),
    ('b', 1778.934),
    ('c', 626.443);

query TRTR
SELECT *
FROM population as a
JOIN (SELECT * FROM population) as b
ON a.population = b.population
ORDER BY a.population
----
c 626.443 c 626.443
a 838.698 a 838.698
b 1778.934 b 1778.934

statement ok
DROP TABLE population;

# Inner join qualified names

statement ok
CREATE TABLE t1 (a INT, b INT, c INT) AS VALUES
    (1, 10, 50),
    (2, 20, 60),
    (3, 30, 70),
    (4, 40, 80);

statement ok
CREATE TABLE t2 (a INT, b INT, c INT) AS VALUES
    (1, 100, 500),
    (2, 200, 600),
    (9, 300, 700),
    (4, 400, 800);

query IIIIII
SELECT t1.a, t1.b, t1.c, t2.a, t2.b, t2.c
FROM t1
INNER JOIN t2 ON t1.a = t2.a
ORDER BY t1.a
----
1 10 50 1 100 500
2 20 60 2 200 600
4 40 80 4 400 800

query IIIIII
SELECT t1.a, t1.b, t1.c, t2.a, t2.b, t2.c
FROM t1
INNER JOIN t2 ON t2.a = t1.a
ORDER BY t1.a
----
1 10 50 1 100 500
2 20 60 2 200 600
4 40 80 4 400 800

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

# TODO: nestedjoin_with_alias

# Nested join without alias

query IIII
select * from (select 1 as a, 2 as b) c INNER JOIN (select 1 as a, 3 as d) e on c.a = e.a
----
1 2 1 3

# Join tables with duplicated column name not in on constraint

statement ok
CREATE TABLE countries (id INT, country VARCHAR) AS VALUES
    (1, 'Germany'),
    (2, 'Sweden'),
    (3, 'Japan');

statement ok
CREATE TABLE cities (id INT, country_id INT, city VARCHAR) AS VALUES
    (1, 1, 'Hamburg'),
    (2, 2, 'Stockholm'),
    (3, 3, 'Osaka'),
    (4, 1, 'Berlin'),
    (5, 2, 'Göteborg'),
    (6, 3, 'Tokyo'),
    (7, 3, 'Kyoto');

query IITT
SELECT t1.id, t2.id, t1.city, t2.country FROM cities AS t1 JOIN countries AS t2 ON t1.country_id = t2.id ORDER BY t1.id
----
1 1 Hamburg Germany
2 2 Stockholm Sweden
3 3 Osaka Japan
4 1 Berlin Germany
5 2 Göteborg Sweden
6 3 Tokyo Japan
7 3 Kyoto Japan

statement ok
DROP TABLE countries;

statement ok
DROP TABLE cities;

# TODO: join_timestamp

# Left join and right join should not panic with empty side

statement ok
CREATE TABLE t1 (t1_id BIGINT, ti_value VARCHAR NOT NULL) AS VALUES
    (5247, 'a'),
    (3821, 'b'),
    (6321, 'c'),
    (8821, 'd'),
    (7748, 'e');

statement ok
CREATE TABLE t2 (t2_id BIGINT, t2_value BOOLEAN) AS VALUES
    (358, true),
    (2820, false),
    (3804, NULL),
    (7748, NULL);

query ITIB rowsort
SELECT * FROM t1 LEFT JOIN t2 ON t1_id = t2_id
----
3821 b NULL NULL
5247 a NULL NULL
6321 c NULL NULL
7748 e 7748 NULL
8821 d NULL NULL

query IBIT rowsort
SELECT * FROM t2 RIGHT JOIN t1 ON t1_id = t2_id
----
7748 NULL 7748 e
NULL NULL 3821 b
NULL NULL 5247 a
NULL NULL 6321 c
NULL NULL 8821 d

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

# TODO: left_join_using_2

# TODO: left_join_using_join_key_projection

# TODO: left_join_2

# TODO: join_partitioned

# TODO: hash_join_with_date32

# TODO: hash_join_with_date64

# TODO: hash_join_with_decimal

# TODO: hash_join_with_dictionary


###
# Configuration setup
###

statement ok
set datafusion.optimizer.repartition_joins = false;

# Reduce left join 1 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
LEFT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_id < 100
----
logical_plan
Inner Join: join_t1.t1_id = join_t2.t2_id
--Filter: join_t1.t1_id < UInt32(100)
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--Filter: join_t2.t2_id < UInt32(100)
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce left join 2 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
LEFT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_int < 10 or (join_t1.t1_int > 2 and join_t2.t2_name != 'w')
----
logical_plan
Inner Join: join_t1.t1_id = join_t2.t2_id Filter: join_t2.t2_int < UInt32(10) OR join_t1.t1_int > UInt32(2) AND join_t2.t2_name != Utf8("w")
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--Filter: join_t2.t2_int < UInt32(10) OR join_t2.t2_name != Utf8("w")
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce left join 3 (to inner join)

query TT
EXPLAIN
SELECT *
FROM (
    SELECT join_t1.*
    FROM join_t1
    LEFT JOIN join_t2 ON join_t1.t1_id = join_t2.t2_id
    WHERE join_t2.t2_int < 3
) t3
LEFT JOIN join_t2 on t3.t1_int = join_t2.t2_int
WHERE t3.t1_id < 100
----
logical_plan
Left Join: t3.t1_int = join_t2.t2_int
--SubqueryAlias: t3
----Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
------Inner Join: join_t1.t1_id = join_t2.t2_id
--------Filter: join_t1.t1_id < UInt32(100)
----------TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--------Projection: join_t2.t2_id
----------Filter: join_t2.t2_int < UInt32(3) AND join_t2.t2_id < UInt32(100)
------------TableScan: join_t2 projection=[t2_id, t2_int]
--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce right join 1 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
RIGHT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_int IS NOT NULL
----
logical_plan
Inner Join: join_t1.t1_id = join_t2.t2_id
--Filter: join_t1.t1_int IS NOT NULL
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce right join 2 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
RIGHT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE NOT (join_t1.t1_int = join_t2.t2_int)
----
logical_plan
Inner Join: join_t1.t1_id = join_t2.t2_id Filter: join_t1.t1_int != join_t2.t2_int
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to right join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_name IS NOT NULL
----
logical_plan
Right Join: join_t1.t1_id = join_t2.t2_id
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--Filter: join_t2.t2_name IS NOT NULL
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to left join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 ON join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_name != 'b'
----
logical_plan
Left Join: join_t1.t1_id = join_t2.t2_id
--Filter: join_t1.t1_name != Utf8("b")
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to inner join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_name != 'b' and join_t2.t2_name = 'x'
----
logical_plan
Inner Join: join_t1.t1_id = join_t2.t2_id
--Filter: join_t1.t1_name != Utf8("b")
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--Filter: join_t2.t2_name = Utf8("x")
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

###
# Configuration teardown
###

statement ok
set datafusion.optimizer.repartition_joins = true;


# Sort merge equijoin

query ITT
SELECT t1_id, t1_name, t2_name
FROM join_t1
JOIN join_t2 ON t1_id = t2_id
ORDER BY t1_id
----
11 a z
22 b y
44 d x

query ITT
SELECT t1_id, t1_name, t2_name
FROM join_t1
JOIN join_t2 ON t2_id = t1_id
ORDER BY t1_id
----
11 a z
22 b y
44 d x

# TODO: sort_merge_join_on_date32

# TODO: sort_merge_join_on_decimal


# TODO: Left semi join

# Left semi join pushdown

query TT
EXPLAIN
SELECT lsaj_t1.t1_id, lsaj_t1.t1_name
FROM lsaj_t1
LEFT SEMI JOIN lsaj_t2 ON (lsaj_t1.t1_id = lsaj_t2.t2_id and lsaj_t2.t2_int > 1)
----
logical_plan
LeftSemi Join: lsaj_t1.t1_id = lsaj_t2.t2_id
--TableScan: lsaj_t1 projection=[t1_id, t1_name]
--Projection: lsaj_t2.t2_id
----Filter: lsaj_t2.t2_int > UInt32(1)
------TableScan: lsaj_t2 projection=[t2_id, t2_int]

# Left anti join

statement ok
set datafusion.optimizer.repartition_joins = false;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

query I
SELECT t1_id
FROM lsaj_t1
EXCEPT SELECT t2_id FROM lsaj_t2
ORDER BY t1_id
----
33

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
LEFT ANTI JOIN lsaj_t2 ON (t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

statement ok
set datafusion.optimizer.repartition_joins = true;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

query I
SELECT t1_id
FROM lsaj_t1
EXCEPT SELECT t2_id FROM lsaj_t2
ORDER BY t1_id
----
33

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
LEFT ANTI JOIN lsaj_t2 ON (t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

# Error left anti join
# https://github.com/apache/arrow-datafusion/issues/4366

statement ok
set datafusion.optimizer.repartition_joins = false;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id and t1_id > 11)
ORDER BY t1_id
----
11 a
11 a
33 c
NULL e

statement ok
set datafusion.optimizer.repartition_joins = true;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id and t1_id > 11)
ORDER BY t1_id
----
11 a
11 a
33 c
NULL e

# TODO: null_aware_left_anti_join

# TODO: right_semi_join

# Join and aggregate on same key

statement ok
set datafusion.explain.logical_plan_only = false;

query TT
EXPLAIN
select distinct(join_t1.t1_id)
from join_t1
inner join join_t2 on join_t1.t1_id = join_t2.t2_id
----
logical_plan
Aggregate: groupBy=[[join_t1.t1_id]], aggr=[[]]
--Projection: join_t1.t1_id
----Inner Join: join_t1.t1_id = join_t2.t2_id
------TableScan: join_t1 projection=[t1_id]
------TableScan: join_t2 projection=[t2_id]
physical_plan
AggregateExec: mode=Single, gby=[t1_id@0 as t1_id], aggr=[]
--ProjectionExec: expr=[t1_id@0 as t1_id]
----CoalesceBatchesExec: target_batch_size=4096
------HashJoinExec: mode=Partitioned, join_type=Inner, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 0 })]
--------CoalesceBatchesExec: target_batch_size=4096
----------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 2), input_partitions=2
------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
--------------MemoryExec: partitions=1, partition_sizes=[1]
--------CoalesceBatchesExec: target_batch_size=4096
----------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 2), input_partitions=2
------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
--------------MemoryExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN
select count(*)
from (select * from join_t1 inner join join_t2 on join_t1.t1_id = join_t2.t2_id)
group by t1_id
----
logical_plan
Projection: COUNT(UInt8(1))
--Aggregate: groupBy=[[join_t1.t1_id]], aggr=[[COUNT(UInt8(1))]]
----Projection: join_t1.t1_id
------Inner Join: join_t1.t1_id = join_t2.t2_id
--------TableScan: join_t1 projection=[t1_id]
--------TableScan: join_t2 projection=[t2_id]
physical_plan
ProjectionExec: expr=[COUNT(UInt8(1))@1 as COUNT(UInt8(1))]
--AggregateExec: mode=Single, gby=[t1_id@0 as t1_id], aggr=[COUNT(UInt8(1))]
----ProjectionExec: expr=[t1_id@0 as t1_id]
------CoalesceBatchesExec: target_batch_size=4096
--------HashJoinExec: mode=Partitioned, join_type=Inner, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 0 })]
----------CoalesceBatchesExec: target_batch_size=4096
------------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 2), input_partitions=2
--------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
----------------MemoryExec: partitions=1, partition_sizes=[1]
----------CoalesceBatchesExec: target_batch_size=4096
------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 2), input_partitions=2
--------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
----------------MemoryExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN
select count(distinct join_t1.t1_id)
from join_t1
inner join join_t2 on join_t1.t1_id = join_t2.t2_id
----
logical_plan
Projection: COUNT(alias1) AS COUNT(DISTINCT join_t1.t1_id)
--Aggregate: groupBy=[[]], aggr=[[COUNT(alias1)]]
----Aggregate: groupBy=[[join_t1.t1_id AS alias1]], aggr=[[]]
------Projection: join_t1.t1_id
--------Inner Join: join_t1.t1_id = join_t2.t2_id
----------TableScan: join_t1 projection=[t1_id]
----------TableScan: join_t2 projection=[t2_id]
physical_plan
ProjectionExec: expr=[COUNT(alias1)@0 as COUNT(DISTINCT join_t1.t1_id)]
--AggregateExec: mode=Final, gby=[], aggr=[COUNT(alias1)]
----CoalescePartitionsExec
------AggregateExec: mode=Partial, gby=[], aggr=[COUNT(alias1)]
--------AggregateExec: mode=FinalPartitioned, gby=[alias1@0 as alias1], aggr=[]
----------AggregateExec: mode=Partial, gby=[t1_id@0 as alias1], aggr=[]
------------ProjectionExec: expr=[t1_id@0 as t1_id]
--------------CoalesceBatchesExec: target_batch_size=4096
----------------HashJoinExec: mode=Partitioned, join_type=Inner, on=[(Column { name: "t1_id", index: 0 }, Column { name: "t2_id", index: 0 })]
------------------CoalesceBatchesExec: target_batch_size=4096
--------------------RepartitionExec: partitioning=Hash([Column { name: "t1_id", index: 0 }], 2), input_partitions=2
----------------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
------------------------MemoryExec: partitions=1, partition_sizes=[1]
------------------CoalesceBatchesExec: target_batch_size=4096
--------------------RepartitionExec: partitioning=Hash([Column { name: "t2_id", index: 0 }], 2), input_partitions=2
----------------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
------------------------MemoryExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.explain.logical_plan_only = true;

# Reduce cross join with expr join key all (to inner join)

query TT
EXPLAIN
select *
from join_t1
cross join join_t2
where join_t1.t1_id + 12 = join_t2.t2_id + 1
----
logical_plan
Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = CAST(join_t2.t2_id AS Int64) + Int64(1)
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce cross join with cast expr join key (to inner join)

query TT
EXPLAIN
select join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
from join_t1
cross join join_t2 where join_t1.t1_id + 11 = cast(join_t2.t2_id as BIGINT)
----
logical_plan
Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
----TableScan: join_t1 projection=[t1_id, t1_name]
----TableScan: join_t2 projection=[t2_id]

# Reduce cross join with wildcard and expr (to inner join)

statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
select *, join_t1.t1_id + 11
from join_t1, join_t2
where join_t1.t1_id + 11 = join_t2.t2_id
----
logical_plan
Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int, join_t2.t2_id, join_t2.t2_name, join_t2.t2_int, CAST(join_t1.t1_id AS Int64) + Int64(11)
--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@3 as t2_id, t2_name@4 as t2_name, t2_int@5 as t2_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
--ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@4 as t2_id, t2_name@5 as t2_name, t2_int@6 as t2_int]
----CoalesceBatchesExec: target_batch_size=4096
------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(Column { name: "join_t1.t1_id + Int64(11)", index: 3 }, Column { name: "CAST(join_t2.t2_id AS Int64)", index: 3 })]
--------CoalescePartitionsExec
----------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
--------------MemoryExec: partitions=1, partition_sizes=[1]
--------ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, CAST(t2_id@0 AS Int64) as CAST(join_t2.t2_id AS Int64)]
----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
select *, join_t1.t1_id + 11
from join_t1, join_t2
where join_t1.t1_id + 11 = join_t2.t2_id
----
logical_plan
Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int, join_t2.t2_id, join_t2.t2_name, join_t2.t2_int, CAST(join_t1.t1_id AS Int64) + Int64(11)
--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@3 as t2_id, t2_name@4 as t2_name, t2_int@5 as t2_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
--ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@4 as t2_id, t2_name@5 as t2_name, t2_int@6 as t2_int]
----CoalesceBatchesExec: target_batch_size=4096
------HashJoinExec: mode=Partitioned, join_type=Inner, on=[(Column { name: "join_t1.t1_id + Int64(11)", index: 3 }, Column { name: "CAST(join_t2.t2_id AS Int64)", index: 3 })]
--------CoalesceBatchesExec: target_batch_size=4096
----------RepartitionExec: partitioning=Hash([Column { name: "join_t1.t1_id + Int64(11)", index: 3 }], 2), input_partitions=2
------------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
--------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
----------------MemoryExec: partitions=1, partition_sizes=[1]
--------CoalesceBatchesExec: target_batch_size=4096
----------RepartitionExec: partitioning=Hash([Column { name: "CAST(join_t2.t2_id AS Int64)", index: 3 }], 2), input_partitions=2
------------ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, CAST(t2_id@0 AS Int64) as CAST(join_t2.t2_id AS Int64)]
--------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
----------------MemoryExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.explain.logical_plan_only = true;

# TODO: both_side_expr_key_inner_join

# TODO: left_side_expr_key_inner_join

# TODO: right_side_expr_key_inner_join

# TODO: select_wildcard_with_expr_key_inner_join

# TODO: join_with_type_coercion_for_equi_expr

# TODO: join_only_with_filter

# TODO: type_coercion_join_with_filter_and_equi_expr

# TODO: test_cross_join_to_groupby_with_different_key_ordering

# TODO: subquery_to_join_with_both_side_expr

# TODO: subquery_to_join_with_multi_filter

# TODO: three_projection_exprs_subquery_to_join

# TODO: in_subquery_to_join_with_correlated_outer_filter

# TODO: not_in_subquery_to_join_with_correlated_outer_filter

# TODO: in_subquery_to_join_with_outer_filter

# TODO: two_in_subquery_to_join_with_outer_filter

# TODO: right_as_inner_table_nested_loop_join

# TODO: left_as_inner_table_nested_loop_join

# TODO: exists_subquery_to_join_expr_filter

# TODO: exists_subquery_to_join_inner_filter

# TODO: exists_subquery_to_join_outer_filter

# TODO: not_exists_subquery_to_join_expr_filter

# TODO: exists_distinct_subquery_to_join

# TODO: exists_distinct_subquery_to_join_with_expr


# Exists distinct subquery left anti join with literal

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_5.t2_id AS Int64) * Int64(2)
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--SubqueryAlias: __correlated_sq_5
----Aggregate: groupBy=[[join_t2.t2_id]], aggr=[[]]
------TableScan: join_t2 projection=[t2_id]

query ITI
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_7.t2_id AS Int64) * Int64(2)
--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
--SubqueryAlias: __correlated_sq_7
----Aggregate: groupBy=[[join_t2.t2_id]], aggr=[[]]
------TableScan: join_t2 projection=[t2_id]

query ITI
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.explain.logical_plan_only = false;
