# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#############
## Scalar Function Tests
#############

statement ok
CREATE TABLE t1(
  a INT,
  b INT,
  c INT,
  d INT
) as VALUES
  (1, 100, 567, 1024),
  (2, 1000, 123, 256),
  (3, 10000, 978, 2048)
;

# pi scalar function
query RRR rowsort
select pi(), pi() / 2, pi() / 3;
----
3.14159265359 1.570796326795 1.047197551197

# log scalar function
query RR rowsort
select log(2, 64) a, log(100) b union all select log(2, 8), log(10);
----
3 1
6 2

# log scalar function
query RRR rowsort
select log(a, 64) a, log(b), log(10, b) from t1;
----
3.7855785 4 4
6 3 3
Infinity 2 2

# log scalar nulls
query RR rowsort
select log(null, 64) a, log(null) b
----
NULL NULL

# log scalar nulls 1
query RR rowsort
select log(2, null) a, log(null) b
----
NULL NULL

# log scalar nulls 2
query RR rowsort
select log(null, null) a, log(null) b
----
NULL NULL

# log scalar ops with zero edgecases
# please see https://github.com/apache/arrow-datafusion/pull/5245#issuecomment-1426828382
query RR rowsort
select log(0) a, log(1, 64) b
----
-Infinity Infinity

# bitwise and with column and scalar
query I rowsort
select c & 856 from t1;
----
528
848
88

# bitwise or with column and scalar
query I rowsort
select c | 856 from t1;
----
891
895
986

# bitwise xor with column and scalar
query I rowsort
select c ^ 856 from t1;
----
138
367
803

# right shift with column and scalar
query I rowsort
select d >> 2 from t1;
----
256
512
64

# left shift with column and scalar
query I rowsort
select d << 2 from t1;
----
1024
4096
8192

statement ok
drop table t1


statement ok
create table t1(c1 varchar) as values ('a'), ('b'), ('c'), (null);

# case_when()
query I
SELECT
CASE WHEN c1 = 'a' THEN 1
 WHEN c1 = 'b' THEN 2
 END
FROM t1
----
1
2
NULL
NULL

# case_when_else()
query I
SELECT
CASE WHEN c1 = 'a' THEN 1
 WHEN c1 = 'b' THEN 2
 ELSE 999 END
FROM t1
----
1
2
999
999

# case_when_with_base_expr()
query I
SELECT
CASE c1 WHEN 'a' THEN 1
 WHEN 'b' THEN 2
 END
FROM t1
----
1
2
NULL
NULL

# case_when_else_with_base_expr()
query I
SELECT
CASE c1 WHEN 'a' THEN 1
 WHEN 'b' THEN 2
 ELSE 999 END
FROM t1
----
1
2
999
999

# case_when_else_with_null_contant()
query I
 SELECT
CASE WHEN c1 = 'a' THEN 1
 WHEN NULL THEN 2
 ELSE 999 END
FROM t1
----
1
999
999
999

statement ok
drop table t1


query T
SELECT CASE WHEN NULL THEN 'foo' ELSE 'bar' END
----
bar

# case_expr_with_null()
query I
select case when b is null then null else b end from (select a,b from (values (1,null),(2,3)) as t (a,b)) a;
----
NULL
3

query I
select case when b is null then null else b end from (select a,b from (values (1,1),(2,3)) as t (a,b)) a;
----
1
3

# case_expr_with_nulls()
query I
select case when b is null then null when b < 3 then null when b >=3 then b + 1 else b end from (select a,b from (values (1,null),(1,2),(2,3)) as t (a,b)) a
----
NULL
NULL
4

query I
select case b when 1 then null when 2 then null when 3 then b + 1 else b end from (select a,b from (values (1,null),(1,2),(2,3)) as t (a,b)) a;
----
NULL
NULL
4

# csv_query_sum_cast() {

statement ok
CREATE EXTERNAL TABLE aggregate_test_100 (
  c1  VARCHAR NOT NULL,
  c2  TINYINT NOT NULL,
  c3  SMALLINT NOT NULL,
  c4  SMALLINT,
  c5  INT,
  c6  BIGINT NOT NULL,
  c7  SMALLINT NOT NULL,
  c8  INT NOT NULL,
  c9  BIGINT UNSIGNED NOT NULL,
  c10 VARCHAR NOT NULL,
  c11 FLOAT NOT NULL,
  c12 DOUBLE NOT NULL,
  c13 VARCHAR NOT NULL
)
STORED AS CSV
WITH HEADER ROW
LOCATION '../../testing/data/csv/aggregate_test_100.csv'

# c8 = i32; c6 = i64
query TTT
SELECT arrow_typeof(c8), arrow_typeof(c6), arrow_typeof(c8 + c6) FROM aggregate_test_100 limit 1;
----
Int32 Int64 Int64


statement ok
drop table aggregate_test_100

statement ok
create table test_boolean(c1 boolean) as values (false), (null), (true);

statement ok
create table test_int32(c1 int) as values (0), (1), (null), (3);

## Note that test_float has a NaN (which is not possible to create in SQL) so it is registered via rust.

# query_not()

query B
SELECT NOT c1 FROM test_boolean
----
true
NULL
false


# query_is_null()

# Note the last value is NaN (not NULL)
query R
SELECT c1 from test_float;
----
1
NULL
NaN


query B
SELECT c1 IS NULL FROM test_float
----
false
true
false

# query_is_not_null()
query B
SELECT c1 IS NOT NULL FROM test_float
----
true
false
true


# query_is_true()
query B
SELECT c1 IS TRUE as t FROM test_boolean
----
false
false
true

# query_is_false()
query B
SELECT c1 IS FALSE as f FROM test_boolean
----
true
false
false

# query_is_not_true()

query B
SELECT c1 IS NOT TRUE as nt FROM test_boolean
----
true
true
false

# query_is_not_false()
query B
SELECT c1 IS NOT FALSE as nf FROM test_boolean
----
false
true
true


# query_is_unknown()
query B
SELECT c1 IS UNKNOWN as t FROM test_boolean
----
false
true
false

# query_is_not_unknown()
query B
SELECT c1 IS NOT UNKNOWN as t FROM test_boolean
----
true
false
true


# query_without_from()

query I
SELECT 1
----
1

query IIR
SELECT 1+2, 3/4, cos(0)
----
3 0 1


# query_scalar_minus_array()
query I
SELECT 4 - c1 FROM test_int32
----
4
3
NULL
1

# test_string_concat_operator()
# concat 2 strings
query T
SELECT 'aa' || 'b'
----
aab

# concat 4 strings as a string concat pipe.
query T
SELECT 'aa' || 'b' || 'cc' || 'd'
----
aabccd

# concat 2 strings and NULL, output should be NULL
query T
SELECT 'aa' || NULL || 'd'
----
NULL

# concat 1 strings and 2 numeric
query T
SELECT 'a' || 42 || 23.3
----
a4223.3

# test_not_expressions()

query BB
SELECT not(true), not(false)
----
false true

query BB
SELECT not(1), not(0)
----
-2 -1

query ?B
SELECT null, not(null)
----
NULL NULL

query error DataFusion error: Error during planning: NOT or BITWISE_NOT not supported for datatype: 'Utf8'
SELECT NOT('hi')

# test_negative_expressions()

query ??
SELECT null, -null
----
NULL NULL

statement ok
drop table test_boolean

statement ok
drop table test_int32
