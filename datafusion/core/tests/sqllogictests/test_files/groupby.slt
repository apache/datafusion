# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


statement ok
CREATE TABLE tab0(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
CREATE TABLE tab1(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
CREATE TABLE tab2(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
INSERT INTO tab0 VALUES(83,0,38)

statement ok
INSERT INTO tab0 VALUES(26,0,79)

statement ok
INSERT INTO tab0 VALUES(43,81,24)

statement ok
INSERT INTO tab1 VALUES(22,6,8)

statement ok
INSERT INTO tab1 VALUES(28,57,45)

statement ok
INSERT INTO tab1 VALUES(82,44,71)

statement ok
INSERT INTO tab2 VALUES(15,61,87)

statement ok
INSERT INTO tab2 VALUES(91,59,79)

statement ok
INSERT INTO tab2 VALUES(92,41,58)

query I rowsort
SELECT - tab1.col0 * 84 + + 38 AS col2 FROM tab1 GROUP BY tab1.col0
----
-1810
-2314
-6850

query I rowsort
SELECT + cor0.col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT DISTINCT - ( + col1 ) + - 51 AS col0 FROM tab1 AS cor0 GROUP BY col1
----
-108
-57
-95

query I rowsort
SELECT col1 * cor0.col1 * 56 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
194936
208376
94136

query I rowsort label-4
SELECT ALL + tab2.col1 / tab2.col1 FROM tab2 GROUP BY col1
----
1
1
1

query I rowsort
SELECT ALL + tab1.col0 FROM tab1 GROUP BY col0
----
22
28
82

query I rowsort
SELECT DISTINCT tab1.col0 AS col1 FROM tab1 GROUP BY tab1.col0
----
22
28
82

query I rowsort
SELECT ALL col2 FROM tab1 GROUP BY col2
----
45
71
8

query I rowsort
SELECT ALL + cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col0, cor0.col2
----
26
43
83

query III rowsort
SELECT DISTINCT * FROM tab0 AS cor0 GROUP BY cor0.col1, cor0.col2, cor0.col0
----
26 0 79
43 81 24
83 0 38

query III rowsort
SELECT * FROM tab0 AS cor0 GROUP BY cor0.col1, cor0.col2, cor0.col0
----
26 0 79
43 81 24
83 0 38

query I rowsort
SELECT - 9 * cor0.col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
-369
-531
-549

query I rowsort
SELECT DISTINCT - 21 FROM tab2 GROUP BY col2
----
-21

query I rowsort
SELECT DISTINCT - 97 AS col2 FROM tab1 GROUP BY col0
----
-97

query I rowsort
SELECT + ( - 1 ) AS col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
-1
-1
-1

query I rowsort
SELECT - + cor0.col1 FROM tab0, tab0 cor0 GROUP BY cor0.col1
----
-81
0

query I rowsort
SELECT + cor0.col0 + 36 AS col2 FROM tab0 AS cor0 GROUP BY col0
----
119
62
79

query I rowsort
SELECT cor0.col1 AS col1 FROM tab0 AS cor0 GROUP BY col1
----
0
81

query I rowsort
SELECT DISTINCT + cor0.col1 FROM tab2 cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT ALL + cor0.col0 + - col0 col1 FROM tab1 AS cor0 GROUP BY col0
----
0
0
0

query I rowsort
SELECT ALL 54 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
54
54
54

query I rowsort
SELECT 40 AS col1 FROM tab1 cor0 GROUP BY cor0.col0
----
40
40
40

query I rowsort
SELECT DISTINCT ( cor0.col0 ) AS col0 FROM tab0 AS cor0 GROUP BY cor0.col0
----
26
43
83

query I rowsort
SELECT 62 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col0
----
62
62
62

query I rowsort
SELECT 23 FROM tab2 GROUP BY tab2.col2
----
23
23
23

query I rowsort
SELECT + ( - tab0.col0 ) col2 FROM tab0, tab0 AS cor0 GROUP BY tab0.col0
----
-26
-43
-83

query I rowsort
SELECT + cor0.col1 FROM tab1 AS cor0 GROUP BY cor0.col1
----
44
57
6

query I rowsort
SELECT cor0.col1 FROM tab2 AS cor0 GROUP BY cor0.col1, cor0.col2
----
41
59
61

query I rowsort
SELECT DISTINCT + 80 + cor0.col2 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col2
----
104
118
159

query I rowsort
SELECT DISTINCT 30 * - 9 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
-270

query I rowsort
SELECT DISTINCT - col2 FROM tab1 AS cor0 GROUP BY col2
----
-45
-71
-8

query I rowsort
SELECT ALL - col2 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2
----
-45
-71
-8

query I rowsort
SELECT DISTINCT + 82 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col2
----
82

query I rowsort
SELECT 79 * 19 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col2
----
1501
1501
1501

query I rowsort
SELECT ALL ( + 68 ) FROM tab1 cor0 GROUP BY cor0.col2
----
68
68
68

query I rowsort
SELECT - col0 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
-22
-28
-82

query I rowsort
SELECT + 81 col2 FROM tab2 AS cor0 GROUP BY cor0.col0
----
81
81
81

query I rowsort
SELECT ALL cor0.col2 AS col1 FROM tab2 cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT ALL + cor0.col0 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col1, cor0.col0
----
22
28
82

query I rowsort
SELECT - cor0.col2 AS col0 FROM tab0 cor0 GROUP BY cor0.col2
----
-24
-38
-79

query I rowsort
SELECT cor0.col0 FROM tab1 AS cor0 GROUP BY col0, cor0.col1, cor0.col1
----
22
28
82

query I rowsort
SELECT 58 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col1
----
58
58

query I rowsort
SELECT ALL cor0.col1 + - 20 AS col1 FROM tab0 cor0 GROUP BY cor0.col1
----
-20
61

query I rowsort
SELECT ALL + col1 col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT DISTINCT - - 56 FROM tab2, tab0 AS cor0 GROUP BY cor0.col1
----
56

query I rowsort
SELECT - 10 AS col0 FROM tab2, tab1 AS cor0, tab2 AS cor1 GROUP BY cor1.col0
----
-10
-10
-10

query I rowsort
SELECT 31 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col1
----
31
31
31

query I rowsort
SELECT col2 AS col0 FROM tab0 cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort
SELECT + 70 AS col1 FROM tab0 GROUP BY col0
----
70
70
70

query I rowsort
SELECT DISTINCT cor0.col1 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT - cor0.col1 FROM tab2, tab2 AS cor0 GROUP BY cor0.col1
----
-41
-59
-61

query I rowsort
SELECT DISTINCT + tab0.col0 col1 FROM tab0 GROUP BY tab0.col0
----
26
43
83

query I rowsort
SELECT DISTINCT - cor0.col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
-24
-38
-79

query I rowsort
SELECT + cor0.col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT - 5 AS col2 FROM tab2, tab2 AS cor0, tab2 AS cor1 GROUP BY tab2.col1
----
-5
-5
-5

query I rowsort
SELECT DISTINCT 0 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
0

query I rowsort
SELECT DISTINCT - - tab2.col0 FROM tab2 GROUP BY col0
----
15
91
92

query III rowsort
SELECT DISTINCT * FROM tab2 AS cor0 GROUP BY cor0.col0, col1, cor0.col2
----
15 61 87
91 59 79
92 41 58

query I rowsort label-58
SELECT 9 / + cor0.col0 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col0, cor0.col2
----
0
0
0

query I rowsort
SELECT ( - 72 ) AS col1 FROM tab1 cor0 GROUP BY cor0.col0, cor0.col2
----
-72
-72
-72

query I rowsort
SELECT cor0.col0 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT ( col0 ) FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort label-62
SELECT ALL 59 / 26 FROM tab2 AS cor0 GROUP BY cor0.col0
----
2
2
2

query I rowsort
SELECT 15 FROM tab1 AS cor0 GROUP BY col2, col2
----
15
15
15

query I rowsort
SELECT CAST ( NULL AS INTEGER ) FROM tab0 AS cor0 GROUP BY cor0.col2, cor0.col2
----
NULL
NULL
NULL

query I rowsort
SELECT ALL - 79 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
-79
-79
-79

query I rowsort
SELECT ALL 69 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col2
----
69
69
69

query I rowsort
SELECT ALL 37 col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
37
37

query I rowsort
SELECT ALL 55 * 15 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2
----
825
825
825

query I rowsort
SELECT ( 63 ) FROM tab1 AS cor0 GROUP BY cor0.col2
----
63
63
63

query I rowsort
SELECT - cor0.col2 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col2
----
-45
-71
-8

query I rowsort
SELECT - col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
-58
-79
-87

query I rowsort
SELECT ALL 81 * 11 FROM tab2 AS cor0 GROUP BY col1, cor0.col0
----
891
891
891

query I rowsort
SELECT ALL 9 FROM tab2 AS cor0 GROUP BY col2
----
9
9
9

query I rowsort
SELECT DISTINCT ( - 31 ) col1 FROM tab1 GROUP BY tab1.col0
----
-31

query I rowsort label-75
SELECT + + cor0.col0 / - cor0.col0 FROM tab1, tab0 AS cor0 GROUP BY cor0.col0
----
-1
-1
-1

query I rowsort
SELECT cor0.col2 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT ALL cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
0
81

query I rowsort
SELECT ALL + - ( - tab0.col2 ) AS col0 FROM tab0 GROUP BY tab0.col2
----
24
38
79

query I rowsort
SELECT 72 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
72
72

query I rowsort
SELECT - 20 - + col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
-101
-20

query I rowsort
SELECT - - 63 FROM tab1 GROUP BY tab1.col0
----
63
63
63

query I rowsort
SELECT cor0.col2 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col2, col1
----
45
71
8

query I rowsort
SELECT + cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
0
81

query I rowsort
SELECT DISTINCT cor0.col1 FROM tab1 AS cor0 GROUP BY cor0.col1, cor0.col1
----
44
57
6

query I rowsort
SELECT cor0.col0 - col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
0
0
0

query I rowsort
SELECT 50 FROM tab0 AS cor0 GROUP BY cor0.col0
----
50
50
50

query I rowsort
SELECT - 18 AS col0 FROM tab1 cor0 GROUP BY cor0.col2
----
-18
-18
-18

query I rowsort
SELECT + cor0.col2 * cor0.col2 FROM tab0 AS cor0 GROUP BY cor0.col0, cor0.col2
----
1444
576
6241

query I rowsort
SELECT ALL 91 / cor0.col1 FROM tab2 AS cor0 GROUP BY col1, cor0.col1
----
1
1
2

query I rowsort
SELECT cor0.col2 AS col2 FROM tab0 AS cor0 GROUP BY col2
----
24
38
79

query I rowsort
SELECT ALL + 85 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col0
----
85
85
85

query I rowsort
SELECT + 49 AS col2 FROM tab0 cor0 GROUP BY cor0.col0
----
49
49
49

query I rowsort
SELECT cor0.col2 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col2
----
45
71
8

query I rowsort
SELECT - col0 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
-15
-91
-92

query I rowsort
SELECT DISTINCT - 87 AS col1 FROM tab0 AS cor0 GROUP BY col0
----
-87

query I rowsort
SELECT + 39 FROM tab0 AS cor0 GROUP BY col1
----
39
39

query I rowsort
SELECT ALL cor0.col2 * + col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
3364
6241
7569

query I rowsort
SELECT 40 FROM tab0 GROUP BY tab0.col1
----
40
40

query I rowsort
SELECT tab1.col2 AS col0 FROM tab1 GROUP BY tab1.col2
----
45
71
8

query I rowsort
SELECT tab2.col0 FROM tab2 GROUP BY tab2.col0
----
15
91
92

query I rowsort
SELECT + col0 * + col0 FROM tab0 GROUP BY tab0.col0
----
1849
676
6889

query I rowsort
SELECT ALL cor0.col2 + cor0.col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
158
48
76

query I rowsort
SELECT DISTINCT cor0.col2 FROM tab1 cor0 GROUP BY cor0.col2
----
45
71
8

query I rowsort
SELECT ALL + cor0.col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort
SELECT cor0.col2 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort label-106
SELECT - 53 / cor0.col0 col0 FROM tab1 cor0 GROUP BY cor0.col0
----
-1
-2
0

query I rowsort
SELECT cor0.col1 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
0
81

query I rowsort
SELECT DISTINCT + cor0.col1 col0 FROM tab2 cor0 GROUP BY cor0.col1, cor0.col0
----
41
59
61

query I rowsort
SELECT - cor0.col2 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col0, cor0.col2
----
-45
-71
-8

query I rowsort
SELECT cor0.col1 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col1, cor0.col1
----
0
81

query I rowsort
SELECT 25 AS col1 FROM tab2 cor0 GROUP BY cor0.col0
----
25
25
25

query I rowsort
SELECT cor0.col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT DISTINCT + 6 FROM tab1 cor0 GROUP BY col2, cor0.col0
----
6

query I rowsort
SELECT cor0.col2 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT ALL 72 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
72
72
72

query I rowsort
SELECT ALL + 73 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col0
----
73
73
73

query I rowsort
SELECT tab1.col0 AS col2 FROM tab1 GROUP BY col0
----
22
28
82

query I rowsort
SELECT + cor0.col1 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT DISTINCT - cor0.col1 col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
-81
0

query I rowsort
SELECT cor0.col0 * 51 FROM tab1 AS cor0 GROUP BY col0
----
1122
1428
4182

query I rowsort
SELECT ALL + 89 FROM tab2, tab1 AS cor0, tab1 AS cor1 GROUP BY cor0.col2
----
89
89
89

query I rowsort
SELECT ALL + cor0.col0 - + cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
0
0
0

query I rowsort
SELECT ALL 71 AS col0 FROM tab0 GROUP BY col1
----
71
71

query I rowsort
SELECT - ( + cor0.col0 ) AS col1 FROM tab0 AS cor0 GROUP BY cor0.col0
----
-26
-43
-83

query I rowsort
SELECT 62 FROM tab1 AS cor0 GROUP BY cor0.col0
----
62
62
62

query I rowsort
SELECT ALL - 97 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col0
----
-97
-97
-97

query I rowsort
SELECT DISTINCT + 29 * ( cor0.col0 ) + + 47 FROM tab1 cor0 GROUP BY cor0.col0
----
2425
685
859

query I rowsort
SELECT DISTINCT col2 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT ALL 40 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col2
----
40
40
40

query I rowsort
SELECT cor0.col1 + cor0.col1 AS col2 FROM tab2 cor0 GROUP BY cor0.col1
----
118
122
82

query I rowsort
SELECT ( + cor0.col1 ) FROM tab2 AS cor0 GROUP BY cor0.col1, cor0.col1
----
41
59
61

query I rowsort
SELECT cor0.col1 * + cor0.col1 col1 FROM tab1 AS cor0 GROUP BY cor0.col1
----
1936
3249
36

query I rowsort
SELECT ALL + cor0.col0 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col0
----
22
28
82

query I rowsort
SELECT - 9 FROM tab2 AS cor0 GROUP BY cor0.col1, cor0.col1, col2
----
-9
-9
-9

query I rowsort
SELECT ALL - 7 * cor0.col1 FROM tab1 AS cor0 GROUP BY cor0.col0, cor0.col1
----
-308
-399
-42

query I rowsort
SELECT - 21 AS col2 FROM tab1 cor0 GROUP BY cor0.col1, cor0.col1
----
-21
-21
-21

query I rowsort
SELECT DISTINCT tab1.col2 FROM tab1 GROUP BY tab1.col2
----
45
71
8

query I rowsort
SELECT DISTINCT - 76 FROM tab2 GROUP BY tab2.col2
----
-76

query I rowsort
SELECT DISTINCT - cor0.col1 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col1
----
-41
-59
-61

query I rowsort
SELECT cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
0
81

query I rowsort
SELECT ALL - cor0.col2 + - 55 AS col1 FROM tab0 AS cor0 GROUP BY col2
----
-134
-79
-93

query I rowsort
SELECT - + 28 FROM tab0, tab2 cor0 GROUP BY tab0.col1
----
-28
-28

query I rowsort
SELECT ALL col1 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT ALL + 35 * 14 AS col1 FROM tab2 GROUP BY tab2.col1
----
490
490
490

query I rowsort
SELECT ALL cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0, cor0.col1
----
15
91
92

query I rowsort
SELECT DISTINCT - cor0.col2 * 18 + + 56 FROM tab2 AS cor0 GROUP BY col2
----
-1366
-1510
-988

query I rowsort
SELECT cor0.col0 FROM tab0 cor0 GROUP BY col0
----
26
43
83

query I rowsort
SELECT ALL - 38 AS col1 FROM tab2 GROUP BY tab2.col2
----
-38
-38
-38

query I rowsort
SELECT - 79 FROM tab0, tab0 cor0, tab0 AS cor1 GROUP BY cor1.col0
----
-79
-79
-79

query I rowsort
SELECT + cor0.col2 FROM tab1 cor0 GROUP BY cor0.col2, cor0.col1
----
45
71
8

query I rowsort
SELECT cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col2, cor0.col0
----
26
43
83

query I rowsort
SELECT cor0.col2 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col2, cor0.col0
----
24
38
79

query I rowsort
SELECT + - 57 AS col1 FROM tab2 GROUP BY tab2.col2
----
-57
-57
-57

query I rowsort
SELECT ALL - cor0.col1 FROM tab2 cor0 GROUP BY cor0.col1
----
-41
-59
-61

query I rowsort
SELECT DISTINCT cor0.col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT - cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col0
----
-26
-43
-83

query I rowsort
SELECT ( - cor0.col1 ) FROM tab1 AS cor0 GROUP BY cor0.col1
----
-44
-57
-6

query I rowsort
SELECT DISTINCT - cor0.col2 FROM tab0 cor0 GROUP BY cor0.col2, cor0.col2
----
-24
-38
-79

query I rowsort
SELECT DISTINCT tab1.col1 * ( + tab1.col1 ) FROM tab1 GROUP BY col1
----
1936
3249
36

query I rowsort
SELECT - cor0.col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
-41
-59
-61

query III rowsort
SELECT * FROM tab2 AS cor0 GROUP BY cor0.col1, cor0.col2, cor0.col0
----
15 61 87
91 59 79
92 41 58

query I rowsort
SELECT + 83 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
83
83
83

query I rowsort
SELECT + ( 97 ) + - tab0.col1 FROM tab0, tab1 AS cor0 GROUP BY tab0.col1
----
16
97

query I rowsort
SELECT 61 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2
----
61
61
61

query I rowsort
SELECT ALL cor0.col2 FROM tab0 cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort
SELECT cor0.col2 FROM tab0, tab1 AS cor0 GROUP BY cor0.col2
----
45
71
8

query I rowsort
SELECT + - 3 FROM tab2 GROUP BY col1
----
-3
-3
-3

query I rowsort
SELECT DISTINCT + 96 FROM tab2 GROUP BY tab2.col1
----
96

query I rowsort
SELECT ALL 81 FROM tab1 AS cor0 GROUP BY cor0.col1
----
81
81
81

query I rowsort
SELECT cor0.col0 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col0
----
26
43
83

query I rowsort
SELECT - + 51 col2 FROM tab2, tab2 AS cor0 GROUP BY cor0.col1
----
-51
-51
-51

query I rowsort
SELECT cor0.col1 + - cor0.col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
0
0
0

query I rowsort
SELECT 35 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col1
----
35
35
35

query I rowsort
SELECT + tab2.col1 col0 FROM tab2 GROUP BY tab2.col1
----
41
59
61

query I rowsort
SELECT 37 AS col1 FROM tab0 AS cor0 GROUP BY col0
----
37
37
37

query I rowsort
SELECT + cor0.col1 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61

query I rowsort
SELECT cor0.col1 FROM tab2, tab1 AS cor0 GROUP BY cor0.col1
----
44
57
6

query I rowsort
SELECT ALL - col0 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
-22
-28
-82

query I rowsort
SELECT + 77 AS col1 FROM tab1 AS cor0 CROSS JOIN tab0 AS cor1 GROUP BY cor0.col2
----
77
77
77

query I rowsort
SELECT ALL cor0.col0 col1 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT + cor0.col2 * + cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col0, cor0.col2
----
1032
2054
3154

query I rowsort
SELECT DISTINCT 39 FROM tab0 AS cor0 GROUP BY cor0.col0
----
39

query III rowsort
SELECT DISTINCT * FROM tab1 AS cor0 GROUP BY cor0.col0, cor0.col2, cor0.col1
----
22 6 8
28 57 45
82 44 71

query I rowsort
SELECT ALL + 28 FROM tab2 cor0 GROUP BY cor0.col0
----
28
28
28

query I rowsort
SELECT cor0.col0 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col0
----
22
28
82

query I rowsort
SELECT ALL cor0.col2 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col2
----
45
71
8

query I rowsort
SELECT + ( col0 ) * col0 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col0
----
225
8281
8464

query I rowsort label-188
SELECT - 21 - + 57 / cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col0
----
-21
-22
-23

query I rowsort
SELECT + 37 + cor0.col0 * cor0.col2 FROM tab2 AS cor0 GROUP BY cor0.col2, col0
----
1342
5373
7226

query I rowsort
SELECT ALL cor0.col2 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col0
----
45
71
8

query III rowsort
SELECT * FROM tab1 AS cor0 GROUP BY col2, cor0.col1, cor0.col0
----
22 6 8
28 57 45
82 44 71

query I rowsort
SELECT ( cor0.col2 ) AS col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort
SELECT DISTINCT 28 FROM tab0 AS cor0 GROUP BY cor0.col0
----
28

query I rowsort
SELECT ALL - 18 FROM tab0, tab1 AS cor0 GROUP BY cor0.col0
----
-18
-18
-18

query I rowsort
SELECT DISTINCT cor0.col2 FROM tab0 AS cor0 GROUP BY cor0.col2
----
24
38
79

query I rowsort
SELECT + col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT - cor0.col0 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col1, cor0.col0
----
-22
-28
-82

query I rowsort
SELECT 29 FROM tab1 AS cor0 GROUP BY cor0.col1, cor0.col0
----
29
29
29

query I rowsort
SELECT - + cor0.col0 - 39 AS col0 FROM tab0, tab0 cor0 GROUP BY cor0.col0
----
-122
-65
-82

query I rowsort
SELECT ALL 45 AS col0 FROM tab0 GROUP BY tab0.col0
----
45
45
45

query I rowsort
SELECT + 74 AS col1 FROM tab1 GROUP BY tab1.col0
----
74
74
74

query I rowsort
SELECT cor0.col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort label-203
SELECT - cor0.col2 + CAST ( 80 AS INTEGER ) FROM tab1 AS cor0 GROUP BY col2
----
35
72
9

query I rowsort
SELECT DISTINCT - cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
-81
0

query I rowsort
SELECT - 51 * + cor0.col2 FROM tab0, tab2 cor0, tab1 AS cor1 GROUP BY cor0.col2
----
-2958
-4029
-4437

query I rowsort
SELECT ALL + col0 * cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
225
8281
8464

query I rowsort
SELECT DISTINCT ( col0 ) FROM tab0 AS cor0 GROUP BY cor0.col0
----
26
43
83

query I rowsort
SELECT 87 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
87
87
87

query I rowsort
SELECT + cor0.col0 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT DISTINCT + 45 col0 FROM tab1 AS cor0 GROUP BY col0
----
45

query I rowsort label-211
SELECT ALL CAST ( NULL AS INTEGER ) FROM tab2 AS cor0 GROUP BY col1
----
NULL
NULL
NULL

query I rowsort
SELECT ALL cor0.col1 + col1 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col1
----
0
162

query I rowsort
SELECT - cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
-81
0

query I rowsort
SELECT DISTINCT + 99 * 76 + + tab2.col1 AS col2 FROM tab2 GROUP BY col1
----
7565
7583
7585

query I rowsort
SELECT ALL 54 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
54
54
54

query I rowsort
SELECT + cor0.col2 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col2, cor0.col0
----
58
79
87

query I rowsort
SELECT cor0.col0 + + 87 FROM tab1 AS cor0 GROUP BY cor0.col0
----
109
115
169

query I rowsort
SELECT cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0, cor0.col1, cor0.col0
----
15
91
92

query I rowsort
SELECT ALL col0 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT DISTINCT - cor0.col0 - + cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
-182
-184
-30

query I rowsort
SELECT ALL - 68 * + cor0.col1 FROM tab0 AS cor0 GROUP BY cor0.col1, cor0.col1
----
-5508
0

query I rowsort
SELECT col2 AS col2 FROM tab0 AS cor0 GROUP BY cor0.col1, cor0.col2
----
24
38
79

query I rowsort
SELECT ALL - 11 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col2
----
-11
-11
-11

query I rowsort
SELECT 66 AS col1 FROM tab1 AS cor0 GROUP BY cor0.col2
----
66
66
66

query I rowsort
SELECT - cor0.col2 FROM tab2 AS cor0 GROUP BY cor0.col2
----
-58
-79
-87

query I rowsort
SELECT ALL 37 FROM tab2, tab0 AS cor0 GROUP BY cor0.col1
----
37
37

query I rowsort
SELECT DISTINCT + 20 col2 FROM tab0 GROUP BY tab0.col1
----
20

query I rowsort
SELECT 42 FROM tab0 cor0 GROUP BY col2
----
42
42
42

query I rowsort
SELECT ALL - cor0.col1 AS col1 FROM tab1 cor0 GROUP BY cor0.col1
----
-44
-57
-6

query I rowsort
SELECT - col2 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col2
----
-58
-79
-87

query I rowsort
SELECT DISTINCT + 86 FROM tab1 GROUP BY tab1.col2
----
86

query I rowsort
SELECT + cor0.col1 AS col1 FROM tab2, tab0 cor0 GROUP BY cor0.col1
----
0
81

query I rowsort
SELECT - 13 FROM tab0 cor0 GROUP BY cor0.col1
----
-13
-13

query I rowsort
SELECT tab1.col0 AS col1 FROM tab1 GROUP BY tab1.col0
----
22
28
82

query I rowsort
SELECT ALL cor0.col1 * cor0.col1 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col1
----
1681
3481
3721

query I rowsort
SELECT - cor0.col0 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col0
----
-15
-91
-92

query I rowsort
SELECT cor0.col2 FROM tab1 AS cor0 GROUP BY cor0.col0, cor0.col2
----
45
71
8

query I rowsort
SELECT ALL - 67 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
-67
-67
-67

query I rowsort
SELECT + 75 AS col2 FROM tab1 cor0 GROUP BY cor0.col0
----
75
75
75

query I rowsort
SELECT ALL cor0.col1 FROM tab0 AS cor0 GROUP BY col0, cor0.col1
----
0
0
81

query I rowsort
SELECT ALL + cor0.col1 FROM tab0 AS cor0 GROUP BY col1
----
0
81

query I rowsort
SELECT DISTINCT - 38 - - cor0.col0 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col0
----
-12
45
5

query I rowsort
SELECT + cor0.col0 + - col0 + 21 AS col0 FROM tab0 AS cor0 GROUP BY cor0.col0
----
21
21
21

query I rowsort
SELECT + cor0.col0 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col0, cor0.col0
----
22
28
82

query I rowsort
SELECT ALL - cor0.col0 FROM tab0 AS cor0 GROUP BY cor0.col0, cor0.col0
----
-26
-43
-83

query III rowsort
SELECT * FROM tab0 AS cor0 GROUP BY cor0.col2, cor0.col1, cor0.col0
----
26 0 79
43 81 24
83 0 38

query I rowsort
SELECT DISTINCT + + tab2.col2 FROM tab2, tab1 AS cor0 GROUP BY tab2.col2
----
58
79
87

query I rowsort
SELECT cor0.col0 AS col1 FROM tab2 AS cor0 GROUP BY cor0.col0
----
15
91
92

query I rowsort
SELECT col0 AS col0 FROM tab2 AS cor0 GROUP BY cor0.col0
----
15
91
92

query I rowsort
SELECT - cor0.col0 AS col1 FROM tab1 AS cor0 GROUP BY col0
----
-22
-28
-82

query I rowsort
SELECT DISTINCT ( + 71 ) col1 FROM tab1 GROUP BY tab1.col2
----
71

query I rowsort
SELECT + 96 * 29 col1 FROM tab2, tab1 AS cor0 GROUP BY tab2.col0
----
2784
2784
2784

query I rowsort
SELECT + 3 FROM tab2 AS cor0 GROUP BY cor0.col2
----
3
3
3

query I rowsort
SELECT 37 FROM tab0 AS cor0 GROUP BY col0
----
37
37
37

query I rowsort
SELECT 82 FROM tab0 cor0 GROUP BY cor0.col1
----
82
82

query I rowsort
SELECT cor0.col2 FROM tab2 cor0 GROUP BY cor0.col2
----
58
79
87

query I rowsort
SELECT DISTINCT - 87 FROM tab1, tab2 AS cor0, tab2 AS cor1 GROUP BY tab1.col0
----
-87

query I rowsort
SELECT 55 FROM tab1 AS cor0 GROUP BY cor0.col2, cor0.col1
----
55
55
55

query I rowsort
SELECT DISTINCT 35 FROM tab0 cor0 GROUP BY cor0.col2, cor0.col0
----
35

query I rowsort
SELECT cor0.col0 FROM tab2 cor0 GROUP BY col0
----
15
91
92

query I rowsort
SELECT - cor0.col2 AS col1 FROM tab1 AS cor0 GROUP BY col2
----
-45
-71
-8

query I rowsort
SELECT ALL ( cor0.col2 ) AS col1 FROM tab2, tab1 AS cor0 GROUP BY cor0.col2
----
45
71
8

query I rowsort
SELECT DISTINCT - col2 FROM tab1 GROUP BY tab1.col2
----
-45
-71
-8

query I rowsort
SELECT 38 FROM tab1 AS cor0 GROUP BY cor0.col1, cor0.col1
----
38
38
38

query I rowsort
SELECT - 16 * - cor0.col0 * 47 FROM tab0 AS cor0 GROUP BY cor0.col0
----
19552
32336
62416

query I rowsort
SELECT - 31 FROM tab2 AS cor0 GROUP BY cor0.col2
----
-31
-31
-31

query I rowsort
SELECT ( + 34 ) AS col1 FROM tab1 AS cor0 GROUP BY cor0.col2
----
34
34
34

query I rowsort
SELECT cor0.col2 AS col0 FROM tab1 AS cor0 GROUP BY cor0.col2
----
45
71
8

query I rowsort
SELECT DISTINCT 21 FROM tab0 AS cor0 GROUP BY cor0.col2
----
21

query I rowsort
SELECT 62 AS col2 FROM tab0 cor0 GROUP BY cor0.col1, cor0.col2
----
62
62
62

query I rowsort
SELECT cor0.col0 FROM tab1 cor0 GROUP BY cor0.col0, cor0.col1
----
22
28
82

query I rowsort
SELECT DISTINCT cor0.col0 FROM tab2 AS cor0 GROUP BY cor0.col0, col1
----
15
91
92

query I rowsort
SELECT DISTINCT cor0.col0 AS col2 FROM tab1 AS cor0 GROUP BY cor0.col0
----
22
28
82

query I rowsort
SELECT ALL - ( 30 ) * + cor0.col1 AS col2 FROM tab2 AS cor0 GROUP BY cor0.col1
----
-1230
-1770
-1830

query I rowsort
SELECT DISTINCT 94 AS col1 FROM tab0 AS cor0 GROUP BY cor0.col1
----
94

query I rowsort
SELECT DISTINCT + col1 FROM tab2 AS cor0 GROUP BY cor0.col1
----
41
59
61



# Columns in the table are a,b,c,d. Source is CsvExec which is ordered by
# a,b,c column. Column a has cardinality 2, column b has cardinality 4.
# Column c has cardinality 100 (unique entries). Column d has cardinality 5.
statement ok
CREATE UNBOUNDED EXTERNAL TABLE annotated_data_infinite2 (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH HEADER ROW
WITH ORDER (a ASC, b ASC, c ASC)
LOCATION 'tests/data/window_2.csv';

# Create a table with 2 ordered columns.
# In the next step, we will expect to observe the removed sort execs.
statement ok
CREATE EXTERNAL TABLE multiple_ordered_table (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH HEADER ROW
WITH ORDER (a ASC, b ASC)
WITH ORDER (c ASC)
LOCATION 'tests/data/window_2.csv';

# Expected a sort exec for b DESC
query TT
EXPLAIN SELECT a FROM multiple_ordered_table ORDER BY b DESC;
----
logical_plan
Projection: multiple_ordered_table.a
--Sort: multiple_ordered_table.b DESC NULLS FIRST
----TableScan: multiple_ordered_table projection=[a, b]
physical_plan
ProjectionExec: expr=[a@0 as a]
--SortExec: expr=[b@1 DESC]
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST], has_header=true

# Final plan shouldn't have SortExec c ASC,
# because table already satisfies this ordering.
query TT
EXPLAIN SELECT a FROM multiple_ordered_table ORDER BY c ASC;
----
logical_plan
Projection: multiple_ordered_table.a
--Sort: multiple_ordered_table.c ASC NULLS LAST
----TableScan: multiple_ordered_table projection=[a, c]
physical_plan
ProjectionExec: expr=[a@0 as a]
--CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, c], output_ordering=[a@0 ASC NULLS LAST], has_header=true

# Final plan shouldn't have SortExec a ASC, b ASC,
# because table already satisfies this ordering.
query TT
EXPLAIN SELECT a FROM multiple_ordered_table ORDER BY a ASC, b ASC;
----
logical_plan
Projection: multiple_ordered_table.a
--Sort: multiple_ordered_table.a ASC NULLS LAST, multiple_ordered_table.b ASC NULLS LAST
----TableScan: multiple_ordered_table projection=[a, b]
physical_plan
ProjectionExec: expr=[a@0 as a]
--CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST], has_header=true

# test_window_agg_sort
statement ok
set datafusion.execution.target_partitions = 1;

# test_source_sorted_groupby
query TT
EXPLAIN SELECT a, b,
 SUM(c) as summation1
 FROM annotated_data_infinite2
 GROUP BY b, a
----
logical_plan
Projection: annotated_data_infinite2.a, annotated_data_infinite2.b, SUM(annotated_data_infinite2.c) AS summation1
--Aggregate: groupBy=[[annotated_data_infinite2.b, annotated_data_infinite2.a]], aggr=[[SUM(annotated_data_infinite2.c)]]
----TableScan: annotated_data_infinite2 projection=[a, b, c]
physical_plan
ProjectionExec: expr=[a@1 as a, b@0 as b, SUM(annotated_data_infinite2.c)@2 as summation1]
--AggregateExec: mode=Single, gby=[b@1 as b, a@0 as a], aggr=[SUM(annotated_data_infinite2.c)], ordering_mode=FullyOrdered
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], has_header=true


query III
 SELECT a, b,
 SUM(c) as summation1
 FROM annotated_data_infinite2
 GROUP BY b, a
----
0 0 300
0 1 925
1 2 1550
1 3 2175


# test_source_sorted_groupby2
# If ordering is not important for the aggregation function, we should ignore the ordering requirement. Hence
# "ORDER BY a DESC" should have no effect.
query TT
EXPLAIN SELECT a, d,
 SUM(c ORDER BY a DESC) as summation1
 FROM annotated_data_infinite2
 GROUP BY d, a
----
logical_plan
Projection: annotated_data_infinite2.a, annotated_data_infinite2.d, SUM(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST] AS summation1
--Aggregate: groupBy=[[annotated_data_infinite2.d, annotated_data_infinite2.a]], aggr=[[SUM(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]]]
----TableScan: annotated_data_infinite2 projection=[a, c, d]
physical_plan
ProjectionExec: expr=[a@1 as a, d@0 as d, SUM(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]@2 as summation1]
--AggregateExec: mode=Single, gby=[d@2 as d, a@0 as a], aggr=[SUM(annotated_data_infinite2.c)], ordering_mode=PartiallyOrdered
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, c, d], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST], has_header=true

query III
SELECT a, d,
 SUM(c ORDER BY a DESC) as summation1
 FROM annotated_data_infinite2
 GROUP BY d, a
----
0 0 292
0 2 196
0 1 315
0 4 164
0 3 258
1 0 622
1 3 299
1 1 1043
1 4 913
1 2 848

# test_source_sorted_groupby3

query TT
EXPLAIN SELECT a, b, FIRST_VALUE(c ORDER BY a DESC) as first_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
logical_plan
Projection: annotated_data_infinite2.a, annotated_data_infinite2.b, FIRST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST] AS first_c
--Aggregate: groupBy=[[annotated_data_infinite2.a, annotated_data_infinite2.b]], aggr=[[FIRST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]]]
----TableScan: annotated_data_infinite2 projection=[a, b, c]
physical_plan
ProjectionExec: expr=[a@0 as a, b@1 as b, FIRST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]@2 as first_c]
--AggregateExec: mode=Single, gby=[a@0 as a, b@1 as b], aggr=[LAST_VALUE(annotated_data_infinite2.c)], ordering_mode=FullyOrdered
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], has_header=true

query III
SELECT a, b, FIRST_VALUE(c ORDER BY a DESC) as first_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
0 0 24
0 1 49
1 2 74
1 3 99

# test_source_sorted_groupby4

query TT
EXPLAIN SELECT a, b, LAST_VALUE(c ORDER BY a DESC) as last_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
logical_plan
Projection: annotated_data_infinite2.a, annotated_data_infinite2.b, LAST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST] AS last_c
--Aggregate: groupBy=[[annotated_data_infinite2.a, annotated_data_infinite2.b]], aggr=[[LAST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]]]
----TableScan: annotated_data_infinite2 projection=[a, b, c]
physical_plan
ProjectionExec: expr=[a@0 as a, b@1 as b, LAST_VALUE(annotated_data_infinite2.c) ORDER BY [annotated_data_infinite2.a DESC NULLS FIRST]@2 as last_c]
--AggregateExec: mode=Single, gby=[a@0 as a, b@1 as b], aggr=[FIRST_VALUE(annotated_data_infinite2.c)], ordering_mode=FullyOrdered
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], has_header=true

query III
SELECT a, b, LAST_VALUE(c ORDER BY a DESC) as last_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
0 0 0
0 1 25
1 2 50
1 3 75

# when LAST_VALUE, or FIRST_VALUE value do not contain ordering requirement
# queries should still work, However, result depends on the scanning order and
# not deterministic
query TT
EXPLAIN SELECT a, b, LAST_VALUE(c) as last_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
logical_plan
Projection: annotated_data_infinite2.a, annotated_data_infinite2.b, LAST_VALUE(annotated_data_infinite2.c) AS last_c
--Aggregate: groupBy=[[annotated_data_infinite2.a, annotated_data_infinite2.b]], aggr=[[LAST_VALUE(annotated_data_infinite2.c)]]
----TableScan: annotated_data_infinite2 projection=[a, b, c]
physical_plan
ProjectionExec: expr=[a@0 as a, b@1 as b, LAST_VALUE(annotated_data_infinite2.c)@2 as last_c]
--AggregateExec: mode=Single, gby=[a@0 as a, b@1 as b], aggr=[LAST_VALUE(annotated_data_infinite2.c)], ordering_mode=FullyOrdered
----CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], has_header=true

query III
SELECT a, b, LAST_VALUE(c) as last_c
  FROM annotated_data_infinite2
  GROUP BY a, b
----
0 0 24
0 1 49
1 2 74
1 3 99

statement ok
drop table annotated_data_infinite2;

# create a table for testing
statement ok
CREATE TABLE sales_global (zip_code INT,
          country VARCHAR(3),
          sn INT,
          ts TIMESTAMP,
          currency VARCHAR(3),
          amount FLOAT
        ) as VALUES
          (0, 'GRC', 0, '2022-01-01 06:00:00'::timestamp, 'EUR', 30.0),
          (1, 'FRA', 1, '2022-01-01 08:00:00'::timestamp, 'EUR', 50.0),
          (1, 'TUR', 2, '2022-01-01 11:30:00'::timestamp, 'TRY', 75.0),
          (1, 'FRA', 3, '2022-01-02 12:00:00'::timestamp, 'EUR', 200.0),
          (1, 'TUR', 4, '2022-01-03 10:00:00'::timestamp, 'TRY', 100.0),
          (0, 'GRC', 4, '2022-01-03 10:00:00'::timestamp, 'EUR', 80.0)

# test_ordering_sensitive_aggregation
# ordering sensitive requirement should add a SortExec in the final plan. To satisfy amount ASC
# in the aggregation
statement ok
set datafusion.execution.target_partitions = 1;

query TT
EXPLAIN SELECT country, (ARRAY_AGG(amount ORDER BY amount ASC)) AS amounts
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS amounts
--Aggregate: groupBy=[[sales_global.country]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]]]
----TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@1 as amounts]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount)]
----SortExec: expr=[amount@1 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]


query T?
SELECT country, (ARRAY_AGG(amount ORDER BY amount ASC)) AS amounts
  FROM sales_global
  GROUP BY country
----
GRC [30.0, 80.0]
FRA [50.0, 200.0]
TUR [75.0, 100.0]

# test_ordering_sensitive_aggregation2
# We should be able to satisfy the finest requirement among all aggregators, when we have multiple aggregators.
# Hence final plan should have SortExec: expr=[amount@1 DESC] to satisfy array_agg requirement.
query TT
EXPLAIN SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
          SUM(s.amount) AS sum1
        FROM sales_global AS s
        GROUP BY s.country
----
logical_plan
Projection: s.country, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST] AS amounts, SUM(s.amount) AS sum1
--Aggregate: groupBy=[[s.country]], aggr=[[ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST], SUM(s.amount)]]
----SubqueryAlias: s
------TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST]@1 as amounts, SUM(s.amount)@2 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(s.amount), SUM(s.amount)]
----SortExec: expr=[amount@1 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?R
SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
    SUM(s.amount) AS sum1
  FROM sales_global AS s
  GROUP BY s.country
----
FRA [200.0, 50.0] 250
TUR [100.0, 75.0] 175
GRC [80.0, 30.0] 110

# test_ordering_sensitive_multiple_req
# Currently we do not support multiple ordering requirement for aggregation
# once this support is added. This test should change
# See issue: https://github.com/sqlparser-rs/sqlparser-rs/issues/875
statement error DataFusion error: This feature is not implemented: ARRAY_AGG only supports a single ORDER BY expression\. Got 2
SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC, s.country DESC) AS amounts,
    SUM(s.amount ORDER BY s.amount DESC) AS sum1
  FROM sales_global AS s
  GROUP BY s.country

# test_ordering_sensitive_aggregation3
# When different aggregators have conflicting requirements, we cannot satisfy all of them in current implementation.
# test below should raise Plan Error.
statement error DataFusion error: This feature is not implemented: Conflicting ordering requirements in aggregate functions is not supported
SELECT ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
    ARRAY_AGG(s.amount ORDER BY s.amount ASC) AS amounts2,
    ARRAY_AGG(s.amount ORDER BY s.sn ASC) AS amounts3
  FROM sales_global AS s
  GROUP BY s.country

# test_ordering_sensitive_aggregation4
# If aggregators can work with bounded memory (FullyOrdered or PartiallyOrdered mode), we should append requirement to
# the existing ordering. This enables us to still work with bounded memory, and also satisfy aggregation requirement.
# This test checks for whether we can satisfy aggregation requirement in FullyOrdered mode.
query TT
EXPLAIN SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
        SUM(s.amount) AS sum1
          FROM (SELECT *
            FROM sales_global
            ORDER BY country) AS s
          GROUP BY s.country
----
logical_plan
Projection: s.country, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST] AS amounts, SUM(s.amount) AS sum1
--Aggregate: groupBy=[[s.country]], aggr=[[ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST], SUM(s.amount)]]
----SubqueryAlias: s
------Sort: sales_global.country ASC NULLS LAST
--------TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST]@1 as amounts, SUM(s.amount)@2 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(s.amount), SUM(s.amount)], ordering_mode=FullyOrdered
----SortExec: expr=[country@0 ASC NULLS LAST,amount@1 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?R
SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
  SUM(s.amount) AS sum1
    FROM (SELECT *
      FROM sales_global
      ORDER BY country) AS s
    GROUP BY s.country
----
FRA [200.0, 50.0] 250
GRC [80.0, 30.0] 110
TUR [100.0, 75.0] 175

# test_ordering_sensitive_aggregation5
# If aggregators can work with bounded memory (FullyOrdered or PartiallyOrdered mode), we should be append requirement to
# the existing ordering. This enables us to still work with bounded memory, and also satisfy aggregation requirement.
# This test checks for whether we can satisfy aggregation requirement in PartiallyOrdered mode.
query TT
EXPLAIN SELECT s.country, s.zip_code, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
        SUM(s.amount) AS sum1
          FROM (SELECT *
            FROM sales_global
            ORDER BY country) AS s
          GROUP BY s.country, s.zip_code
----
logical_plan
Projection: s.country, s.zip_code, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST] AS amounts, SUM(s.amount) AS sum1
--Aggregate: groupBy=[[s.country, s.zip_code]], aggr=[[ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST], SUM(s.amount)]]
----SubqueryAlias: s
------Sort: sales_global.country ASC NULLS LAST
--------TableScan: sales_global projection=[zip_code, country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, zip_code@1 as zip_code, ARRAY_AGG(s.amount) ORDER BY [s.amount DESC NULLS FIRST]@2 as amounts, SUM(s.amount)@3 as sum1]
--AggregateExec: mode=Single, gby=[country@1 as country, zip_code@0 as zip_code], aggr=[ARRAY_AGG(s.amount), SUM(s.amount)], ordering_mode=PartiallyOrdered
----SortExec: expr=[country@1 ASC NULLS LAST,amount@2 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query TI?R
SELECT s.country, s.zip_code, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
    SUM(s.amount) AS sum1
      FROM (SELECT *
        FROM sales_global
        ORDER BY country) AS s
      GROUP BY s.country, s.zip_code
----
FRA 1 [200.0, 50.0] 250
GRC 0 [80.0, 30.0] 110
TUR 1 [100.0, 75.0] 175

# test_ordering_sensitive_aggregation6
# If aggregators can work with bounded memory (FullyOrdered or PartiallyOrdered mode), we should be append requirement to
# the existing ordering. When group by expressions contain aggregation requirement, we shouldn't append redundant expression.
# Hence in the final plan SortExec should be SortExec: expr=[country@0 DESC] not SortExec: expr=[country@0 ASC NULLS LAST,country@0 DESC]
query TT
EXPLAIN SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.country DESC) AS amounts,
        SUM(s.amount) AS sum1
          FROM (SELECT *
            FROM sales_global
            ORDER BY country) AS s
          GROUP BY s.country
----
logical_plan
Projection: s.country, ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST] AS amounts, SUM(s.amount) AS sum1
--Aggregate: groupBy=[[s.country]], aggr=[[ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST], SUM(s.amount)]]
----SubqueryAlias: s
------Sort: sales_global.country ASC NULLS LAST
--------TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST]@1 as amounts, SUM(s.amount)@2 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(s.amount), SUM(s.amount)], ordering_mode=FullyOrdered
----SortExec: expr=[country@0 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?R
SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.amount DESC) AS amounts,
  SUM(s.amount) AS sum1
    FROM (SELECT *
      FROM sales_global
      ORDER BY country) AS s
    GROUP BY s.country
----
FRA [200.0, 50.0] 250
GRC [80.0, 30.0] 110
TUR [100.0, 75.0] 175

# test_ordering_sensitive_aggregation7
# Lexicographical ordering requirement can be given as
# argument to the aggregate functions
query TT
EXPLAIN SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.country DESC, s.amount DESC) AS amounts,
        SUM(s.amount) AS sum1
          FROM (SELECT *
            FROM sales_global
            ORDER BY country) AS s
          GROUP BY s.country
----
logical_plan
Projection: s.country, ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST, s.amount DESC NULLS FIRST] AS amounts, SUM(s.amount) AS sum1
--Aggregate: groupBy=[[s.country]], aggr=[[ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST, s.amount DESC NULLS FIRST], SUM(s.amount)]]
----SubqueryAlias: s
------Sort: sales_global.country ASC NULLS LAST
--------TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(s.amount) ORDER BY [s.country DESC NULLS FIRST, s.amount DESC NULLS FIRST]@1 as amounts, SUM(s.amount)@2 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(s.amount), SUM(s.amount)], ordering_mode=FullyOrdered
----SortExec: expr=[country@0 ASC NULLS LAST,amount@1 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?R
SELECT s.country, ARRAY_AGG(s.amount ORDER BY s.country DESC, s.amount DESC) AS amounts,
  SUM(s.amount) AS sum1
    FROM (SELECT *
      FROM sales_global
      ORDER BY country) AS s
    GROUP BY s.country
----
FRA [200.0, 50.0] 250
GRC [80.0, 30.0] 110
TUR [100.0, 75.0] 175

# test_reverse_aggregate_expr
# Some of the Aggregators can be reversed, by this way we can still run aggregators without re-ordering
# that have contradictory requirements at first glance.
query TT
EXPLAIN SELECT country, ARRAY_AGG(amount ORDER BY amount DESC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS fv2
--Aggregate: groupBy=[[sales_global.country]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST], FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]]]
----TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@1 as amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@2 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@3 as fv2]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount), LAST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)]
----SortExec: expr=[amount@1 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?RR
SELECT country, ARRAY_AGG(amount ORDER BY amount DESC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
----
FRA [200.0, 50.0] 50 50
TUR [100.0, 75.0] 75 75
GRC [80.0, 30.0] 30 30

# test_reverse_aggregate_expr2
# Some of the Aggregators can be reversed, by this way we can still run aggregators without re-ordering
# that have contradictory requirements at first glance.
query TT
EXPLAIN SELECT country, ARRAY_AGG(amount ORDER BY amount ASC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS fv2
--Aggregate: groupBy=[[sales_global.country]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST], FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]]]
----TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@1 as amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@2 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@3 as fv2]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount), FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount)]
----SortExec: expr=[amount@1 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]

query T?RR
SELECT country, ARRAY_AGG(amount ORDER BY amount ASC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
----
GRC [30.0, 80.0] 30 30
FRA [50.0, 200.0] 50 50
TUR [75.0, 100.0] 75 75

# test_reverse_aggregate_expr3
# Some of the Aggregators can be reversed, by this way we can still run aggregators without re-ordering
# that have contradictory requirements at first glance. This algorithm shouldn't depend
# on the order of the aggregation expressions.
query TT
EXPLAIN SELECT country, FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2,
  ARRAY_AGG(amount ORDER BY amount ASC) AS amounts
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS fv2, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS amounts
--Aggregate: groupBy=[[sales_global.country]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST], ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]]]
----TableScan: sales_global projection=[country, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@1 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@2 as fv2, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@3 as amounts]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount), ARRAY_AGG(sales_global.amount)]
----SortExec: expr=[amount@1 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]

query TRR?
SELECT country, FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2,
  ARRAY_AGG(amount ORDER BY amount ASC) AS amounts
  FROM sales_global
  GROUP BY country
----
GRC 30 30 [30.0, 80.0]
FRA 50 50 [50.0, 200.0]
TUR 75 75 [75.0, 100.0]

# test_reverse_aggregate_expr4
# Ordering requirement by the ordering insensitive aggregators shouldn't have effect on
# final plan. Hence seemingly conflicting requirements by SUM and ARRAY_AGG shouldn't raise error.
query TT
EXPLAIN SELECT country, SUM(amount ORDER BY ts DESC) AS sum1,
  ARRAY_AGG(amount ORDER BY amount ASC) AS amounts
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS sum1, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS amounts
--Aggregate: groupBy=[[sales_global.country]], aggr=[[SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST], ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]]]
----TableScan: sales_global projection=[country, ts, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@1 as sum1, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@2 as amounts]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[SUM(sales_global.amount), ARRAY_AGG(sales_global.amount)]
----SortExec: expr=[amount@2 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]

query TR?
SELECT country, SUM(amount ORDER BY ts DESC) AS sum1,
  ARRAY_AGG(amount ORDER BY amount ASC) AS amounts
  FROM sales_global
  GROUP BY country
----
GRC 110 [30.0, 80.0]
FRA 250 [50.0, 200.0]
TUR 175 [75.0, 100.0]

# test_reverse_aggregate_expr5
# If all of the ordering sensitive aggregation functions are reversible
# we should be able to reverse requirements, if this helps to remove a SortExec.
# Hence in query below, FIRST_VALUE, and LAST_VALUE should be reversed to calculate its result according to `ts ASC` ordering.
# Please note that after `ts ASC` ordering because of inner query. There is no SortExec in the final plan.
query TT
EXPLAIN SELECT country, FIRST_VALUE(amount ORDER BY ts DESC) as fv1,
  LAST_VALUE(amount ORDER BY ts DESC) as lv1,
  SUM(amount ORDER BY ts DESC) as sum1
  FROM (SELECT *
    FROM sales_global
    ORDER BY ts ASC)
  GROUP BY country
----
logical_plan
Projection: sales_global.country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS lv1, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS sum1
--Aggregate: groupBy=[[sales_global.country]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST], SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]]]
----Sort: sales_global.ts ASC NULLS LAST
------TableScan: sales_global projection=[country, ts, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@1 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@2 as lv1, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@3 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[LAST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount), SUM(sales_global.amount)]
----SortExec: expr=[ts@1 ASC NULLS LAST]
------MemoryExec: partitions=1, partition_sizes=[1]

query TRRR
SELECT country, FIRST_VALUE(amount ORDER BY ts DESC) as fv1,
  LAST_VALUE(amount ORDER BY ts DESC) as lv1,
  SUM(amount ORDER BY ts DESC) as sum1
  FROM (SELECT *
    FROM sales_global
    ORDER BY ts ASC)
  GROUP BY country
----
GRC 80 30 110
FRA 200 50 250
TUR 100 75 175

# If existing ordering doesn't satisfy requirement, we should do calculations
# on naive requirement (by convention, otherwise the final plan will be unintuitive),
# even if reverse ordering is possible.
# hence, below query should add `SortExec(ts DESC)` to the final plan.
query TT
EXPLAIN SELECT country, FIRST_VALUE(amount ORDER BY ts DESC) as fv1,
    LAST_VALUE(amount ORDER BY ts DESC) as lv1,
    SUM(amount ORDER BY ts DESC) as sum1
  FROM sales_global
  GROUP BY country
----
logical_plan
Projection: sales_global.country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS lv1, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS sum1
--Aggregate: groupBy=[[sales_global.country]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST], SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]]]
----TableScan: sales_global projection=[country, ts, amount]
physical_plan
ProjectionExec: expr=[country@0 as country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@1 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@2 as lv1, SUM(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@3 as sum1]
--AggregateExec: mode=Single, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount), SUM(sales_global.amount)]
----SortExec: expr=[ts@1 DESC]
------MemoryExec: partitions=1, partition_sizes=[1]

query TRRR
SELECT country, FIRST_VALUE(amount ORDER BY ts DESC) as fv1,
    LAST_VALUE(amount ORDER BY ts DESC) as lv1,
    SUM(amount ORDER BY ts DESC) as sum1
  FROM sales_global
  GROUP BY country
----
TUR 100 75 175
GRC 80 30 110
FRA 200 50 250

# Run order-sensitive aggregators in multiple partitions
statement ok
set datafusion.execution.target_partitions = 8;

# order-sensitive FIRST_VALUE and LAST_VALUE aggregators should work in
# multi-partitions without group by also.
query TT
EXPLAIN SELECT country, FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts ASC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
logical_plan
Sort: sales_global.country ASC NULLS LAST
--Projection: sales_global.country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv2
----Aggregate: groupBy=[[sales_global.country]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]]]
------TableScan: sales_global projection=[country, ts, amount]
physical_plan
SortPreservingMergeExec: [country@0 ASC NULLS LAST]
--SortExec: expr=[country@0 ASC NULLS LAST]
----ProjectionExec: expr=[country@0 as country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@1 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@2 as fv2]
------AggregateExec: mode=FinalPartitioned, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)]
--------SortExec: expr=[ts@1 ASC NULLS LAST]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([country@0], 8), input_partitions=8
--------------AggregateExec: mode=Partial, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)], ordering_mode=None
----------------SortExec: expr=[ts@1 ASC NULLS LAST]
------------------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
--------------------MemoryExec: partitions=1, partition_sizes=[1]

query TRR
SELECT country, FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts ASC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
FRA 50 200
GRC 30 80
TUR 75 100

# Conversion in between FIRST_VALUE and LAST_VALUE to resolve
# contradictory requirements should work in multi partitions.
query TT
EXPLAIN SELECT country, FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts DESC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
logical_plan
Sort: sales_global.country ASC NULLS LAST
--Projection: sales_global.country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS fv2
----Aggregate: groupBy=[[sales_global.country]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]]]
------TableScan: sales_global projection=[country, ts, amount]
physical_plan
SortPreservingMergeExec: [country@0 ASC NULLS LAST]
--SortExec: expr=[country@0 ASC NULLS LAST]
----ProjectionExec: expr=[country@0 as country, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@1 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@2 as fv2]
------AggregateExec: mode=FinalPartitioned, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount)]
--------SortExec: expr=[ts@1 ASC NULLS LAST]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([country@0], 8), input_partitions=8
--------------AggregateExec: mode=Partial, gby=[country@0 as country], aggr=[FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount)], ordering_mode=None
----------------SortExec: expr=[ts@1 ASC NULLS LAST]
------------------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
--------------------MemoryExec: partitions=1, partition_sizes=[1]

query TRR
SELECT country, FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts DESC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
FRA 50 50
GRC 30 30
TUR 75 75

# order-sensitive FIRST_VALUE and LAST_VALUE aggregators should work in
# multi-partitions without group by also.
query TT
EXPLAIN SELECT FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts ASC) AS fv2
  FROM sales_global
----
logical_plan
Projection: FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv2
--Aggregate: groupBy=[[]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]]]
----TableScan: sales_global projection=[ts, amount]
physical_plan
ProjectionExec: expr=[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@0 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@1 as fv2]
--AggregateExec: mode=Final, gby=[], aggr=[FIRST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)]
----SortPreservingMergeExec: [ts@0 ASC NULLS LAST]
------AggregateExec: mode=Partial, gby=[], aggr=[FIRST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)], ordering_mode=None
--------SortExec: expr=[ts@0 ASC NULLS LAST]
----------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

query RR
SELECT FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts ASC) AS fv2
  FROM sales_global
----
30 80

# Conversion in between FIRST_VALUE and LAST_VALUE to resolve
# contradictory requirements should work in multi partitions.
query TT
EXPLAIN SELECT FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts DESC) AS fv2
  FROM sales_global
----
logical_plan
Projection: FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS fv2
--Aggregate: groupBy=[[]], aggr=[[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]]]
----TableScan: sales_global projection=[ts, amount]
physical_plan
ProjectionExec: expr=[FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@0 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@1 as fv2]
--AggregateExec: mode=Final, gby=[], aggr=[FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount)]
----SortPreservingMergeExec: [ts@0 ASC NULLS LAST]
------AggregateExec: mode=Partial, gby=[], aggr=[FIRST_VALUE(sales_global.amount), FIRST_VALUE(sales_global.amount)], ordering_mode=None
--------SortExec: expr=[ts@0 ASC NULLS LAST]
----------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

query RR
SELECT FIRST_VALUE(amount ORDER BY ts ASC) AS fv1,
  LAST_VALUE(amount ORDER BY ts DESC) AS fv2
  FROM sales_global
----
30 30

# ARRAY_AGG should work in multiple partitions
query TT
EXPLAIN SELECT ARRAY_AGG(amount ORDER BY ts ASC) AS array_agg1
  FROM sales_global
----
logical_plan
Projection: ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST] AS array_agg1
--Aggregate: groupBy=[[]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]]]
----TableScan: sales_global projection=[ts, amount]
physical_plan
ProjectionExec: expr=[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts ASC NULLS LAST]@0 as array_agg1]
--AggregateExec: mode=Final, gby=[], aggr=[ARRAY_AGG(sales_global.amount)]
----SortPreservingMergeExec: [ts@0 ASC NULLS LAST]
------AggregateExec: mode=Partial, gby=[], aggr=[ARRAY_AGG(sales_global.amount)], ordering_mode=None
--------SortExec: expr=[ts@0 ASC NULLS LAST]
----------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

query ?
SELECT ARRAY_AGG(amount ORDER BY ts ASC) AS array_agg1
  FROM sales_global
----
[30.0, 50.0, 75.0, 200.0, 100.0, 80.0]

# ARRAY_AGG should work in multiple partitions
query TT
EXPLAIN SELECT ARRAY_AGG(amount ORDER BY ts DESC) AS array_agg1
  FROM sales_global
----
logical_plan
Projection: ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST] AS array_agg1
--Aggregate: groupBy=[[]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]]]
----TableScan: sales_global projection=[ts, amount]
physical_plan
ProjectionExec: expr=[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.ts DESC NULLS FIRST]@0 as array_agg1]
--AggregateExec: mode=Final, gby=[], aggr=[ARRAY_AGG(sales_global.amount)]
----SortPreservingMergeExec: [ts@0 DESC]
------AggregateExec: mode=Partial, gby=[], aggr=[ARRAY_AGG(sales_global.amount)], ordering_mode=None
--------SortExec: expr=[ts@0 DESC]
----------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

query ?
SELECT ARRAY_AGG(amount ORDER BY ts DESC) AS array_agg1
  FROM sales_global
----
[100.0, 80.0, 200.0, 75.0, 50.0, 30.0]

# ARRAY_AGG should work in multiple partitions
query TT
EXPLAIN SELECT ARRAY_AGG(amount ORDER BY amount ASC) AS array_agg1
  FROM sales_global
----
logical_plan
Projection: ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS array_agg1
--Aggregate: groupBy=[[]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]]]
----TableScan: sales_global projection=[amount]
physical_plan
ProjectionExec: expr=[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@0 as array_agg1]
--AggregateExec: mode=Final, gby=[], aggr=[ARRAY_AGG(sales_global.amount)]
----SortPreservingMergeExec: [amount@0 ASC NULLS LAST]
------AggregateExec: mode=Partial, gby=[], aggr=[ARRAY_AGG(sales_global.amount)], ordering_mode=None
--------SortExec: expr=[amount@0 ASC NULLS LAST]
----------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
------------MemoryExec: partitions=1, partition_sizes=[1]

query ?
SELECT ARRAY_AGG(amount ORDER BY amount ASC) AS array_agg1
  FROM sales_global
----
[30.0, 50.0, 75.0, 80.0, 100.0, 200.0]

# ARRAY_AGG should work in multiple partitions
query TT
EXPLAIN SELECT country, ARRAY_AGG(amount ORDER BY amount ASC) AS array_agg1
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
logical_plan
Sort: sales_global.country ASC NULLS LAST
--Projection: sales_global.country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS array_agg1
----Aggregate: groupBy=[[sales_global.country]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]]]
------TableScan: sales_global projection=[country, amount]
physical_plan
SortPreservingMergeExec: [country@0 ASC NULLS LAST]
--SortExec: expr=[country@0 ASC NULLS LAST]
----ProjectionExec: expr=[country@0 as country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@1 as array_agg1]
------AggregateExec: mode=FinalPartitioned, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount)]
--------SortExec: expr=[amount@1 ASC NULLS LAST]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([country@0], 8), input_partitions=8
--------------AggregateExec: mode=Partial, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount)], ordering_mode=None
----------------SortExec: expr=[amount@1 ASC NULLS LAST]
------------------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
--------------------MemoryExec: partitions=1, partition_sizes=[1]

query T?
SELECT country, ARRAY_AGG(amount ORDER BY amount ASC) AS array_agg1
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
FRA [50.0, 200.0]
GRC [30.0, 80.0]
TUR [75.0, 100.0]

# ARRAY_AGG, FIRST_VALUE, LAST_VALUE should work in multiple partitions
query TT
EXPLAIN SELECT country, ARRAY_AGG(amount ORDER BY amount DESC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
logical_plan
Sort: sales_global.country ASC NULLS LAST
--Projection: sales_global.country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST] AS fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST] AS fv2
----Aggregate: groupBy=[[sales_global.country]], aggr=[[ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST], FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST], LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]]]
------TableScan: sales_global projection=[country, amount]
physical_plan
SortPreservingMergeExec: [country@0 ASC NULLS LAST]
--SortExec: expr=[country@0 ASC NULLS LAST]
----ProjectionExec: expr=[country@0 as country, ARRAY_AGG(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@1 as amounts, FIRST_VALUE(sales_global.amount) ORDER BY [sales_global.amount ASC NULLS LAST]@2 as fv1, LAST_VALUE(sales_global.amount) ORDER BY [sales_global.amount DESC NULLS FIRST]@3 as fv2]
------AggregateExec: mode=FinalPartitioned, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount), LAST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)]
--------SortExec: expr=[amount@1 DESC]
----------CoalesceBatchesExec: target_batch_size=8192
------------RepartitionExec: partitioning=Hash([country@0], 8), input_partitions=8
--------------AggregateExec: mode=Partial, gby=[country@0 as country], aggr=[ARRAY_AGG(sales_global.amount), LAST_VALUE(sales_global.amount), LAST_VALUE(sales_global.amount)], ordering_mode=None
----------------SortExec: expr=[amount@1 DESC]
------------------RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1
--------------------MemoryExec: partitions=1, partition_sizes=[1]

query T?RR
SELECT country, ARRAY_AGG(amount ORDER BY amount DESC) AS amounts,
  FIRST_VALUE(amount ORDER BY amount ASC) AS fv1,
  LAST_VALUE(amount ORDER BY amount DESC) AS fv2
  FROM sales_global
  GROUP BY country
  ORDER BY country
----
FRA [200.0, 50.0] 50 50
GRC [80.0, 30.0] 30 30
TUR [100.0, 75.0] 75 75
