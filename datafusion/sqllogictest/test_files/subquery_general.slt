# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# make sure to a batch size smaller than row number of the table.
statement ok
set datafusion.execution.batch_size = 2;

#############
## Subquery Tests
#############


#############
## Setup test data table
#############
# there tables for subquery
statement ok
CREATE TABLE t0(t0_id INT, t0_name TEXT, t0_int INT) AS VALUES
(11, 'o', 6),
(22, 'p', 7),
(33, 'q', 8),
(44, 'r', 9);

statement ok
CREATE TABLE t1(t1_id INT, t1_name TEXT, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4);


statement ok
CREATE TABLE t2(t2_id INT, t2_name TEXT, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3);

statement ok
CREATE TABLE t3(t3_id INT PRIMARY KEY, t3_name TEXT, t3_int INT) AS VALUES
(11, 'e', 3),
(22, 'f', 1),
(44, 'g', 3),
(55, 'h', 3);

# in_subquery_to_join_with_correlated_outer_filter
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id + 12 in (
                           select t2.t2_id + 1 from t2 where t1.t1_int > 0
                       )
----
11 a 1
33 c 3
44 d 4

# not_in_subquery_to_join_with_correlated_outer_filter
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id + 12 not in (
                               select t2.t2_id + 1 from t2 where t1.t1_int > 0
                           )
----
22 b 2


# wrapped_not_in_subquery_to_join_with_correlated_outer_filter
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where not t1.t1_id + 12 in (
                               select t2.t2_id + 1 from t2 where t1.t1_int > 0
                           )
----
22 b 2

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
11 3
22 1
33 NULL
44 3

query IR rowsort
SELECT t1_id, (SELECT sum(t2_int * 1.0) + 1 FROM t2 WHERE t2.t2_id = t1.t1_id) as t2_sum from t1
----
11 4
22 2
33 NULL
44 4

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id group by t2_id, 'a') as t2_sum from t1
----
11 3
22 1
33 NULL
44 3

query II rowsort
SELECT t1_id, (SELECT sum(t2_int) FROM t2 WHERE t2.t2_id = t1.t1_id having sum(t2_int) < 3) as t2_sum from t1
----
11 NULL
22 1
33 NULL
44 NULL

#non_aggregated_correlated_scalar_subquery_unique
query II rowsort
SELECT t1_id, (SELECT t3_int FROM t3 WHERE t3.t3_id = t1.t1_id) as t3_int from t1
----
11 3
22 1
33 NULL
44 3

query II rowsort
SELECT t1_id, (SELECT a FROM (select 1 as a) WHERE a = t1.t1_int) as t2_int from t1
----
11 1
22 NULL
33 NULL
44 NULL

query IT rowsort
SELECT t1_id, t1_name FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t2_id = t1_id limit 1)
----
11 a
22 b
44 d

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id > 40 or t1.t1_id in (select t2.t2_id from t2 where t1.t1_int > 0)
----
11 a 1
22 b 2
44 d 4

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id = 11 or t1.t1_id + 12 not in (select t2.t2_id + 1 from t2 where t1.t1_int > 0)
----
11 a 1
22 b 2

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id > 40 or exists (select * from t2 where t1.t1_id = t2.t2_id)
----
11 a 1
22 b 2
44 d 4

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id > 40 or not exists (select * from t2 where t1.t1_id = t2.t2_id)
----
33 c 3
44 d 4

query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id in (select t3.t3_id from t3) and (t1.t1_id > 40 or t1.t1_id in (select t2.t2_id from t2 where t1.t1_int > 0))
----
11 a 1
22 b 2
44 d 4

# Handle duplicate values in exists query
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where t1.t1_id > 40 or exists (select * from t2 cross join t3 where t1.t1_id = t2.t2_id)
----
11 a 1
22 b 2
44 d 4

# Nested subqueries
query ITI rowsort
select t1.t1_id,
       t1.t1_name,
       t1.t1_int
from t1
where exists (
    select * from t2 where t1.t1_id = t2.t2_id OR exists (
        select * from t3 where t2.t2_id = t3.t3_id
    )
)
----
11 a 1
22 b 2
33 c 3
44 d 4

query IT
SELECT t1_id, t1_name FROM t1 WHERE NOT EXISTS (SELECT * FROM t2 WHERE t2_id = t1_id limit 0)
----
11 a
22 b
33 c
44 d

query II rowsort
SELECT t1_id, (SELECT count(*) FROM t2 WHERE t2.t2_int = t1.t1_int) from t1
----
11 1
22 0
33 3
44 0

query II rowsort
SELECT t1_id, (SELECT count(*) FROM t2 WHERE t2.t2_int = t1.t1_int) as cnt from t1
----
11 1
22 0
33 3
44 0

query II rowsort
SELECT t1_id, (SELECT count(*) as _cnt FROM t2 WHERE t2.t2_int = t1.t1_int) as cnt from t1
----
11 1
22 0
33 3
44 0

query II rowsort
SELECT t1_id, (SELECT count(*) + 2 as _cnt FROM t2 WHERE t2.t2_int = t1.t1_int) from t1
----
11 3
22 2
33 5
44 2

query I rowsort
select t1.t1_int from t1 where (select count(*) from t2 where t1.t1_id = t2.t2_id) < t1.t1_int
----
2
3
4

query II rowsort
SELECT t1_id, (SELECT count(*) + 2 as cnt_plus_2 FROM t2 WHERE t2.t2_int = t1.t1_int having count(*) >1) from t1
----
11 NULL
22 NULL
33 5
44 NULL

query II rowsort
SELECT t1_id, (SELECT count(*) + 2 as cnt_plus_2 FROM t2 WHERE t2.t2_int = t1.t1_int having count(*) = 0) from t1
----
11 NULL
22 2
33 NULL
44 2

query I rowsort
select t1.t1_int from t1 group by t1.t1_int having (select count(*) from t2 where t1.t1_int = t2.t2_int) = 0
----
2
4

query I rowsort
select t1.t1_int from t1 where (select cnt from (select count(*) as cnt, sum(t2_int) from t2 where t1.t1_int = t2.t2_int)) = 0
----
2
4

query I rowsort
select t1.t1_int from t1 where (
    select cnt_plus_one + 1 as cnt_plus_two from (
        select cnt + 1 as cnt_plus_one from (
            select count(*) as cnt, sum(t2_int) s from t2 where t1.t1_int = t2.t2_int having cnt = 0
        )
    )
) = 2
----
2
4

query I rowsort
select t1.t1_int from t1 where
       (select case when count(*) = 1 then null else count(*) end as cnt from t2 where t2.t2_int = t1.t1_int) = 0
----
2
4

query TT
explain select t1_int > (select avg(t1_int) from t1) from t1
----
logical_plan
01)Projection: CAST(t1.t1_int AS Float64) > avg(t1.t1_int) AS t1.t1_int > avg(t1.t1_int)
02)--LeftSingle Join(ComparisonJoin): 
03)----TableScan: t1 projection=[t1_int]
04)----Aggregate: groupBy=[[]], aggr=[[avg(CAST(t1.t1_int AS Float64))]]
05)------Filter: Boolean(true)
06)--------TableScan: t1 projection=[t1_int]
physical_plan
01)ProjectionExec: expr=[CAST(t1_int@0 AS Float64) > avg(t1.t1_int)@1 as t1.t1_int > avg(t1.t1_int)]
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----NestedLoopJoinExec: join_type=LeftSingle
04)------DataSourceExec: partitions=1, partition_sizes=[2]
05)------AggregateExec: mode=Final, gby=[], aggr=[avg(t1.t1_int)]
06)--------CoalescePartitionsExec
07)----------AggregateExec: mode=Partial, gby=[], aggr=[avg(t1.t1_int)]
08)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
09)--------------DataSourceExec: partitions=1, partition_sizes=[2]


# fail
query B rowsort
select t1_int > (select avg(t1_int) from t1) from t1
----
false
false
true
true

query TT
explain SELECT t1_id, (
    SELECT case when max(t2.t2_id) > 1 then 'a' else 'b' end 
        FROM t2 WHERE t2.t2_int = t1.t1_int
) x from t1
----
logical_plan
01)Projection: t1.t1_id, CASE WHEN max(t2.t2_id) > Int64(1) THEN Utf8("a") ELSE Utf8("b") END AS x
02)--LeftSingle Join(ComparisonJoin): t1.t1_int = t1_dscan_2.t1_t1_int Null=Null
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----Projection: CASE WHEN max(t2.t2_id) > Int32(1) THEN Utf8("a") ELSE Utf8("b") END AS CASE WHEN max(t2.t2_id) > Int64(1) THEN Utf8("a") ELSE Utf8("b") END, t1_dscan_2.t1_t1_int
05)------Left Join(DelimJoin): t1_dscan_2.t1_t1_int = t1_dscan_1.t1_t1_int Null=Null
06)--------Projection: t1.t1_int AS t1_dscan_2.t1_t1_int
07)----------DelimGet: t1.t1_int
08)--------Aggregate: groupBy=[[t1_dscan_1.t1_t1_int]], aggr=[[max(t2.t2_id)]]
09)----------Projection: t2.t2_id, t1_dscan_1.t1_t1_int
10)------------Inner Join(ComparisonJoin): t2.t2_int = t1_dscan_1.t1_t1_int
11)--------------Filter: Boolean(true)
12)----------------TableScan: t2 projection=[t2_id, t2_int]
13)--------------Projection: t1.t1_int AS t1_dscan_1.t1_t1_int
14)----------------DelimGet: t1.t1_int
physical_plan
01)ProjectionExec: expr=[t1_id@0 as t1_id, CASE WHEN max(t2.t2_id) > Int64(1) THEN Utf8("a") ELSE Utf8("b") END@1 as x]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=LeftSingle, on=[(t1_int@1, t1_t1_int@1)], projection=[t1_id@0, CASE WHEN max(t2.t2_id) > Int64(1) THEN Utf8("a") ELSE Utf8("b") END@2], NullsEqual: true
04)------DataSourceExec: partitions=1, partition_sizes=[2]
05)------ProjectionExec: expr=[CASE WHEN max(t2.t2_id)@0 > 1 THEN a ELSE b END as CASE WHEN max(t2.t2_id) > Int64(1) THEN Utf8("a") ELSE Utf8("b") END, t1_t1_int@1 as t1_t1_int]
06)--------CoalesceBatchesExec: target_batch_size=2
07)----------HashJoinExec: mode=CollectLeft, join_type=Right, on=[(t1_t1_int@0, t1_t1_int@0)], projection=[max(t2.t2_id)@1, t1_t1_int@2], NullsEqual: true
08)------------CoalescePartitionsExec
09)--------------AggregateExec: mode=FinalPartitioned, gby=[t1_t1_int@0 as t1_t1_int], aggr=[max(t2.t2_id)]
10)----------------CoalesceBatchesExec: target_batch_size=2
11)------------------RepartitionExec: partitioning=Hash([t1_t1_int@0], 4), input_partitions=4
12)--------------------AggregateExec: mode=Partial, gby=[t1_t1_int@1 as t1_t1_int], aggr=[max(t2.t2_id)]
13)----------------------ProjectionExec: expr=[t2_id@1 as t2_id, t1_t1_int@0 as t1_t1_int]
14)------------------------CoalesceBatchesExec: target_batch_size=2
15)--------------------------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_t1_int@0, t2_int@1)], projection=[t1_t1_int@0, t2_id@1]
16)----------------------------ProjectionExec: expr=[t1_int@0 as t1_t1_int]
17)------------------------------AggregateExec: mode=Final, gby=[t1_int@0 as t1_int], aggr=[]
18)--------------------------------DataSourceExec: partitions=1, partition_sizes=[2]
19)----------------------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
20)------------------------------DataSourceExec: partitions=1, partition_sizes=[2]
21)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
22)--------------ProjectionExec: expr=[t1_int@0 as t1_t1_int]
23)----------------AggregateExec: mode=Final, gby=[t1_int@0 as t1_int], aggr=[]
24)------------------DataSourceExec: partitions=1, partition_sizes=[2]

query IT rowsort
SELECT t1_id, (SELECT case when max(t2.t2_id) > 1 then 'a' else 'b' end FROM t2 WHERE t2.t2_int = t1.t1_int) x from t1
----
11 a
22 b
33 a
44 b

query TT 
explain SELECT t1_id, (SELECT max(t2.t2_id) is null FROM t2 WHERE t2.t2_int = t1.t1_int) x from t1
----
logical_plan
01)Projection: t1.t1_id, max(t2.t2_id) IS NULL AS x
02)--LeftSingle Join(ComparisonJoin): t1.t1_int = t1_dscan_2.t1_t1_int Null=Null
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----Projection: max(t2.t2_id) IS NULL, t1_dscan_2.t1_t1_int
05)------Left Join(DelimJoin): t1_dscan_2.t1_t1_int = t1_dscan_1.t1_t1_int Null=Null
06)--------Projection: t1.t1_int AS t1_dscan_2.t1_t1_int
07)----------DelimGet: t1.t1_int
08)--------Aggregate: groupBy=[[t1_dscan_1.t1_t1_int]], aggr=[[max(t2.t2_id)]]
09)----------Projection: t2.t2_id, t1_dscan_1.t1_t1_int
10)------------Inner Join(ComparisonJoin): t2.t2_int = t1_dscan_1.t1_t1_int
11)--------------Filter: Boolean(true)
12)----------------TableScan: t2 projection=[t2_id, t2_int]
13)--------------Projection: t1.t1_int AS t1_dscan_1.t1_t1_int
14)----------------DelimGet: t1.t1_int
physical_plan
01)ProjectionExec: expr=[t1_id@0 as t1_id, max(t2.t2_id) IS NULL@1 as x]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=LeftSingle, on=[(t1_int@1, t1_t1_int@1)], projection=[t1_id@0, max(t2.t2_id) IS NULL@2], NullsEqual: true
04)------DataSourceExec: partitions=1, partition_sizes=[2]
05)------ProjectionExec: expr=[max(t2.t2_id)@0 IS NULL as max(t2.t2_id) IS NULL, t1_t1_int@1 as t1_t1_int]
06)--------CoalesceBatchesExec: target_batch_size=2
07)----------HashJoinExec: mode=CollectLeft, join_type=Right, on=[(t1_t1_int@0, t1_t1_int@0)], projection=[max(t2.t2_id)@1, t1_t1_int@2], NullsEqual: true
08)------------CoalescePartitionsExec
09)--------------AggregateExec: mode=FinalPartitioned, gby=[t1_t1_int@0 as t1_t1_int], aggr=[max(t2.t2_id)]
10)----------------CoalesceBatchesExec: target_batch_size=2
11)------------------RepartitionExec: partitioning=Hash([t1_t1_int@0], 4), input_partitions=4
12)--------------------AggregateExec: mode=Partial, gby=[t1_t1_int@1 as t1_t1_int], aggr=[max(t2.t2_id)]
13)----------------------ProjectionExec: expr=[t2_id@1 as t2_id, t1_t1_int@0 as t1_t1_int]
14)------------------------CoalesceBatchesExec: target_batch_size=2
15)--------------------------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_t1_int@0, t2_int@1)], projection=[t1_t1_int@0, t2_id@1]
16)----------------------------ProjectionExec: expr=[t1_int@0 as t1_t1_int]
17)------------------------------AggregateExec: mode=Final, gby=[t1_int@0 as t1_int], aggr=[]
18)--------------------------------DataSourceExec: partitions=1, partition_sizes=[2]
19)----------------------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
20)------------------------------DataSourceExec: partitions=1, partition_sizes=[2]
21)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
22)--------------ProjectionExec: expr=[t1_int@0 as t1_t1_int]
23)----------------AggregateExec: mode=Final, gby=[t1_int@0 as t1_int], aggr=[]
24)------------------DataSourceExec: partitions=1, partition_sizes=[2]



query IB rowsort
SELECT t1_id, (SELECT max(t2.t2_id) is null FROM t2 WHERE t2.t2_int = t1.t1_int) x from t1
----
11 false
22 true
33 false
44 true 
