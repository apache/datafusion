
#correlated_scalar_subquery_count_agg
query TT
explain SELECT t1_id, (SELECT count(*) FROM t2 WHERE t2.t2_int = t1.t1_int) from t1
----
logical_plan
01)Projection: t1.t1_id, CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(0) ELSE __scalar_sq_1.count(*) END AS count(*)
02)--Left Join: t1.t1_int = __scalar_sq_1.t2_int
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----SubqueryAlias: __scalar_sq_1
05)------Projection: count(Int64(1)) AS count(*), t2.t2_int, Boolean(true) AS __always_true
06)--------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
07)----------TableScan: t2 projection=[t2_int]

query II rowsort
SELECT t1_id, (SELECT count(*) FROM t2 WHERE t2.t2_int = t1.t1_int) from t1
----
11 1
22 0
33 3
44 0


#correlated_scalar_subquery_count_agg2
query TT
explain SELECT t1_id, (SELECT count(*) FROM t2 WHERE t2.t2_int = t1.t1_int) as cnt from t1
----
logical_plan
01)Projection: t1.t1_id, CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(0) ELSE __scalar_sq_1.count(*) END AS cnt
02)--Left Join: t1.t1_int = __scalar_sq_1.t2_int
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----SubqueryAlias: __scalar_sq_1
05)------Projection: count(Int64(1)) AS count(*), t2.t2_int, Boolean(true) AS __always_true
06)--------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
07)----------TableScan: t2 projection=[t2_int]

#correlated_scalar_subquery_count_agg_complex_expr
query TT
explain SELECT t1_id, (SELECT count(*) + 2 as _cnt FROM t2 WHERE t2.t2_int = t1.t1_int) from t1
----
logical_plan
01)Projection: t1.t1_id, CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(2) ELSE __scalar_sq_1._cnt END AS _cnt
02)--Left Join: t1.t1_int = __scalar_sq_1.t2_int
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----SubqueryAlias: __scalar_sq_1
05)------Projection: count(Int64(1)) + Int64(2) AS _cnt, t2.t2_int, Boolean(true) AS __always_true
06)--------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
07)----------TableScan: t2 projection=[t2_int]


#correlated_scalar_subquery_count_agg_where_clause
query TT
explain select t1.t1_int from t1 where (select count(*) from t2 where t1.t1_id = t2.t2_id) < t1.t1_int
select t1.t1_int from t1,
(
    select count(*) as count_all from t2, (
        select distinct t1_id 
    ) as domain where t2.t2_id = domain.t1_id
) as pulled_up
where t1.t1_id=pulled_up.t1_id and pulled_up.count_all < t1.t1_int 
----
logical_plan
01)Projection: t1.t1_int
02)--Filter: CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(0) ELSE __scalar_sq_1.count(*) END < CAST(t1.t1_int AS Int64)
03)----Projection: t1.t1_int, __scalar_sq_1.count(*), __scalar_sq_1.__always_true
04)------Left Join: t1.t1_id = __scalar_sq_1.t2_id
05)--------TableScan: t1 projection=[t1_id, t1_int]
06)--------SubqueryAlias: __scalar_sq_1
07)----------Projection: count(Int64(1)) AS count(*), t2.t2_id, Boolean(true) AS __always_true
08)------------Aggregate: groupBy=[[t2.t2_id]], aggr=[[count(Int64(1))]]
09)--------------TableScan: t2 projection=[t2_id]

#correlated_scalar_subquery_count_agg_with_having
#the having condition is kept as the normal filter condition, no need to pull up
query TT
explain SELECT t1_id, (SELECT count(*) + 2 as cnt_plus_2 FROM t2 WHERE t2.t2_int = t1.t1_int having count(*) >1) from t1
----
logical_plan
01)Projection: t1.t1_id, __scalar_sq_1.cnt_plus_2 AS cnt_plus_2
02)--Left Join: t1.t1_int = __scalar_sq_1.t2_int
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----SubqueryAlias: __scalar_sq_1
05)------Projection: count(Int64(1)) AS count(*) + Int64(2) AS cnt_plus_2, t2.t2_int
06)--------Filter: count(Int64(1)) > Int64(1)
07)----------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
08)------------TableScan: t2 projection=[t2_int]


query TT
explain SELECT t1_id, (SELECT count(*) + 2 as cnt_plus_2 FROM t2 WHERE t2.t2_int = t1.t1_int having count(*) = 0) from t1
----
logical_plan
01)Projection: t1.t1_id, CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(2) WHEN __scalar_sq_1.count(Int64(1)) != Int64(0) THEN NULL ELSE __scalar_sq_1.cnt_plus_2 END AS cnt_plus_2
02)--Left Join: t1.t1_int = __scalar_sq_1.t2_int
03)----TableScan: t1 projection=[t1_id, t1_int]
04)----SubqueryAlias: __scalar_sq_1
05)------Projection: count(Int64(1)) + Int64(2) AS cnt_plus_2, t2.t2_int, count(Int64(1)), Boolean(true) AS __always_true
06)--------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
07)----------TableScan: t2 projection=[t2_int]

query TT
explain select t1.t1_int from t1 where (select cnt from (select count(*) as cnt, sum(t2_int) from t2 where t1.t1_int = t2.t2_int)) = 0
----
logical_plan
01)Projection: t1.t1_int
02)--Filter: CASE WHEN __scalar_sq_1.__always_true IS NULL THEN Int64(0) ELSE __scalar_sq_1.cnt END = Int64(0)
03)----Projection: t1.t1_int, __scalar_sq_1.cnt, __scalar_sq_1.__always_true
04)------Left Join: t1.t1_int = __scalar_sq_1.t2_int
05)--------TableScan: t1 projection=[t1_int]
06)--------SubqueryAlias: __scalar_sq_1
07)----------Projection: count(Int64(1)) AS cnt, t2.t2_int, Boolean(true) AS __always_true
08)------------Aggregate: groupBy=[[t2.t2_int]], aggr=[[count(Int64(1))]]
09)--------------TableScan: t2 projection=[t2_int]

