# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Portions of this file are derived from DuckDB and are licensed
# under the MIT License (see below).

# Copyright 2018-2025 Stichting DuckDB Foundation

# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

statement ok
CREATE TABLE t1 (x INT, y INT);

statement ok
INSERT INTO t1 VALUES (3, 3), (3, 3), (1, 1);

statement ok
CREATE TABLE t2 (y INT, z INT);

statement ok
INSERT INTO t2 VALUES (2, 2), (4, 4);


# Test binding
query I
SELECT t1.x FROM t1 UNION BY NAME SELECT x FROM t1 ORDER BY t1.x;
----
1
3

query I
SELECT t1.x FROM t1 UNION ALL BY NAME SELECT x FROM t1 ORDER BY t1.x;
----
1
1
3
3
3
3

query I
SELECT x FROM t1 UNION BY NAME SELECT x FROM t1 ORDER BY t1.x;
----
1
3

query I
SELECT x FROM t1 UNION ALL BY NAME SELECT x FROM t1 ORDER BY t1.x;
----
1
1
3
3
3
3

query II
(SELECT x FROM t1 UNION ALL SELECT x FROM t1) UNION BY NAME SELECT 5 ORDER BY x;
----
NULL 1
NULL 3
5 NULL

# TODO: This should pass, but the sanity checker isn't allowing it.
# Commenting out the ordering check in the sanity checker produces the correct result.
query error
(SELECT x FROM t1 UNION ALL SELECT x FROM t1) UNION ALL BY NAME SELECT 5 ORDER BY x;
----
DataFusion error: SanityCheckPlan
caused by
Error during planning: Plan: ["SortPreservingMergeExec: [x@1 ASC NULLS LAST]", "  UnionExec", "    SortExec: expr=[x@1 ASC NULLS LAST], preserve_partitioning=[true]", "      ProjectionExec: expr=[NULL as Int64(5), x@0 as x]", "        UnionExec", "          DataSourceExec: partitions=1, partition_sizes=[1]", "          DataSourceExec: partitions=1, partition_sizes=[1]", "    ProjectionExec: expr=[5 as Int64(5), NULL as x]", "      PlaceholderRowExec"] does not satisfy order requirements: [x@1 ASC NULLS LAST]. Child-0 order: []


query II
(SELECT x FROM t1 UNION ALL SELECT y FROM t1) UNION BY NAME SELECT 5 ORDER BY x;
----
NULL 1
NULL 3
5 NULL

# TODO: This should pass, but the sanity checker isn't allowing it.
# Commenting out the ordering check in the sanity checker produces the correct result.
query error
(SELECT x FROM t1 UNION ALL SELECT y FROM t1) UNION ALL BY NAME SELECT 5 ORDER BY x;
----
DataFusion error: SanityCheckPlan
caused by
Error during planning: Plan: ["SortPreservingMergeExec: [x@1 ASC NULLS LAST]", "  UnionExec", "    SortExec: expr=[x@1 ASC NULLS LAST], preserve_partitioning=[true]", "      ProjectionExec: expr=[NULL as Int64(5), x@0 as x]", "        UnionExec", "          DataSourceExec: partitions=1, partition_sizes=[1]", "          ProjectionExec: expr=[y@0 as x]", "            DataSourceExec: partitions=1, partition_sizes=[1]", "    ProjectionExec: expr=[5 as Int64(5), NULL as x]", "      PlaceholderRowExec"] does not satisfy order requirements: [x@1 ASC NULLS LAST]. Child-0 order: []



# Ambiguous name

statement error DataFusion error: Schema error: No field named t1.x. Valid fields are a, b.
SELECT x AS a FROM t1 UNION BY NAME SELECT x AS b FROM t1 ORDER BY t1.x;

query II
(SELECT y FROM t1 UNION ALL SELECT x FROM t1) UNION BY NAME (SELECT z FROM t2 UNION ALL SELECT y FROM t2) ORDER BY y, z;
----
1 NULL
3 NULL
NULL 2
NULL 4

query II
(SELECT y FROM t1 UNION ALL SELECT x FROM t1) UNION ALL BY NAME (SELECT z FROM t2 UNION ALL SELECT y FROM t2) ORDER BY y, z;
----
1 NULL
1 NULL
3 NULL
3 NULL
3 NULL
3 NULL
NULL 2
NULL 2
NULL 4
NULL 4

# Limit

query III
SELECT 1 UNION BY NAME SELECT * FROM unnest(range(2, 100)) UNION BY NAME SELECT 999 ORDER BY 3, 1 LIMIT 5;
----
NULL NULL 2
NULL NULL 3
NULL NULL 4
NULL NULL 5
NULL NULL 6

# TODO: This should pass, but the sanity checker isn't allowing it.
# Commenting out the ordering check in the sanity checker produces the correct result.
query error
SELECT 1 UNION ALL BY NAME SELECT * FROM unnest(range(2, 100)) UNION ALL BY NAME SELECT 999 ORDER BY 3, 1 LIMIT 5;
----
DataFusion error: SanityCheckPlan
caused by
Error during planning: Plan: ["SortPreservingMergeExec: [UNNEST(range(Int64(2),Int64(100)))@2 ASC NULLS LAST, Int64(1)@0 ASC NULLS LAST], fetch=5", "  UnionExec", "    SortExec: TopK(fetch=5), expr=[UNNEST(range(Int64(2),Int64(100)))@2 ASC NULLS LAST], preserve_partitioning=[true]", "      ProjectionExec: expr=[Int64(1)@0 as Int64(1), NULL as Int64(999), UNNEST(range(Int64(2),Int64(100)))@1 as UNNEST(range(Int64(2),Int64(100)))]", "        UnionExec", "          ProjectionExec: expr=[1 as Int64(1), NULL as UNNEST(range(Int64(2),Int64(100)))]", "            PlaceholderRowExec", "          ProjectionExec: expr=[NULL as Int64(1), __unnest_placeholder(range(Int64(2),Int64(100)),depth=1)@0 as UNNEST(range(Int64(2),Int64(100)))]", "            UnnestExec", "              ProjectionExec: expr=[[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] as __unnest_placeholder(range(Int64(2),Int64(100)))]", "                PlaceholderRowExec", "    ProjectionExec: expr=[NULL as Int64(1), 999 as Int64(999), NULL as UNNEST(range(Int64(2),Int64(100)))]", "      PlaceholderRowExec"] does not satisfy order requirements: [UNNEST(range(Int64(2),Int64(100)))@2 ASC NULLS LAST, Int64(1)@0 ASC NULLS LAST]. Child-0 order: []


# Order by

query III
SELECT x, y FROM t1 UNION BY NAME SELECT y, z FROM t2 ORDER BY y;
----
1 1 NULL
NULL 2 2
3 3 NULL
NULL 4 4

query III
SELECT x, y FROM t1 UNION ALL BY NAME SELECT y, z FROM t2 ORDER BY y;
----
1 1 NULL
NULL 2 2
3 3 NULL
3 3 NULL
NULL 4 4

query III
SELECT x, y FROM t1 UNION BY NAME SELECT y, z FROM t2 ORDER BY 3, 1;
----
NULL 2 2
NULL 4 4
1 1 NULL
3 3 NULL

query III
SELECT x, y FROM t1 UNION ALL BY NAME SELECT y, z FROM t2 ORDER BY 3, 1;
----
NULL 2 2
NULL 4 4
1 1 NULL
3 3 NULL
3 3 NULL

statement error
SELECT x, y FROM t1 UNION BY NAME SELECT y, z FROM t2 ORDER BY 4;
----
DataFusion error: Error during planning: Order by column out of bounds, specified: 4, max: 3


statement error
SELECT x, y FROM t1 UNION ALL BY NAME SELECT y, z FROM t2 ORDER BY 4;
----
DataFusion error: Error during planning: Order by column out of bounds, specified: 4, max: 3


# Multi set operations

query IIII rowsort
(SELECT 1 UNION BY NAME SELECT x, y FROM t1) UNION BY NAME SELECT y, z FROM t2;
----
1 NULL NULL NULL
NULL 1 1 NULL
NULL 3 3 NULL
NULL NULL 2 2
NULL NULL 4 4

query IIII rowsort
(SELECT 1 UNION ALL BY NAME SELECT x, y FROM t1) UNION ALL BY NAME SELECT y, z FROM t2;
----
1 NULL NULL NULL
NULL 1 1 NULL
NULL 3 3 NULL
NULL 3 3 NULL
NULL NULL 2 2
NULL NULL 4 4

query III
SELECT x, y FROM t1 UNION BY NAME (SELECT y, z FROM t2 INTERSECT SELECT 2, 2 as two FROM t1 ORDER BY 1) ORDER BY 1;
----
1 1 NULL
3 3 NULL
NULL 2 2

# TODO: Test regression on a new feature, with the same SanityCheckPlan failures as currently existing for this feature.
# output plan in SanityCheckPlan error has nondeterministic order in the HashJoinExec ON, so we can't compare the error directly
# query error
# SELECT x, y FROM t1 UNION ALL BY NAME (SELECT y, z FROM t2 INTERSECT SELECT 2, 2 as two FROM t1 ORDER BY 1) ORDER BY 1;
# ----
# DataFusion error: SanityCheckPlan
# caused by
# Error during planning: Plan: ["SortPreservingMergeExec: [x@0 ASC NULLS LAST]", "  UnionExec", "    SortExec: expr=[x@0 ASC NULLS LAST], preserve_partitioning=[false]", "      ProjectionExec: expr=[x@0 as x, y@1 as y, NULL as z]", "        DataSourceExec: partitions=1, partition_sizes=[1]", "    ProjectionExec: expr=[NULL as x, y@0 as y, z@1 as z]", "      CoalescePartitionsExec", "        CoalesceBatchesExec: target_batch_size=8192", "          HashJoinExec: mode=Partitioned, join_type=LeftSemi, on=[(CAST(t2.y AS Int64)@3, Int64(2)@0), (CAST(t2.z AS Int64)@2, two@1)], projection=[y@0, z@1]", "            CoalesceBatchesExec: target_batch_size=8192", "              RepartitionExec: partitioning=Hash([CAST(t2.y AS Int64)@3, CAST(t2.z AS Int64)@2], 4), input_partitions=4", "                ProjectionExec: expr=[y@0 as y, z@1 as z, CAST(z@1 AS Int64) as CAST(t2.z AS Int64), CAST(y@0 AS Int64) as CAST(t2.y AS Int64)]", "                  AggregateExec: mode=FinalPartitioned, gby=[y@0 as y, z@1 as z], aggr=[]", "                    CoalesceBatchesExec: target_batch_size=8192", "                      RepartitionExec: partitioning=Hash([y@0, z@1], 4), input_partitions=4", "                        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1", "                          AggregateExec: mode=Partial, gby=[y@0 as y, z@1 as z], aggr=[]", "                            DataSourceExec: partitions=1, partition_sizes=[1]", "            CoalesceBatchesExec: target_batch_size=8192", "              RepartitionExec: partitioning=Hash([Int64(2)@0, two@1], 4), input_partitions=1", "                ProjectionExec: expr=[2 as Int64(2), 2 as two]", "                  DataSourceExec: partitions=1, partition_sizes=[1]"] does not satisfy order requirements: [x@0 ASC NULLS LAST]. Child-0 order: []


query III
(SELECT x, y FROM t1 UNION BY NAME SELECT y, z FROM t2 ORDER BY 1) EXCEPT SELECT NULL, 2, 2 as two FROM t1 ORDER BY 1;
----
1 1 NULL
3 3 NULL
NULL 4 4

# Alias in select list

query II
SELECT x as a FROM t1 UNION BY NAME SELECT x FROM t1 ORDER BY 1, 2;
----
1 NULL
3 NULL
NULL 1
NULL 3

query II
SELECT x as a FROM t1 UNION ALL BY NAME SELECT x FROM t1 ORDER BY 1, 2;
----
1 NULL
3 NULL
3 NULL
NULL 1
NULL 3
NULL 3

# Different types

query T rowsort
SELECT '0' as c UNION ALL BY NAME SELECT 0 as c;
----
0
0
