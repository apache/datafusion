# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
## UPDATE tests for MemTable
##########

# Test basic UPDATE with WHERE clause
statement ok
CREATE TABLE test_update AS VALUES (1, 'a'), (2, 'b'), (3, 'c');

query I
UPDATE test_update SET column2 = 'updated' WHERE column1 = 2;
----
1

query IT rowsort
SELECT * FROM test_update;
----
1 a
2 updated
3 c

statement ok
DROP TABLE test_update;

# Test UPDATE all rows (no WHERE clause)
statement ok
CREATE TABLE test_update_all AS VALUES (1, 'x'), (2, 'y'), (3, 'z');

query I
UPDATE test_update_all SET column2 = 'changed';
----
3

query IT rowsort
SELECT * FROM test_update_all;
----
1 changed
2 changed
3 changed

statement ok
DROP TABLE test_update_all;

# Test UPDATE multiple columns
statement ok
CREATE TABLE test_update_multi(id INT, name VARCHAR, value INT);

statement ok
INSERT INTO test_update_multi VALUES (1, 'one', 10), (2, 'two', 20), (3, 'three', 30);

query I
UPDATE test_update_multi SET name = 'updated', value = 99 WHERE id = 2;
----
1

query ITI rowsort
SELECT * FROM test_update_multi;
----
1 one 10
2 updated 99
3 three 30

statement ok
DROP TABLE test_update_multi;

# Test UPDATE with compound predicate (AND)
statement ok
CREATE TABLE test_update_compound AS VALUES (1, 10), (2, 20), (3, 30), (4, 40);

query I
UPDATE test_update_compound SET column2 = 0 WHERE column1 > 1 AND column2 < 40;
----
2

query II rowsort
SELECT * FROM test_update_compound;
----
1 10
2 0
3 0
4 40

statement ok
DROP TABLE test_update_compound;

# Test UPDATE with OR predicate
statement ok
CREATE TABLE test_update_or AS VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd');

query I
UPDATE test_update_or SET column2 = 'modified' WHERE column1 = 1 OR column1 = 4;
----
2

query IT rowsort
SELECT * FROM test_update_or;
----
1 modified
2 b
3 c
4 modified

statement ok
DROP TABLE test_update_or;

# Test UPDATE with no matching rows
statement ok
CREATE TABLE test_update_nomatch AS VALUES (1, 'a'), (2, 'b');

query I
UPDATE test_update_nomatch SET column2 = 'new' WHERE column1 > 100;
----
0

query IT rowsort
SELECT * FROM test_update_nomatch;
----
1 a
2 b

statement ok
DROP TABLE test_update_nomatch;

# Test UPDATE with NULL predicate (SQL three-valued logic)
# Rows where predicate is NULL should NOT be updated
statement ok
CREATE TABLE test_update_null_pred(id INT, value INT, name VARCHAR);

statement ok
INSERT INTO test_update_null_pred VALUES (1, 10, 'a'), (2, NULL, 'b'), (3, 30, 'c');

# This predicate evaluates to NULL for row with id=2 (because NULL > 15 is NULL)
# Only row with id=3 should be updated (30 > 15 is true)
# Row with id=2 should keep its original name 'b' (NULL > 15 is NULL, not true)
query I
UPDATE test_update_null_pred SET name = 'updated' WHERE value > 15;
----
1

query IIT rowsort
SELECT * FROM test_update_null_pred;
----
1 10 a
2 NULL b
3 30 updated

statement ok
DROP TABLE test_update_null_pred;

# Test UPDATE with arithmetic expression (SET column = column * 2)
statement ok
CREATE TABLE test_update_expr AS VALUES (1, 10), (2, 20), (3, 30);

query I
UPDATE test_update_expr SET column2 = column2 * 2 WHERE column1 = 2;
----
1

query II rowsort
SELECT * FROM test_update_expr;
----
1 10
2 40
3 30

statement ok
DROP TABLE test_update_expr;

# Test UPDATE setting column to NULL
statement ok
CREATE TABLE test_update_null(id INT, name VARCHAR);

statement ok
INSERT INTO test_update_null VALUES (1, 'one'), (2, 'two'), (3, 'three');

query I
UPDATE test_update_null SET name = NULL WHERE id = 2;
----
1

query IT rowsort
SELECT * FROM test_update_null;
----
1 one
2 NULL
3 three

statement ok
DROP TABLE test_update_null;

# Test UPDATE with CASE expression in SET
statement ok
CREATE TABLE test_update_case AS VALUES (1, 'low'), (50, 'medium'), (100, 'high');

query I
UPDATE test_update_case SET column2 = CASE
    WHEN column1 < 25 THEN 'small'
    WHEN column1 < 75 THEN 'medium'
    ELSE 'large'
END;
----
3

query IT rowsort
SELECT * FROM test_update_case;
----
1 small
100 large
50 medium

statement ok
DROP TABLE test_update_case;

# Test UPDATE with column reference (SET a = b)
statement ok
CREATE TABLE test_update_col_ref AS VALUES (1, 10, 100), (2, 20, 200);

query I
UPDATE test_update_col_ref SET column1 = column2 WHERE column3 = 100;
----
1

query III rowsort
SELECT * FROM test_update_col_ref;
----
10 10 100
2 20 200

statement ok
DROP TABLE test_update_col_ref;

# Test UPDATE with invalid column name (error case)
statement ok
CREATE TABLE test_update_error(id INT, name VARCHAR);

statement ok
INSERT INTO test_update_error VALUES (1, 'test');

statement error No field named nonexistent
UPDATE test_update_error SET nonexistent = 'value';

statement ok
DROP TABLE test_update_error;

# Test UPDATE with expression that would error on non-matching rows
# Regression test: expressions should only be evaluated on rows that match
# the WHERE clause, not all rows. This prevents divide-by-zero errors
# on rows that won't be updated.
statement ok
CREATE TABLE test_update_div(id INT, divisor INT, result INT);

statement ok
INSERT INTO test_update_div VALUES (1, 0, 0), (2, 2, 0), (3, 5, 0);

# This should succeed: 1/divisor is only evaluated where divisor != 0
# Row 1 (divisor=0) is excluded by WHERE clause and expression is NOT evaluated
query I
UPDATE test_update_div SET result = 100 / divisor WHERE divisor != 0;
----
2

query III rowsort
SELECT * FROM test_update_div;
----
1 0 0
2 2 50
3 5 20

statement ok
DROP TABLE test_update_div;
