# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
## UPDATE tests
##########

# Test basic UPDATE with WHERE clause
statement ok
CREATE TABLE test_update AS VALUES (1, 'a'), (2, 'b'), (3, 'c');

query I
UPDATE test_update SET column2 = 'updated' WHERE column1 = 2;
----
1

query IT rowsort
SELECT * FROM test_update;
----
1 a
2 updated
3 c

statement ok
DROP TABLE test_update;

# Test UPDATE all rows (no WHERE clause)
statement ok
CREATE TABLE test_update_all AS VALUES (1, 'x'), (2, 'y'), (3, 'z');

query I
UPDATE test_update_all SET column2 = 'changed';
----
3

query IT rowsort
SELECT * FROM test_update_all;
----
1 changed
2 changed
3 changed

statement ok
DROP TABLE test_update_all;

# Test UPDATE multiple columns
statement ok
CREATE TABLE test_update_multi(id INT, name VARCHAR, value INT);

statement ok
INSERT INTO test_update_multi VALUES (1, 'one', 10), (2, 'two', 20), (3, 'three', 30);

query I
UPDATE test_update_multi SET name = 'updated', value = 99 WHERE id = 2;
----
1

query ITI rowsort
SELECT * FROM test_update_multi;
----
1 one 10
2 updated 99
3 three 30

statement ok
DROP TABLE test_update_multi;

# Test UPDATE with compound predicate (AND)
statement ok
CREATE TABLE test_update_compound AS VALUES (1, 10), (2, 20), (3, 30), (4, 40);

query I
UPDATE test_update_compound SET column2 = 0 WHERE column1 > 1 AND column2 < 40;
----
2

query II rowsort
SELECT * FROM test_update_compound;
----
1 10
2 0
3 0
4 40

statement ok
DROP TABLE test_update_compound;

# Test UPDATE with OR predicate
statement ok
CREATE TABLE test_update_or AS VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd');

query I
UPDATE test_update_or SET column2 = 'modified' WHERE column1 = 1 OR column1 = 4;
----
2

query IT rowsort
SELECT * FROM test_update_or;
----
1 modified
2 b
3 c
4 modified

statement ok
DROP TABLE test_update_or;

# Test UPDATE with no matching rows
statement ok
CREATE TABLE test_update_nomatch AS VALUES (1, 'a'), (2, 'b');

query I
UPDATE test_update_nomatch SET column2 = 'new' WHERE column1 > 100;
----
0

query IT rowsort
SELECT * FROM test_update_nomatch;
----
1 a
2 b

statement ok
DROP TABLE test_update_nomatch;

# Test UPDATE with NULL predicate (SQL semantics: NULL predicate should NOT update row)
# When comparing with NULL, the predicate evaluates to NULL, not true/false
statement ok
CREATE TABLE test_update_null_pred(id INT, value INT, name VARCHAR);

statement ok
INSERT INTO test_update_null_pred VALUES (1, 10, 'a'), (2, NULL, 'b'), (3, 30, 'c');

# This predicate evaluates to NULL for row with id=2 (because NULL > 15 is NULL)
# Only row with id=3 should be updated (30 > 15 is true)
# Row with id=2 should keep its original name 'b' (NULL > 15 is NULL, not true)
query I
UPDATE test_update_null_pred SET name = 'updated' WHERE value > 15;
----
1

query IIT rowsort
SELECT * FROM test_update_null_pred;
----
1 10 a
2 NULL b
3 30 updated

statement ok
DROP TABLE test_update_null_pred;

# Test UPDATE with arithmetic expression
statement ok
CREATE TABLE test_update_expr AS VALUES (1, 10), (2, 20), (3, 30);

query I
UPDATE test_update_expr SET column2 = column2 * 2 WHERE column1 = 2;
----
1

query II rowsort
SELECT * FROM test_update_expr;
----
1 10
2 40
3 30

statement ok
DROP TABLE test_update_expr;

# Test UPDATE setting column to NULL
statement ok
CREATE TABLE test_update_null(id INT, name VARCHAR);

statement ok
INSERT INTO test_update_null VALUES (1, 'one'), (2, 'two'), (3, 'three');

query I
UPDATE test_update_null SET name = NULL WHERE id = 2;
----
1

query IT rowsort
SELECT * FROM test_update_null;
----
1 one
2 NULL
3 three

statement ok
DROP TABLE test_update_null;

# Test multiple UPDATEs on same table
statement ok
CREATE TABLE test_multi_update AS VALUES (1, 0), (2, 0), (3, 0), (4, 0), (5, 0);

query I
UPDATE test_multi_update SET column2 = 10 WHERE column1 = 1;
----
1

query I
UPDATE test_multi_update SET column2 = 30 WHERE column1 = 3;
----
1

query I
UPDATE test_multi_update SET column2 = 50 WHERE column1 = 5;
----
1

query II rowsort
SELECT * FROM test_multi_update;
----
1 10
2 0
3 30
4 0
5 50

statement ok
DROP TABLE test_multi_update;

# Test UPDATE with string concatenation expression
statement ok
CREATE TABLE test_update_concat AS VALUES (1, 'hello'), (2, 'world');

query I
UPDATE test_update_concat SET column2 = column2 || '!' WHERE column1 = 1;
----
1

query IT rowsort
SELECT * FROM test_update_concat;
----
1 hello!
2 world

statement ok
DROP TABLE test_update_concat;

# Test UPDATE with UPPER function in SET
statement ok
CREATE TABLE test_update_upper AS VALUES (1, 'hello'), (2, 'world');

query I
UPDATE test_update_upper SET column2 = UPPER(column2) WHERE column1 = 1;
----
1

query IT rowsort
SELECT * FROM test_update_upper;
----
1 HELLO
2 world

statement ok
DROP TABLE test_update_upper;

# Test UPDATE with SUBSTRING function in SET
statement ok
CREATE TABLE test_update_substr AS VALUES (1, 'hello world'), (2, 'goodbye');

query I
UPDATE test_update_substr SET column2 = SUBSTRING(column2, 1, 5) WHERE column1 = 1;
----
1

query IT rowsort
SELECT * FROM test_update_substr;
----
1 hello
2 goodbye

statement ok
DROP TABLE test_update_substr;

# Test UPDATE with LIKE predicate in WHERE
statement ok
CREATE TABLE test_update_like AS VALUES ('apple', 0), ('apricot', 0), ('banana', 0);

query I
UPDATE test_update_like SET column2 = 1 WHERE column1 LIKE 'ap%';
----
2

query TI rowsort
SELECT * FROM test_update_like;
----
apple 1
apricot 1
banana 0

statement ok
DROP TABLE test_update_like;

# Test UPDATE with BETWEEN predicate in WHERE
statement ok
CREATE TABLE test_update_between AS VALUES (1, 'a'), (5, 'b'), (10, 'c'), (15, 'd');

query I
UPDATE test_update_between SET column2 = 'updated' WHERE column1 BETWEEN 5 AND 10;
----
2

query IT rowsort
SELECT * FROM test_update_between;
----
1 a
10 updated
15 d
5 updated

statement ok
DROP TABLE test_update_between;

# Test UPDATE with IN predicate in WHERE
statement ok
CREATE TABLE test_update_in AS VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd');

query I
UPDATE test_update_in SET column2 = 'selected' WHERE column1 IN (1, 3);
----
2

query IT rowsort
SELECT * FROM test_update_in;
----
1 selected
2 b
3 selected
4 d

statement ok
DROP TABLE test_update_in;

# Test UPDATE with CASE expression in SET
statement ok
CREATE TABLE test_update_case AS VALUES (1, 'low'), (50, 'medium'), (100, 'high');

query I
UPDATE test_update_case SET column2 = CASE
    WHEN column1 < 25 THEN 'small'
    WHEN column1 < 75 THEN 'medium'
    ELSE 'large'
END;
----
3

query IT rowsort
SELECT * FROM test_update_case;
----
1 small
100 large
50 medium

statement ok
DROP TABLE test_update_case;

# Test UPDATE with float values
statement ok
CREATE TABLE test_update_float AS VALUES (1.5, 'a'), (2.7, 'b'), (3.14, 'c');

query I
UPDATE test_update_float SET column2 = 'big' WHERE column1 > 2.0;
----
2

query RT rowsort
SELECT * FROM test_update_float;
----
1.5 a
2.7 big
3.14 big

statement ok
DROP TABLE test_update_float;

# Test UPDATE with boolean values
statement ok
CREATE TABLE test_update_bool(id INT, active BOOLEAN);

statement ok
INSERT INTO test_update_bool VALUES (1, true), (2, false), (3, true);

query I
UPDATE test_update_bool SET active = false WHERE active = true;
----
2

query IB rowsort
SELECT * FROM test_update_bool;
----
1 false
2 false
3 false

statement ok
DROP TABLE test_update_bool;

# Test UPDATE with column reference (SET a = b)
statement ok
CREATE TABLE test_update_col_ref AS VALUES (1, 10, 100), (2, 20, 200);

query I
UPDATE test_update_col_ref SET column1 = column2 WHERE column3 = 100;
----
1

query III rowsort
SELECT * FROM test_update_col_ref;
----
10 10 100
2 20 200

statement ok
DROP TABLE test_update_col_ref;

# Test UPDATE with invalid column name (error case)
statement ok
CREATE TABLE test_update_error(id INT, name VARCHAR);

statement ok
INSERT INTO test_update_error VALUES (1, 'test');

statement error No field named nonexistent
UPDATE test_update_error SET nonexistent = 'value';

statement ok
DROP TABLE test_update_error;
