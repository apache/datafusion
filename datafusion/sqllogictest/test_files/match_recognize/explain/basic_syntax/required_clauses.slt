# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Import common test data
include ../../init_data.slt.part

# Test minimal MATCH_RECOGNIZE with required clauses only
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test missing PATTERN clause (should fail)
query error DataFusion error: SQL error: ParserError\("Expected: PATTERN, found: DEFINE at Line: 3, Column: 5"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    DEFINE A AS price > 100
)

# Test missing DEFINE clause when pattern uses symbols (should fail)
query error DataFusion error: SQL error: ParserError\("Expected: DEFINE, found: \) at Line: 4, Column: 1"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PATTERN (A B)
)

# Test undefined symbol in pattern (B is implicitly TRUE)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A B)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A B] symbols=[A,B] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B: Boolean(true)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A B] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a, true as __mr_symbol_b], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N, __mr_symbol_b:Boolean]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test unused symbol in DEFINE (B defined but not used in pattern)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A)
    DEFINE
        A AS price > 100,
        B AS price < 50
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A,B] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B: stock_price.price < Int32(50) AS stock_price.price < Int64(50)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a, price@2 < 50 as __mr_symbol_b], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N, __mr_symbol_b:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test multiple symbols in pattern
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A B C)
    DEFINE
        A AS price > 100,
        B AS price < 50,
        C AS price > 75
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A B C] symbols=[A,B,C] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B: stock_price.price < Int32(50) AS stock_price.price < Int64(50), C: stock_price.price > Int32(75) AS stock_price.price > Int64(75)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A B C] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a, price@2 < 50 as __mr_symbol_b, price@2 > 75 as __mr_symbol_c], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N, __mr_symbol_b:Boolean;N, __mr_symbol_c:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test complex DEFINE expressions
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100 AND company = 'ACME'
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AND stock_price.company = Utf8View("ACME") AS stock_price.price > Int64(100) AND stock_price.company = Utf8("ACME")] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 AND company@0 = ACME as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
