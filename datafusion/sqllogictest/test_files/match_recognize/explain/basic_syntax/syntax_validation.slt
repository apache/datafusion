# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Import common test data
include ../../init_data.slt.part

# Test invalid SQL syntax - missing opening parenthesis
query error DataFusion error: SQL error: ParserError\("Expected: \(, found: PATTERN at Line: 3, Column: 5"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE
    PATTERN (A)
    DEFINE A AS price > 100
)

# Test invalid SQL syntax - missing closing parenthesis
query error DataFusion error: SQL error: ParserError\("Expected: \), found: EOF"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PATTERN (A)
    DEFINE A AS price > 100

# Test invalid PATTERN syntax
query error DataFusion error: SQL error: ParserError\("Expected: \(, found: A at Line: 3, Column: 13"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PATTERN A)
    DEFINE A AS price > 100
)

# Test invalid DEFINE syntax
query error DataFusion error: SQL error: ParserError\("Expected: AS, found: price at Line: 4, Column: 14"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PATTERN (A)
    DEFINE A price > 100
)

# Test valid identifier names
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES
        price AS current_price_value,
        company AS stock_symbol
    PATTERN (A1 B2 C_3)
    DEFINE
        A1 AS price > 100,
        B2 AS company = 'ACME',
        C_3 AS price_date IS NOT NULL
)
----
logical_plan
01)Projection: stock_price.company, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price_value, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS stock_symbol
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A1 B2 C_3] symbols=[A1,B2,C_3] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A1: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B2: stock_price.company = Utf8View("ACME") AS stock_price.company = Utf8("ACME"), C_3: stock_price.price_date IS NOT NULL] output={passthrough_columns=[stock_price.company,stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@2 as current_price_value, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@3 as stock_symbol], schema=[company:Utf8View;N, current_price_value:Int32;N, stock_symbol:Utf8View;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Utf8View;N]
03)----SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8View;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8View;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8View;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@2 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.company) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8View;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A1 B2 C_3] output={passthrough_columns=[company,price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a1:Boolean;N, __mr_symbol_b2:Boolean;N, __mr_symbol_c_3:Boolean]
10)------------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a1, company@0 = ACME as __mr_symbol_b2, price_date@1 IS NOT NULL as __mr_symbol_c_3], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a1:Boolean;N, __mr_symbol_b2:Boolean;N, __mr_symbol_c_3:Boolean]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test case sensitivity
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    ONE ROW PER MATCH
    PATTERN (UpTrend DownTrend)
    DEFINE
        UpTrend AS price > 100,
        DownTrend AS price < 50
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[PAST LAST ROW] pattern=[UpTrend DownTrend] symbols=[DownTrend,UpTrend] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[DownTrend: stock_price.price < Int32(50) AS stock_price.price < Int64(50), UpTrend: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[UpTrend DownTrend] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 < 50 as __mr_symbol_downtrend, price@0 > 100 as __mr_symbol_uptrend], schema=[price:Int32;N, __mr_symbol_downtrend:Boolean;N, __mr_symbol_uptrend:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test quoted identifiers preserve case
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    ONE ROW PER MATCH
    PATTERN ("UpTrend" "DownTrend")
    DEFINE
        "UpTrend" AS price > 100,
        "DownTrend" AS price < 50
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[PAST LAST ROW] pattern=[UpTrend DownTrend] symbols=[DownTrend,UpTrend] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[DownTrend: stock_price.price < Int32(50) AS stock_price.price < Int64(50), UpTrend: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[UpTrend DownTrend] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 < 50 as __mr_symbol_downtrend, price@0 > 100 as __mr_symbol_uptrend], schema=[price:Int32;N, __mr_symbol_downtrend:Boolean;N, __mr_symbol_uptrend:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test MATCH_RECOGNIZE plan creation
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test MATCH_RECOGNIZE function structure
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES COUNT(*) AS cnt
    ONE ROW PER MATCH
    AFTER MATCH SKIP TO NEXT ROW
    PATTERN (A+)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: stock_price.company, count(Int64(1)) AS cnt
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[count(Int64(1))]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[TO NEXT ROW] pattern=[A+] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company], metadata=[__mr_match_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, count(Int64(1))@2 as cnt], schema=[company:Utf8View;N, cnt:Int64]
02)--AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1)):Int64]
03)----SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
06)----------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A+] output={passthrough_columns=[company], metadata=[__mr_match_number]}, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
09)----------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test plan display
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test plan equality (identical queries should produce same plan)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES COUNT(*) AS cnt
    PATTERN (A+)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: stock_price.company, count(Int64(1)) AS cnt
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[count(Int64(1))]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A+] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company], metadata=[__mr_match_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, count(Int64(1))@2 as cnt], schema=[company:Utf8View;N, cnt:Int64]
02)--AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1)):Int64]
03)----SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
06)----------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A+] output={passthrough_columns=[company], metadata=[__mr_match_number]}, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
09)----------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test complex expression parsing
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES
        CASE WHEN price > 100 THEN 'HIGH' ELSE 'LOW' END AS price_category,
        price + 10 * 2 AS adjusted_price,
        COALESCE(price, 0) AS safe_price
    PATTERN (A)
    DEFINE A AS price > 50 AND (company = 'ACME' OR company = 'BETA')
)
----
logical_plan
01)Projection: last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS price_category, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS adjusted_price, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS safe_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(CASE WHEN stock_price.price > Int32(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(__common_expr_1 + Int64(20)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(CASE WHEN __common_expr_1 IS NOT NULL THEN __common_expr_1 ELSE Int64(0) END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----Projection: CAST(stock_price.price AS Int64) AS __common_expr_1, stock_price.price, __mr_match_number, __mr_match_sequence_number
04)------MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(50) AND (stock_price.company = Utf8View("ACME") OR stock_price.company = Utf8View("BETA")) AS stock_price.price > Int64(50) AND stock_price.company = Utf8("ACME") OR stock_price.company = Utf8("BETA")] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
05)--------TableScan: stock_price projection=[company, price]
physical_plan
01)ProjectionExec: expr=[last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as price_category, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@2 as adjusted_price, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@3 as safe_price], schema=[price_category:Utf8;N, adjusted_price:Int64;N, safe_price:Int64;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Utf8;N, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int64;N, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int64;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@2 as __mr_match_number], aggr=[last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST], last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(CASE WHEN stock_price.price > Int64(100) THEN Utf8("HIGH") ELSE Utf8("LOW") END) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Utf8;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(stock_price.price + Int64(10) * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N, last_value(coalesce(stock_price.price,Int64(0))) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
07)------------ProjectionExec: expr=[CAST(price@0 AS Int64) as __common_expr_1, price@0 as price, __mr_match_number@1 as __mr_match_number, __mr_match_sequence_number@2 as __mr_match_sequence_number], schema=[__common_expr_1:Int64;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
10)------------------ProjectionExec: expr=[company@0 as company, price@1 as price, price@1 > 50 AND (company@0 = ACME OR company@0 = BETA) as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]

# Test valid column references
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES price AS p
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: stock_price.company, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS p
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@2 as p], schema=[company:Utf8View;N, p:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@2 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test invalid column references - non-existent column in PARTITION BY
query error DataFusion error: Schema error: No field named non_existent_col\. Valid fields are stock_price\.company, stock_price\.price_date, stock_price\.price\.
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY non_existent_col
    MEASURES price AS p
    PATTERN (A)
    DEFINE A AS price > 100
)

# Test invalid column references - non-existent column in MEASURES
query error DataFusion error: Schema error: No field named non_existent_col\. Valid fields are stock_price\.company, stock_price\.price_date, stock_price\.price, __mr_classifier, __mr_match_number, __mr_match_sequence_number, __mr_classifier_a\.
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES non_existent_col AS val
    PATTERN (A)
    DEFINE A AS price > 100
)

# Test invalid column references - non-existent column in DEFINE
query error DataFusion error: Schema error: No field named non_existent_col\. Valid fields are stock_price\.company, stock_price\.price_date, stock_price\.price\.
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS p
    PATTERN (A)
    DEFINE A AS non_existent_col > 100
)

# Test nested expressions
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    MEASURES
        ABS(price - LAG(price, 1, 0)) AS price_change
    PATTERN (A+)
    DEFINE
        A AS ABS(price - LAG(price, 1, 0)) > 10
)
----
logical_plan
01)Projection: stock_price.company, last_value(abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS price_change
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[last_value(abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----WindowAggr: windowExpr=[[lag(stock_price.price, Int64(1), Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
04)------MatchRecognize: partition_by=[stock_price.company] after_skip=[PAST LAST ROW] pattern=[A+] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) > Int32(10) AS abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) > Int64(10)] output={passthrough_columns=[stock_price.company,stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
05)--------WindowAggr: windowExpr=[[lag(stock_price.price, Int64(1), Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
06)----------TableScan: stock_price projection=[company, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, last_value(abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@2 as price_change], schema=[company:Utf8View;N, price_change:Int32;N]
02)--AggregateExec: mode=SinglePartitioned, gby=[company@0 as company, __mr_match_number@2 as __mr_match_number], aggr=[last_value(abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(abs(stock_price.price - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----BoundedWindowAggExec: wdw=[lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { name: "lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted], schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N, lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING:Int32;N]
04)------SortExec: expr=[company@0 ASC NULLS LAST, __mr_match_number@2 ASC NULLS LAST, __mr_match_sequence_number@3 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
05)--------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
06)----------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@2], 4), input_partitions=4, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A+] output={passthrough_columns=[company,price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[company@0 as company, price@1 as price, lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@2 as lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING, abs(price@1 - lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@2) > 10 as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------BoundedWindowAggExec: wdw=[lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { name: "lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted], schema=[company:Utf8View;N, price:Int32;N, lag(stock_price.price,Int64(1),Int64(0)) PARTITION BY [stock_price.company] ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING:Int32;N]
11)--------------------SortExec: expr=[company@0 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price:Int32;N]
12)----------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]

# Test table reference validation
query error DataFusion error: Schema error: No field named __mr_classifier_stock_price\. Valid fields are stock_price\.company, stock_price\.price_date, stock_price\.price\.
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY stock_price.company
    ORDER BY stock_price.price_date
    MEASURES stock_price.price as p
    PATTERN (A)
    DEFINE A AS stock_price.price > 100
)

# Test table reference validation except in MEASURES
query error DataFusion error: Schema error: No field named __mr_classifier_stock_price\. Valid fields are stock_price\.company, stock_price\.price_date, stock_price\.price\.
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY stock_price.company
    ORDER BY stock_price.price_date
    MEASURES price as p
    PATTERN (A)
    DEFINE A AS stock_price.price > 100
)

# Test empty pattern error
query error DataFusion error: SQL error: ParserError\("Expected: identifier, found: \) at Line: 4, Column: 14"\)
SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price as p
    PATTERN ()
    DEFINE A AS price > 100
)
