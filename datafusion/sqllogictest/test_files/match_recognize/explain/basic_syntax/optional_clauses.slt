# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Import common test data
include ../../init_data.slt.part

# Test all optional clauses present
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES
        FIRST_VALUE(price) AS first_price,
        LAST_VALUE(price) AS last_price,
        COUNT(*) AS match_count
    ALL ROWS PER MATCH SHOW EMPTY MATCHES
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (A+)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: stock_price.company, stock_price.price_date, stock_price.price, first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW AS first_price, last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW AS last_price, count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW AS match_count
02)--WindowAggr: windowExpr=[[first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW, last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW, count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A+] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW@5 as first_price, last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW@6 as last_price, count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW@7 as match_count], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, first_price:Int32;N, last_price:Int32;N, match_count:Int64]
02)--BoundedWindowAggExec: wdw=[first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: Field { name: "first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW, last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: Field { name: "last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW, count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: Field { name: "count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW", data_type: Int64, nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW], mode=[Sorted], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N, first_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:Int32;N, last_value(stock_price.price) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:Int32;N, count(Int64(1)) PARTITION BY [stock_price.company, __mr_match_number] ORDER BY [__mr_match_sequence_number ASC NULLS LAST] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:Int64]
03)----SortExec: expr=[company@0 ASC NULLS LAST, __mr_match_number@3 ASC NULLS LAST, __mr_match_sequence_number@4 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@3], 4), input_partitions=4, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
06)----------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
07)------------MatchRecognizePatternExec: pattern=[A+] output={passthrough_columns=[company,price_date,price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
09)----------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test all optional clauses absent with ONE ROW PER MATCH (should fail)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)]
02)--TableScan: stock_price projection=[price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A], schema=[]
02)--ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]


# Test all optional clauses absent (should fail: ONE ROW PER MATCH is default)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)]
02)--TableScan: stock_price projection=[price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A], schema=[]
02)--ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]


# Test all optional clauses absent with ALL ROWS PER MATCH
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test PARTITION BY only
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: partition_by=[stock_price.company] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company]}
02)--TableScan: stock_price projection=[company, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company]}, schema=[company:Utf8View;N]
02)--SortExec: expr=[company@0 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----ProjectionExec: expr=[company@0 as company, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]


# Test ONE ROW PER MATCH with PARTITION BY and pushed down FILTER on partition key
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
WHERE company = 'DDOG'
----
logical_plan
01)MatchRecognize: partition_by=[stock_price.company] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company]}
02)--Filter: stock_price.company = Utf8View("DDOG")
03)----TableScan: stock_price projection=[company, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company]}, schema=[company:Utf8View;N]
02)--CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----RepartitionExec: partitioning=Hash([company@0], 4), input_partitions=4, schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------ProjectionExec: expr=[company@0 as company, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price:Int32;N]
06)----------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, price:Int32;N]
07)------------FilterExec: company@0 = DDOG, schema=[company:Utf8View;N, price:Int32;N]
08)--------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]


# Test ONE ROW PER MATCH with PARTITION BY and pushed down FILTER not on partition key
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    MEASURES A.price AS price
    ONE ROW PER MATCH
    PATTERN (A+)
    DEFINE A AS price > 100
)
WHERE price > '150'
----
logical_plan
01)Projection: stock_price.company, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS price
02)--Filter: CAST(last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS Utf8) > Utf8("150")
03)----Projection: stock_price.company, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]
04)------Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
05)--------MatchRecognize: partition_by=[stock_price.company] after_skip=[PAST LAST ROW] pattern=[A+] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number], classifier_flags=[A]}
06)----------TableScan: stock_price projection=[company, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as price], schema=[company:Utf8View;N, price:Int32;N]
02)--CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----FilterExec: CAST(last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 AS Utf8) > 150, schema=[company:Utf8View;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
04)------ProjectionExec: expr=[company@0 as company, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@2 as last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], schema=[company:Utf8View;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
05)--------AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
06)----------SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
07)------------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
08)--------------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
09)----------------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@2 as __mr_match_number], aggr=[last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, last_value(stock_price.price) FILTER (WHERE __mr_classifier_a) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
10)------------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N, __mr_classifier_a:Boolean]
11)--------------------MatchRecognizePatternExec: pattern=[A+] output={passthrough_columns=[company,price], metadata=[__mr_match_number,__mr_match_sequence_number], classifier_flags=[A]}, schema=[company:Utf8View;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N, __mr_classifier_a:Boolean]
12)----------------------SortExec: expr=[company@0 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
13)------------------------ProjectionExec: expr=[company@0 as company, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
14)--------------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]


# Test ORDER BY only without PARTITION BY or MEASURES (should fail)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ORDER BY price_date DESC
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: order_by=[stock_price.price_date DESC NULLS FIRST] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)]
02)--TableScan: stock_price projection=[price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A], schema=[]
02)--SortExec: expr=[price_date@0 DESC], preserve_partitioning=[false], schema=[price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----ProjectionExec: expr=[price_date@0 as price_date, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price_date:Date32;N, price:Int32;N]


# Test ORDER BY only with ALL ROWS PER MATCH
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ORDER BY price_date DESC
    ALL ROWS PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: order_by=[stock_price.price_date DESC NULLS FIRST] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--SortExec: expr=[price_date@1 DESC], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test MEASURES only
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test ONE ROW PER MATCH without PARTITION BY or MEASURES (should fail)
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)]
02)--TableScan: stock_price projection=[price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A], schema=[]
02)--ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]


# Test ONE ROW PER MATCH with PARTITION BY
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: partition_by=[stock_price.company] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company]}
02)--TableScan: stock_price projection=[company, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company]}, schema=[company:Utf8View;N]
02)--SortExec: expr=[company@0 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----ProjectionExec: expr=[company@0 as company, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price:Int32;N]

# Test ALL ROWS PER MATCH OMIT EMPTY MATCHES
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH OMIT EMPTY MATCHES
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH OMIT EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test ALL ROWS PER MATCH WITH UNMATCHED ROWS
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ALL ROWS PER MATCH WITH UNMATCHED ROWS
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH WITH UNMATCHED ROWS] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date,stock_price.price]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date,price]}, schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
02)--ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test AFTER MATCH SKIP TO NEXT ROW
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    AFTER MATCH SKIP TO NEXT ROW
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[TO NEXT ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test AFTER MATCH SKIP TO FIRST symbol
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    AFTER MATCH SKIP TO FIRST A
    PATTERN (A B)
    DEFINE
        A AS price > 100,
        B AS price < 50
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[TO FIRST A] pattern=[A B] symbols=[A,B] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B: stock_price.price < Int32(50) AS stock_price.price < Int64(50)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A B] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a, price@0 < 50 as __mr_symbol_b], schema=[price:Int32;N, __mr_symbol_a:Boolean;N, __mr_symbol_b:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test AFTER MATCH SKIP TO LAST symbol
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES price AS current_price
    AFTER MATCH SKIP TO LAST B
    PATTERN (A B)
    DEFINE
        A AS price > 100,
        B AS price < 50
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: after_skip=[TO LAST B] pattern=[A B] symbols=[A,B] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100), B: stock_price.price < Int32(50) AS stock_price.price < Int64(50)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A B] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a, price@0 < 50 as __mr_symbol_b], schema=[price:Int32;N, __mr_symbol_a:Boolean;N, __mr_symbol_b:Boolean;N]
10)------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test multiple PARTITION BY columns
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company, price_date
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)MatchRecognize: partition_by=[stock_price.company, stock_price.price_date] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company,stock_price.price_date]}
02)--TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company,price_date]}, schema=[company:Utf8View;N, price_date:Date32;N]
02)--SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
03)----ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
04)------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]

# Test multiple ORDER BY columns
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    ORDER BY price_date ASC, price DESC NULLS LAST
    MEASURES price AS current_price
    ONE ROW PER MATCH
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS current_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----MatchRecognize: order_by=[stock_price.price_date ASC NULLS LAST, stock_price.price DESC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
04)------TableScan: stock_price projection=[price_date, price]
physical_plan
01)ProjectionExec: expr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@1 as current_price], schema=[current_price:Int32;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int32;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@1 as __mr_match_number], aggr=[last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, last_value(stock_price.price) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int32;N, __mr_match_sequence_number@2:UInt64;N, is_set:Boolean;N]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------SortExec: expr=[price_date@0 ASC NULLS LAST, price@1 DESC NULLS LAST], preserve_partitioning=[false], schema=[price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------ProjectionExec: expr=[price_date@0 as price_date, price@1 as price, price@1 > 100 as __mr_symbol_a], schema=[price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price_date:Date32;N, price:Int32;N]

# Test complex MEASURES expressions
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    MEASURES
        COUNT(*) AS match_count,
        SUM(price) AS total_price,
        AVG(price) AS avg_price,
        price * 2 AS double_price
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: count(Int64(1)) AS match_count, sum(stock_price.price) AS total_price, avg(stock_price.price) AS avg_price, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST] AS double_price
02)--Aggregate: groupBy=[[__mr_match_number]], aggr=[[count(Int64(1)), sum(__common_expr_1 AS stock_price.price), avg(CAST(stock_price.price AS Float64)), last_value(__common_expr_1 AS stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]]]
03)----Projection: CAST(stock_price.price AS Int64) AS __common_expr_1, stock_price.price, __mr_match_number, __mr_match_sequence_number
04)------MatchRecognize: after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.price], metadata=[__mr_match_number,__mr_match_sequence_number]}
05)--------TableScan: stock_price projection=[price]
physical_plan
01)ProjectionExec: expr=[count(Int64(1))@1 as match_count, sum(stock_price.price)@2 as total_price, avg(stock_price.price)@3 as avg_price, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]@4 as double_price], schema=[match_count:Int64, total_price:Int64;N, avg_price:Float64;N, double_price:Int64;N]
02)--AggregateExec: mode=FinalPartitioned, gby=[__mr_match_number@0 as __mr_match_number], aggr=[count(Int64(1)), sum(stock_price.price), avg(stock_price.price), last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, count(Int64(1)):Int64, sum(stock_price.price):Int64;N, avg(stock_price.price):Float64;N, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]:Int64;N]
03)----SortExec: expr=[__mr_match_number@0 ASC NULLS LAST], preserve_partitioning=[true], schema=[__mr_match_number:UInt64;N, count(Int64(1))[count]:Int64, sum(stock_price.price)[sum]:Int64;N, avg(stock_price.price)[count]:UInt64;N, avg(stock_price.price)[sum]:Float64;N, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[__mr_match_number:UInt64;N, count(Int64(1))[count]:Int64, sum(stock_price.price)[sum]:Int64;N, avg(stock_price.price)[count]:UInt64;N, avg(stock_price.price)[sum]:Float64;N, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
05)--------RepartitionExec: partitioning=Hash([__mr_match_number@0], 4), input_partitions=4, schema=[__mr_match_number:UInt64;N, count(Int64(1))[count]:Int64, sum(stock_price.price)[sum]:Int64;N, avg(stock_price.price)[count]:UInt64;N, avg(stock_price.price)[sum]:Float64;N, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
06)----------AggregateExec: mode=Partial, gby=[__mr_match_number@2 as __mr_match_number], aggr=[count(Int64(1)), sum(stock_price.price), avg(stock_price.price), last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST]], ordering_mode=Sorted, schema=[__mr_match_number:UInt64;N, count(Int64(1))[count]:Int64, sum(stock_price.price)[sum]:Int64;N, avg(stock_price.price)[count]:UInt64;N, avg(stock_price.price)[sum]:Float64;N, last_value(stock_price.price * Int64(2)) ORDER BY [__mr_match_sequence_number ASC NULLS LAST][last_value]:Int64;N, __mr_match_sequence_number@3:UInt64;N, is_set:Boolean;N]
07)------------ProjectionExec: expr=[CAST(price@0 AS Int64) as __common_expr_1, price@0 as price, __mr_match_number@1 as __mr_match_number, __mr_match_sequence_number@2 as __mr_match_sequence_number], schema=[__common_expr_1:Int64;N, price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
08)--------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
09)----------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[price], metadata=[__mr_match_number,__mr_match_sequence_number]}, schema=[price:Int32;N, __mr_match_number:UInt64;N, __mr_match_sequence_number:UInt64;N]
10)------------------ProjectionExec: expr=[price@0 as price, price@0 > 100 as __mr_symbol_a], schema=[price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[price:Int32;N]

# Test clause combinations
query TT
EXPLAIN SELECT * FROM stock_price
MATCH_RECOGNIZE (
    PARTITION BY company
    ORDER BY price_date
    MEASURES COUNT(*) AS cnt
    PATTERN (A)
    DEFINE A AS price > 100
)
----
logical_plan
01)Projection: stock_price.company, count(Int64(1)) AS cnt
02)--Aggregate: groupBy=[[stock_price.company, __mr_match_number]], aggr=[[count(Int64(1))]]
03)----MatchRecognize: partition_by=[stock_price.company] order_by=[stock_price.price_date ASC NULLS LAST] after_skip=[PAST LAST ROW] pattern=[A] symbols=[A] rows_per_match=[ALL ROWS PER MATCH SHOW EMPTY MATCHES] defines=[A: stock_price.price > Int32(100) AS stock_price.price > Int64(100)] output={passthrough_columns=[stock_price.company], metadata=[__mr_match_number]}
04)------TableScan: stock_price projection=[company, price_date, price]
physical_plan
01)ProjectionExec: expr=[company@0 as company, count(Int64(1))@2 as cnt], schema=[company:Utf8View;N, cnt:Int64]
02)--AggregateExec: mode=FinalPartitioned, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=PartiallySorted([1]), schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1)):Int64]
03)----SortExec: expr=[__mr_match_number@1 ASC NULLS LAST], preserve_partitioning=[true], schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
04)------CoalesceBatchesExec: target_batch_size=8192, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
05)--------RepartitionExec: partitioning=Hash([company@0, __mr_match_number@1], 4), input_partitions=4, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
06)----------AggregateExec: mode=Partial, gby=[company@0 as company, __mr_match_number@1 as __mr_match_number], aggr=[count(Int64(1))], ordering_mode=Sorted, schema=[company:Utf8View;N, __mr_match_number:UInt64;N, count(Int64(1))[count]:Int64]
07)------------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
08)--------------MatchRecognizePatternExec: pattern=[A] output={passthrough_columns=[company], metadata=[__mr_match_number]}, schema=[company:Utf8View;N, __mr_match_number:UInt64;N]
09)----------------SortExec: expr=[company@0 ASC NULLS LAST, price_date@1 ASC NULLS LAST], preserve_partitioning=[false], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
10)------------------ProjectionExec: expr=[company@0 as company, price_date@1 as price_date, price@2 as price, price@2 > 100 as __mr_symbol_a], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N, __mr_symbol_a:Boolean;N]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1], schema=[company:Utf8View;N, price_date:Date32;N, price:Int32;N]
