# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
# Tests for schema evolution -- reading
# data from different files with different schemas
##########


statement ok
CREATE EXTERNAL TABLE parquet_table(a varchar, b int, c float) STORED AS PARQUET
LOCATION 'test_files/scratch/schema_evolution/parquet_table/';

# File1 has only columns a and b
statement ok
COPY  (
  SELECT column1 as a, column2 as b
  FROM ( VALUES ('foo', 1), ('foo', 2), ('foo', 3) )
 )  TO 'test_files/scratch/schema_evolution/parquet_table/1.parquet'
STORED AS PARQUET;


# File2 has only b
statement ok
COPY  (
  SELECT column1 as b
  FROM ( VALUES (10) )
 )  TO 'test_files/scratch/schema_evolution/parquet_table/2.parquet'
STORED AS PARQUET;

# File3 has a column from 'z' which does not appear in the table
# but also values from a which do appear in the table
statement ok
COPY  (
  SELECT column1 as z, column2 as a
    FROM ( VALUES ('bar', 'foo'), ('blarg', 'foo') )
 )  TO 'test_files/scratch/schema_evolution/parquet_table/3.parquet'
STORED AS PARQUET;

# File4 has data for b and a (reversed) and d
statement ok
COPY  (
  SELECT column1 as b, column2 as a, column3 as c
    FROM ( VALUES (100, 'foo', 10.5), (200, 'foo', 12.6), (300, 'bzz', 13.7) )
 )  TO 'test_files/scratch/schema_evolution/parquet_table/4.parquet'
STORED AS PARQUET;

# The logical distribution of `a`, `b` and `c` in the files is like this:
#
## File1:
# foo 1 NULL
# foo 2 NULL
# foo 3 NULL
#
## File2:
# NULL 10 NULL
#
## File3:
# foo NULL NULL
# foo NULL NULL
#
## File4:
# foo 100 10.5
# foo 200 12.6
# bzz 300 13.7

# Show all the data
query TIR rowsort
select * from parquet_table;
----
NULL 10 NULL
bzz 300 13.7
foo 1 NULL
foo 100 10.5
foo 2 NULL
foo 200 12.6
foo 3 NULL
foo NULL NULL
foo NULL NULL

# Should see all 7 rows that have 'a=foo'
query TIR rowsort
select * from parquet_table where a = 'foo';
----
foo 1 NULL
foo 100 10.5
foo 2 NULL
foo 200 12.6
foo 3 NULL
foo NULL NULL
foo NULL NULL

query TIR rowsort
select * from parquet_table where a != 'foo';
----
bzz 300 13.7

# this should produce at least one row
query TIR rowsort
select * from parquet_table where a is NULL;
----
NULL 10 NULL

query TIR rowsort
select * from parquet_table where b > 5;
----
NULL 10 NULL
bzz 300 13.7
foo 100 10.5
foo 200 12.6


query TIR rowsort
select * from parquet_table where b < 150;
----
NULL 10 NULL
foo 1 NULL
foo 100 10.5
foo 2 NULL
foo 3 NULL

query TIR rowsort
select * from parquet_table where c > 11.0;
----
bzz 300 13.7
foo 200 12.6

##########
# Projection tests - selecting subset of columns
# These tests verify column reordering and projection work correctly
# with schema evolution (addresses E2E column reordering concern)
##########

# Select only column a
query T rowsort
select a from parquet_table;
----
NULL
bzz
foo
foo
foo
foo
foo
foo
foo

# Select columns in different order than table schema (c, a instead of a, b, c)
query RT rowsort
select c, a from parquet_table;
----
10.5 foo
12.6 foo
13.7 bzz
NULL NULL
NULL foo
NULL foo
NULL foo
NULL foo
NULL foo

# Select single column that's missing in some files
query I rowsort
select b from parquet_table;
----
1
10
100
2
200
3
300
NULL
NULL

##########
# Projection with filter tests
##########

# Projection with equality filter
query TI rowsort
select a, b from parquet_table where a = 'foo';
----
foo 1
foo 100
foo 2
foo 200
foo 3
foo NULL
foo NULL

# Projection with range filter on projected column
query IR rowsort
select b, c from parquet_table where b > 5;
----
10 NULL
100 10.5
200 12.6
300 13.7

# Projection excluding filtered column (filter on c, project a)
query T rowsort
select a from parquet_table where c > 11.0;
----
bzz
foo

##########
# Complex filter tests - OR combinations and IS NOT NULL
##########

# OR combination
query TIR rowsort
select * from parquet_table where a = 'foo' OR b > 100;
----
bzz 300 13.7
foo 1 NULL
foo 100 10.5
foo 2 NULL
foo 200 12.6
foo 3 NULL
foo NULL NULL
foo NULL NULL

# IS NOT NULL on column a
query TIR rowsort
select * from parquet_table where a IS NOT NULL;
----
bzz 300 13.7
foo 1 NULL
foo 100 10.5
foo 2 NULL
foo 200 12.6
foo 3 NULL
foo NULL NULL
foo NULL NULL

# IS NOT NULL on column c (missing in most files)
query TIR rowsort
select * from parquet_table where c IS NOT NULL;
----
bzz 300 13.7
foo 100 10.5
foo 200 12.6

# Combined conditions with NULL checks
query TIR rowsort
select * from parquet_table where a IS NULL OR (b IS NOT NULL AND b > 5);
----
NULL 10 NULL
bzz 300 13.7
foo 100 10.5
foo 200 12.6

##########
# Multi-column predicates
##########

# AND across columns with different availability
query TIR rowsort
select * from parquet_table where a = 'foo' AND b > 50;
----
foo 100 10.5
foo 200 12.6

# Filter on multiple columns from reordered file (File4 has b, a, c order)
query TIR rowsort
select * from parquet_table where b = 100 AND c = 10.5;
----
foo 100 10.5
