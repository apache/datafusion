# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#############
## Struct Expressions Tests
#############

statement ok
CREATE TABLE values(
    a INT,
    b FLOAT,
    c VARCHAR,
    n VARCHAR
) AS VALUES
  (1, 1.1, 'a', NULL),
  (2, 2.2, 'b', NULL),
  (3, 3.3, 'c', NULL)
;


# named and named less struct fields
statement ok
CREATE TABLE struct_values (
    s1 struct<INT>,
    s2 struct<a INT,b VARCHAR>
) AS VALUES
  (struct(1), struct(1, 'string1')),
  (struct(2), struct(2, 'string2')),
  (struct(3), struct(3, 'string3'))
;

query ??
select * from struct_values;
----
{c0: 1} {a: 1, b: string1}
{c0: 2} {a: 2, b: string2}
{c0: 3} {a: 3, b: string3}

query TT
select arrow_typeof(s1), arrow_typeof(s2) from struct_values;
----
Struct("c0": Int32) Struct("a": Int32, "b": Utf8View)
Struct("c0": Int32) Struct("a": Int32, "b": Utf8View)
Struct("c0": Int32) Struct("a": Int32, "b": Utf8View)


# struct[i]
query IRT
select struct(1, 3.14, 'h')['c0'], struct(3, 2.55, 'b')['c1'], struct(2, 6.43, 'a')['c2'];
----
1 2.55 a

# struct[i] with columns
query R
select struct(a, b, c)['c1'] from values;
----
1.1
2.2
3.3

# explicit invocation of get_field
query R
select get_field(struct(a, b, c), 'c1') from values;
----
1.1
2.2
3.3

# struct scalar function #1
query ?
select struct(1, 3.14, 'e');
----
{c0: 1, c1: 3.14, c2: e}

# struct scalar function with named values
query ?
select struct(1 as "name0", 3.14 as name1, 'e', true as 'name3');
----
{name0: 1, name1: 3.14, c2: e, name3: true}

# struct scalar function with mixed named and unnamed values
query ?
select struct(1, 3.14 as name1, 'e', true);
----
{c0: 1, name1: 3.14, c2: e, c3: true}

# struct scalar function with columns #1
query ?
select struct(a, b, c) from values;
----
{c0: 1, c1: 1.1, c2: a}
{c0: 2, c1: 2.2, c2: b}
{c0: 3, c1: 3.3, c2: c}

# struct scalar function with columns and scalars
query ?
select struct(a, 'foo') from values;
----
{c0: 1, c1: foo}
{c0: 2, c1: foo}
{c0: 3, c1: foo}


# explain struct scalar function with columns #1
query TT
explain select struct(a, b, c) from values;
----
logical_plan
01)Projection: struct(values.a, values.b, values.c)
02)--TableScan: values projection=[a, b, c]
physical_plan
01)ProjectionExec: expr=[struct(a@0, b@1, c@2) as struct(values.a,values.b,values.c)]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

# error on 0 arguments
query error
select named_struct();

# error on duplicate field names
query error
select named_struct('c0': 1, 'c1': 2, 'c1': 3);

# error on odd number of arguments #1
query error DataFusion error: Execution error: named_struct requires an even number of arguments, got 1 instead
select named_struct('a');

# error on odd number of arguments #2
query error DataFusion error: Execution error: named_struct requires an even number of arguments, got 1 instead
select named_struct(1);

# error on odd number of arguments #3
query error DataFusion error: Execution error: named_struct requires an even number of arguments, got 1 instead
select named_struct(values.a) from values;

# error on odd number of arguments #4
query error DataFusion error: Execution error: named_struct requires an even number of arguments, got 3 instead
select named_struct('a', 1, 'b');

# error on even argument not a string literal #1
query error DataFusion error: Execution error: named_struct requires 0\-th \(0\-indexed\) field name as non\-empty constant string
select named_struct(1, 'a');

# error on even argument not a string literal #2
query error DataFusion error: Execution error: named_struct requires 2\-th \(0\-indexed\) field name as non\-empty constant string
select named_struct('corret', 1, 0, 'wrong');

# error on even argument not a string literal #3
query error DataFusion error: Execution error: named_struct requires 0\-th \(0\-indexed\) field name as non\-empty constant string
select named_struct(values.a, 'a') from values;

# error on even argument not a string literal #4
query error DataFusion error: Execution error: named_struct requires 0\-th \(0\-indexed\) field name as non\-empty constant string
select named_struct(values.c, 'c') from values;

# named_struct with mixed scalar and array values #1
query ?
select named_struct('scalar', 27, 'array', values.a, 'null', NULL) from values;
----
{scalar: 27, array: 1, null: NULL}
{scalar: 27, array: 2, null: NULL}
{scalar: 27, array: 3, null: NULL}

query ?
select {'scalar': 27, 'array': values.a, 'null': NULL} from values;
----
{scalar: 27, array: 1, null: NULL}
{scalar: 27, array: 2, null: NULL}
{scalar: 27, array: 3, null: NULL}

# named_struct with mixed scalar and array values #2
query ?
select named_struct('array', values.a, 'scalar', 27, 'null', NULL) from values;
----
{array: 1, scalar: 27, null: NULL}
{array: 2, scalar: 27, null: NULL}
{array: 3, scalar: 27, null: NULL}

query ?
select {'array': values.a, 'scalar': 27, 'null': NULL} from values;
----
{array: 1, scalar: 27, null: NULL}
{array: 2, scalar: 27, null: NULL}
{array: 3, scalar: 27, null: NULL}

# named_struct with mixed scalar and array values #3
query ?
select named_struct('null', NULL, 'array', values.a, 'scalar', 27) from values;
----
{null: NULL, array: 1, scalar: 27}
{null: NULL, array: 2, scalar: 27}
{null: NULL, array: 3, scalar: 27}

# named_struct with mixed scalar and array values #4
query ?
select named_struct('null_array', values.n, 'array', values.a, 'scalar', 27, 'null', NULL) from values;
----
{null_array: NULL, array: 1, scalar: 27, null: NULL}
{null_array: NULL, array: 2, scalar: 27, null: NULL}
{null_array: NULL, array: 3, scalar: 27, null: NULL}

# named_struct arrays only
query ?
select named_struct('field_a', a, 'field_b', b) from values;
----
{field_a: 1, field_b: 1.1}
{field_a: 2, field_b: 2.2}
{field_a: 3, field_b: 3.3}

# named_struct scalars only
query ?
select named_struct('field_a', 1, 'field_b', 2);
----
{field_a: 1, field_b: 2}

query T
select arrow_typeof(named_struct('first', 1, 'second', 2, 'third', 3));
----
Struct("first": Int64, "second": Int64, "third": Int64)

query T
select arrow_typeof({'first': 1, 'second': 2, 'third': 3});
----
Struct("first": Int64, "second": Int64, "third": Int64)

# test nested struct literal
query ?
select {'animal': {'cat': 1, 'dog': 2, 'bird': {'parrot': 3, 'canary': 1}}, 'genre': {'fiction': ['mystery', 'sci-fi', 'fantasy'], 'non-fiction': {'biography': 5, 'history': 7, 'science': {'physics': 2, 'biology': 3}}}, 'vehicle': {'car': {'sedan': 4, 'suv': 2}, 'bicycle': 3, 'boat': ['sailboat', 'motorboat']}, 'weather': {'sunny': True, 'temperature': 25.5, 'wind': {'speed': 10, 'direction': 'NW'}}};
----
{animal: {cat: 1, dog: 2, bird: {parrot: 3, canary: 1}}, genre: {fiction: [mystery, sci-fi, fantasy], non-fiction: {biography: 5, history: 7, science: {physics: 2, biology: 3}}}, vehicle: {car: {sedan: 4, suv: 2}, bicycle: 3, boat: [sailboat, motorboat]}, weather: {sunny: true, temperature: 25.5, wind: {speed: 10, direction: NW}}}

# test tuple as struct
query B
select ('x', 'y') = ('x', 'y');
----
true

query B
select ('x', 'y') = ('y', 'x');
----
false

query error DataFusion error: Error during planning: Cannot infer common argument type for comparison operation Struct.*
select ('x', 'y') = ('x', 'y', 'z');

query B
select ('x', 'y') IN (('x', 'y'));
----
true

query B
select ('x', 'y') IN (('x', 'y'), ('y', 'x'));
----
true

query I
select a from values where (a, c) = (1, 'a');
----
1

query I
select a from values as v where (v.a, v.c) = (1, 'a');
----
1

query I
select a from values as v where (v.a, v.c) != (1, 'a');
----
2
3

query I
select a from values as v where (v.a, v.c) = (1, 'b');
----

query I
select a from values where (a, c) IN ((1, 'a'), (2, 'b'));
----
1
2

query I
select a from values as v where (v.a, v.c) IN ((1, 'a'), (2, 'b'));
----
1
2

statement ok
drop table values;

statement ok
drop table struct_values;

statement ok
CREATE OR REPLACE VIEW complex_view AS 
SELECT {
    'user_information': {
        'info': {
            'personal': {
                'name': 'John Doe',
                'age': 30,
                'email': 'john.doe@example.com'
            },
            'address': {
                'street': '123 Main St',
                'city': 'Anytown',
                'country': 'Countryland',
                'coordinates': [40.7128, -74.0060]
            }
        },
        'preferences': {
            'theme': 'dark',
            'notifications': true,
            'languages': ['en', 'es', 'fr']
        },
        'stats': {
            'logins': 42,
            'last_active': '2023-09-15',
            'scores': [85, 92, 78, 95],
            'achievements': {
                'badges': ['early_bird', 'top_contributor'],
                'levels': {
                    'beginner': true,
                    'intermediate': true,
                    'advanced': false
                }
            }
        }
    },
    'metadata': {
        'version': '1.0',
        'created_at': '2023-09-01T12:00:00Z'
    },
    'deep_nested': {
        'level1': {
            'level2': {
                'level3': {
                    'level4': {
                        'level5': {
                            'level6': {
                                'level7': {
                                    'level8': {
                                        'level9': {
                                            'level10': 'You reached the bottom!'
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
} AS complex_data;

query T
SELECT complex_data.user_information.info.personal.name FROM complex_view;
----
John Doe

query I
SELECT complex_data.user_information.info.personal.age FROM complex_view;
----
30

query T
SELECT complex_data.user_information.info.address.city FROM complex_view;
----
Anytown

query T
SELECT complex_data.user_information.preferences.languages[2] FROM complex_view;
----
es

query T
SELECT complex_data.deep_nested.level1.level2.level3.level4.level5.level6.level7.level8.level9.level10 FROM complex_view;
----
You reached the bottom!

statement ok
drop view complex_view;

# struct with different keys r1 and r2 is not valid
statement ok
create table t(a struct<r1 varchar, c int>, b struct<r2 varchar, c float>) as values (struct('red', 1), struct('blue', 2.3));

# Expect same keys for struct type but got mismatched pair r1,c and r2,c
query error
select [a, b] from t;

statement ok
drop table t;

# struct with the same key
statement ok
create table t(a struct<r varchar, c int>, b struct<r varchar, c float>) as values (struct('red', 1), struct('blue', 2.3));

query T
select arrow_typeof([a, b]) from t;
----
List(Struct("r": Utf8View, "c": Float32))

query ?
select [a, b] from t;
----
[{r: red, c: 1.0}, {r: blue, c: 2.3}]

statement ok
drop table t;

# Test row alias

query ?
select row('a', 'b');
----
{c0: a, c1: b}

##################################
# Switch Dialect to DuckDB
##################################

statement ok
set datafusion.sql_parser.dialect = 'DuckDB';

statement ok
CREATE TABLE struct_values (
    s1 struct(a int, b varchar),
    s2 struct(a int, b varchar)
) AS VALUES
  (row(1, 'red'), row(1, 'string1')),
  (row(2, 'blue'), row(2, 'string2')),
  (row(3, 'green'), row(3, 'string3'))
;

statement ok
drop table struct_values;

statement ok
create table t (c1 struct(r varchar, b int), c2 struct(r varchar, b float)) as values (
    row('red', 2),
    row('blue', 2.3)
);

query ??
select * from t;
----
{r: red, b: 2} {r: blue, b: 2.3}

query T
select arrow_typeof(c1) from t;
----
Struct("r": Utf8View, "b": Int32)

query T
select arrow_typeof(c2) from t;
----
Struct("r": Utf8View, "b": Float32)

statement ok
drop table t;

statement ok
create table t as values({r: 'a', c: 1}), ({r: 'b', c: 2.3});

query ?
select * from t;
----
{r: a, c: 1.0}
{r: b, c: 2.3}

query T
select arrow_typeof(column1) from t;
----
Struct("r": Utf8, "c": Float64)
Struct("r": Utf8, "c": Float64)

statement ok
drop table t;

##################################
## Test Coalesce with Struct
##################################

statement ok
CREATE TABLE t (
    s1 struct(a int, b varchar),
    s2 struct(a float, b varchar)
) AS VALUES
  (row(1, 'red'), row(1.1, 'string1')),
  (row(2, 'blue'), row(2.2, 'string2')),
  (row(3, 'green'), row(33.2, 'string3'))
;

query ?
select coalesce(s1) from t;
----
{a: 1, b: red}
{a: 2, b: blue}
{a: 3, b: green}

query T
select arrow_typeof(coalesce(s1, s2)) from t;
----
Struct("a": Float32, "b": Utf8View)
Struct("a": Float32, "b": Utf8View)
Struct("a": Float32, "b": Utf8View)

statement ok
drop table t;

statement ok
CREATE TABLE t (
    s1 struct(a int, b varchar),
    s2 struct(a float, b varchar)
) AS VALUES
  (row(1, 'red'), row(1.1, 'string1')),
  (null, row(2.2, 'string2')),
  (row(3, 'green'), row(33.2, 'string3'))
;

query ?
select coalesce(s1, s2) from t;
----
{a: 1.0, b: red}
{a: 2.2, b: string2}
{a: 3.0, b: green}

query T
select arrow_typeof(coalesce(s1, s2)) from t;
----
Struct("a": Float32, "b": Utf8View)
Struct("a": Float32, "b": Utf8View)
Struct("a": Float32, "b": Utf8View)

statement ok
drop table t;

# row() with incorrect order - row() is positional, not name-based
statement error DataFusion error: Optimizer rule 'simplify_expressions' failed[\s\S]*Arrow error: Cast error: Cannot cast string 'blue' to value of Float32 type
create table t(a struct(r varchar, c int), b struct(r varchar, c float)) as values
    (row('red', 1), row(2.3, 'blue')),
    (row('purple', 1), row('green', 2.3));


##################################
## Test Array of Struct
##################################

query ?
select [{r: 'a', c: 1}, {r: 'b', c: 2}];
----
[{r: a, c: 1}, {r: b, c: 2}]


statement ok
create table t(a struct(r varchar, c int), b struct(r varchar, c float)) as values (row('a', 1), row('b', 2.3));

query T
select arrow_typeof([a, b]) from t;
----
List(Struct("r": Utf8View, "c": Float32))

statement ok
drop table t;


statement ok
create table t(a struct(r varchar, c int, g float), b struct(r varchar, c float, g int)) as values (row('a', 1, 2.3), row('b', 2.3, 2));

# type of each column should not coerced but preserve as it is
query T
select arrow_typeof(a) from t;
----
Struct("r": Utf8View, "c": Int32, "g": Float32)

# type of each column should not coerced but preserve as it is
query T
select arrow_typeof(b) from t;
----
Struct("r": Utf8View, "c": Float32, "g": Int32)

statement ok
drop table t;


# Test struct field access with subscript notation
# This tests accessing struct fields using the subscript notation with string literals

statement ok
create table test (struct_field struct(substruct int)) as values (struct(1));

query ??
select *
from test as test1, test as test2 where
test1.struct_field['substruct'] = test2.struct_field['substruct'];
----
{substruct: 1} {substruct: 1}

statement ok
DROP TABLE test;

statement ok
create table test (struct_field struct(substruct struct(subsubstruct int))) as values (struct(struct(1)));

query ??
select *
from test as test1, test as test2 where
test1.struct_field.substruct['subsubstruct'] = test2.struct_field.substruct['subsubstruct'];
----
{substruct: {subsubstruct: 1}} {substruct: {subsubstruct: 1}}

query ??
select *
from test AS test1, test AS test2 where
test1.struct_field['substruct']['subsubstruct'] = test2.struct_field['substruct']['subsubstruct'];
----
{substruct: {subsubstruct: 1}} {substruct: {subsubstruct: 1}}

statement ok
drop table test;

# Test nested get_field with multiple arguments
query I
select get_field({'a': {'b': 1}}, 'a', 'b');
----
1

# Test nested get_field with three levels
query I
select get_field({'a': {'b': {'c': 42}}}, 'a', 'b', 'c');
----
42

# Test type validation error - accessing field on non-struct
query error Cannot access field at argument 2: type Int64 is not Struct, Map, or Null
select get_field({'a': 1}, 'a', 'b');

# Test that bracket syntax produces a single get_field call (not nested)
# We use a table column to prevent constant folding
statement ok
create table explain_test (s struct(a struct(b int))) as values ({'a': {'b': 1}});

query TT
explain select s['a']['b'] from explain_test;
----
logical_plan
01)Projection: get_field(explain_test.s, Utf8("a"), Utf8("b"))
02)--TableScan: explain_test projection=[s]
physical_plan
01)ProjectionExec: expr=[get_field(s@0, a, b) as explain_test.s[a][b]]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
drop table explain_test;

# Test with nested struct in table
statement ok
create table nested_test (s struct(inner struct(val int))) as values ({'inner': {'val': 100}});

query I
select s['inner']['val'] from nested_test;
----
100

query I
select get_field(s, 'inner', 'val') from nested_test;
----
100

statement ok
drop table nested_test;

# Test mixed struct and map access
query I
select get_field({'m': map(['k'], [42])}, 'm', 'k');
----
42

# Test nested map access
query I
select {'m': map(['outer'], [map(['inner'], [99])])}['m']['outer']['inner'];
----
99

###############################################
# Additional tests for nested get_field support
###############################################

# Backwards compatibility: original 2-argument form still works
query I
select get_field({'a': 1}, 'a');
----
1

# Error: get_field with no arguments
query error get_field requires at least 2 arguments, got 0
select get_field();

# Error: get_field with only 1 argument
query error get_field requires at least 2 arguments, got 1
select get_field({'a': 1});

# Null handling: null at base should return null
query I
select get_field(CAST(NULL AS STRUCT(a STRUCT(b INT))), 'a', 'b');
----
NULL

# Null handling: null in middle of chain
statement ok
create table null_mid_test (s STRUCT(a STRUCT(b INT)));

statement ok
insert into null_mid_test values ({'a': NULL});

query I
select s['a']['b'] from null_mid_test;
----
NULL

query I
select get_field(s, 'a', 'b') from null_mid_test;
----
NULL

statement ok
drop table null_mid_test;

# Type validation error at argument 3
query error Cannot access field at argument 3: type Int64 is not Struct, Map, or Null
select get_field({'a': {'b': 2}}, 'a', 'b', 'c');

# Type validation error at argument 4
query error Cannot access field at argument 4: type Int64 is not Struct, Map, or Null
select get_field({'a': {'b': {'c': 3}}}, 'a', 'b', 'c', 'd');

# Non-existent field at first level
query error Field x not found in struct
select get_field({'a': 1}, 'x');

# Non-existent field at second level
query error Field x not found in struct
select get_field({'a': {'b': 1}}, 'a', 'x');

# Deep nesting: 5-level access
query I
select get_field({'l1': {'l2': {'l3': {'l4': {'l5': 42}}}}}, 'l1', 'l2', 'l3', 'l4', 'l5');
----
42

# Deep nesting: 5-level access via bracket syntax
query I
select {'l1': {'l2': {'l3': {'l4': {'l5': 99}}}}}['l1']['l2']['l3']['l4']['l5'];
----
99

# Mixed array and struct access: array index should break the batching
statement ok
create table mixed_access_test (data STRUCT(items STRUCT(name VARCHAR)[]) );

statement ok
insert into mixed_access_test values ({'items': [{'name': 'first'}, {'name': 'second'}]});

query T
select data['items'][1]['name'] from mixed_access_test;
----
first

query T
select data['items'][2]['name'] from mixed_access_test;
----
second

statement ok
drop table mixed_access_test;

# Nullable parent propagation: null parent should propagate
statement ok
create table nullable_parent_test (s STRUCT(a STRUCT(b INT)));

statement ok
insert into nullable_parent_test values ({'a': {'b': 1}}), (NULL);

query I
select s['a']['b'] from nullable_parent_test;
----
1
NULL

statement ok
drop table nullable_parent_test;

# Test struct casting with field reordering - string fields
query ?
SELECT CAST({b: 'b_value', a: 'a_value'} AS STRUCT(a VARCHAR, b VARCHAR));
----
{a: a_value, b: b_value}

# Test struct casting with field reordering - integer fields
query ?
SELECT CAST({b: 3, a: 4} AS STRUCT(a INT, b INT));
----
{a: 4, b: 3}

# Test with type casting AND field reordering
query ?
SELECT CAST({b: 3, a: 4} AS STRUCT(a BIGINT, b INT));
----
{a: 4, b: 3}

# Test positional casting when there is no name overlap
query ?
SELECT CAST(struct(1, 'x') AS STRUCT(a INT, b VARCHAR));
----
{a: 1, b: x}

# Test with missing field - should insert nulls
query ?
SELECT CAST({a: 1} AS STRUCT(a INT, b INT));
----
{a: 1, b: NULL}

# Test with extra source field - should be ignored
query ?
SELECT CAST({a: 1, b: 2, extra: 3} AS STRUCT(a INT, b INT));
----
{a: 1, b: 2}

# Test no overlap with mismatched field count - should fail because no field names match
statement error DataFusion error: (Plan error|Error during planning|This feature is not implemented): (Cannot cast struct: at least one field name must match between source and target|Cannot cast struct with 3 fields to 2 fields without name overlap|Unsupported CAST from Struct)
SELECT CAST(struct(1, 'x', 'y') AS STRUCT(a INT, b VARCHAR));

# Test nested struct with field reordering
query ?
SELECT CAST(
  {inner: {y: 2, x: 1}}
  AS STRUCT(inner STRUCT(x INT, y INT))
);
----
{inner: {x: 1, y: 2}}

# Test field reordering with table data
statement ok
CREATE TABLE struct_reorder_test (
  data STRUCT(b INT, a VARCHAR)
) AS VALUES
  (struct(100, 'first')),
  (struct(200, 'second')),
  (struct(300, 'third'))
;

query ?
SELECT CAST(data AS STRUCT(a VARCHAR, b INT)) AS casted_data FROM struct_reorder_test ORDER BY data['b'];
----
{a: first, b: 100}
{a: second, b: 200}
{a: third, b: 300}

statement ok
drop table struct_reorder_test;

# Test casting struct with multiple levels of nesting and reordering
query ?
SELECT CAST(
  {level1: {z: 100, y: 'inner', x: 1}}
  AS STRUCT(level1 STRUCT(x INT, y VARCHAR, z INT))
);
----
{level1: {x: 1, y: inner, z: 100}}

# Test field reordering with nulls in source
query ?
SELECT CAST(
  {b: NULL::INT, a: 42}
  AS STRUCT(a INT, b INT)
);
----
{a: 42, b: NULL}

# Test casting preserves struct-level nulls
query ?
SELECT CAST(NULL::STRUCT(b INT, a INT) AS STRUCT(a INT, b INT));
----
NULL

############################
# Implicit Coercion Tests with CREATE TABLE AS VALUES
############################

# Test implicit coercion with same field order, different types
statement ok
create table t as values({r: 'a', c: 1}), ({r: 'b', c: 2.3});

query T
select arrow_typeof(column1) from t limit 1;
----
Struct("r": Utf8, "c": Float64)

query ?
select * from t order by column1.r;
----
{r: a, c: 1.0}
{r: b, c: 2.3}

statement ok
drop table t;

# Test implicit coercion with nullable fields (same order)
statement ok
create table t as values({a: 1, b: 'x'}), ({a: 2, b: 'y'});

query T
select arrow_typeof(column1) from t limit 1;
----
Struct("a": Int64, "b": Utf8)

query ?
select * from t order by column1.a;
----
{a: 1, b: x}
{a: 2, b: y}

statement ok
drop table t;

# Test implicit coercion with nested structs (same field order)
statement ok
create table t as 
  select {outer: {x: 1, y: 2}} as column1
  union all
  select {outer: {x: 3, y: 4}};

query T
select arrow_typeof(column1) from t limit 1;
----
Struct("outer": Struct("x": Int64, "y": Int64))

query ?
select column1 from t order by column1.outer.x;
----
{outer: {x: 1, y: 2}}
{outer: {x: 3, y: 4}}

statement ok
drop table t;

# Test implicit coercion with type widening (Int32 -> Int64)
statement ok
create table t as values({id: 1, val: 100}), ({id: 2, val: 9223372036854775807});

query T
select arrow_typeof(column1) from t limit 1;
----
Struct("id": Int64, "val": Int64)

query ?
select * from t order by column1.id;
----
{id: 1, val: 100}
{id: 2, val: 9223372036854775807}

statement ok
drop table t;

# Test implicit coercion with nested struct and type coercion
statement ok
create table t as 
  select {name: 'Alice', data: {score: 100, active: true}} as column1
  union all
  select {name: 'Bob', data: {score: 200, active: false}};

query T
select arrow_typeof(column1) from t limit 1;
----
Struct("name": Utf8, "data": Struct("score": Int64, "active": Boolean))

query ?
select column1 from t order by column1.name;
----
{name: Alice, data: {score: 100, active: true}}
{name: Bob, data: {score: 200, active: false}}

statement ok
drop table t;

############################
# Field Reordering Tests (using explicit CAST)
############################

# Test explicit cast with field reordering in VALUES - basic case
query ?
select CAST({c: 2.3, r: 'b'} AS STRUCT(r VARCHAR, c FLOAT));
----
{r: b, c: 2.3}

# Test explicit cast with field reordering - multiple rows
query ?
select * from (values 
  (CAST({c: 1, r: 'a'} AS STRUCT(r VARCHAR, c FLOAT))),
  (CAST({c: 2.3, r: 'b'} AS STRUCT(r VARCHAR, c FLOAT)))
) order by column1.r;
----
{r: a, c: 1.0}
{r: b, c: 2.3}

# Test table with explicit cast for field reordering
statement ok
create table t as select CAST({c: 1, r: 'a'} AS STRUCT(r VARCHAR, c FLOAT)) as s
union all
select CAST({c: 2.3, r: 'b'} AS STRUCT(r VARCHAR, c FLOAT));

query T
select arrow_typeof(s) from t limit 1;
----
Struct("r": Utf8View, "c": Float32)

query ?
select * from t order by s.r;
----
{r: a, c: 1.0}
{r: b, c: 2.3}

statement ok
drop table t;

# Test field reordering with nullable fields using CAST
query ?
select CAST({b: NULL, a: 42} AS STRUCT(a INT, b INT));
----
{a: 42, b: NULL}

# Test field reordering with nested structs using CAST
query ?
select CAST({outer: {y: 4, x: 3}} AS STRUCT(outer STRUCT(x INT, y INT)));
----
{outer: {x: 3, y: 4}}

# Test complex nested field reordering
query ?
select CAST(
  {data: {active: false, score: 200}, name: 'Bob'}
  AS STRUCT(name VARCHAR, data STRUCT(score INT, active BOOLEAN))
);
----
{name: Bob, data: {score: 200, active: false}}

############################
# Array Literal Tests with Struct Field Reordering (Implicit Coercion)
############################

# Test array literal with reordered struct fields - implicit coercion by name
# Field order in unified schema is determined during type coercion
query ?
select [{r: 'a', c: 1}, {c: 2.3, r: 'b'}];
----
[{c: 1.0, r: a}, {c: 2.3, r: b}]

# Test array literal with same-named fields but different order
# Fields are reordered during coercion
query ?
select [{a: 1, b: 2}, {b: 3, a: 4}];
----
[{b: 2, a: 1}, {b: 3, a: 4}]

# Test array literal with explicit cast to unify struct schemas with partial overlap
# Use CAST to explicitly unify schemas when fields don't match completely
query ?
select [
  CAST({a: 1, b: 2} AS STRUCT(a INT, b INT, c INT)),
  CAST({b: 3, c: 4} AS STRUCT(a INT, b INT, c INT))
];
----
[{a: 1, b: 2, c: NULL}, {a: NULL, b: 3, c: 4}]

# Test NULL handling in array literals with reordered but matching fields
query ?
select [{a: NULL, b: 1}, {b: 2, a: NULL}];
----
[{b: 1, a: NULL}, {b: 2, a: NULL}]

# Verify arrow_typeof for array with reordered struct fields
# The unified schema type follows the coercion order
query T
select arrow_typeof([{x: 1, y: 2}, {y: 3, x: 4}]);
----
List(Struct("y": Int64, "x": Int64))

# Test array of structs with matching nested fields in different order
# Inner nested fields are also reordered during coercion
query ?
select [
  {id: 1, info: {name: 'Alice', age: 30}},
  {info: {age: 25, name: 'Bob'}, id: 2}
];
----
[{info: {age: 30, name: Alice}, id: 1}, {info: {age: 25, name: Bob}, id: 2}]

# Test nested arrays with matching struct fields (different order)
query ?
select [[{x: 1, y: 2}], [{y: 4, x: 3}]];
----
[[{x: 1, y: 2}], [{x: 3, y: 4}]]

# Test array literal with float type coercion across elements
query ?
select [{val: 1}, {val: 2.5}];
----
[{val: 1.0}, {val: 2.5}]

############################
# Dynamic Array Construction Tests (from Table Columns)
############################

# Setup test table with struct columns for dynamic array construction
statement ok
create table t_complete_overlap (
  s1 struct(x int, y int),
  s2 struct(y int, x int)
) as values
  ({x: 1, y: 2}, {y: 3, x: 4}),
  ({x: 5, y: 6}, {y: 7, x: 8});

# Test 1: Complete overlap - same fields, different order
# Verify arrow_typeof for dynamically created array
query T
select arrow_typeof([s1, s2]) from t_complete_overlap limit 1;
----
List(Struct("y": Int32, "x": Int32))

# Verify values are correctly mapped by name in the array
# Field order follows the second column's field order
query ?
select [s1, s2] from t_complete_overlap order by s1.x;
----
[{y: 2, x: 1}, {y: 3, x: 4}]
[{y: 6, x: 5}, {y: 7, x: 8}]

statement ok
drop table t_complete_overlap;

# Test 2: Partial overlap - some shared fields between columns
# Note: Columns must have the exact same field set for array construction to work
# Test with identical field set (all fields present in both columns)
statement ok
create table t_partial_overlap (
  col_a struct(name VARCHAR, age int, active boolean),
  col_b struct(age int, name VARCHAR, active boolean)
) as values
  ({name: 'Alice', age: 30, active: true}, {age: 25, name: 'Bob', active: false}),
  ({name: 'Charlie', age: 35, active: true}, {age: 40, name: 'Diana', active: false});

# Verify unified type includes all fields from both structs
query T
select arrow_typeof([col_a, col_b]) from t_partial_overlap limit 1;
----
List(Struct("age": Int32, "name": Utf8View, "active": Boolean))

# Verify values are correctly mapped by name in the array
# Field order follows the second column's field order
query ?
select [col_a, col_b] from t_partial_overlap order by col_a.name;
----
[{age: 30, name: Alice, active: true}, {age: 25, name: Bob, active: false}]
[{age: 35, name: Charlie, active: true}, {age: 40, name: Diana, active: false}]

statement ok
drop table t_partial_overlap;

# Test 3: Complete field set matching (no CAST needed)
# Schemas already align; confirm unified type and values
statement ok
create table t_with_cast (
  col_x struct(id int, description VARCHAR),
  col_y struct(id int, description VARCHAR)
) as values
  ({id: 1, description: 'First'}, {id: 10, description: 'First Value'}),
  ({id: 2, description: 'Second'}, {id: 20, description: 'Second Value'});

# Verify type unification with all fields
query T
select arrow_typeof([col_x, col_y]) from t_with_cast limit 1;
----
List(Struct("id": Int32, "description": Utf8View))

# Verify values remain aligned by name
query ?
select [col_x, col_y] from t_with_cast order by col_x.id;
----
[{id: 1, description: First}, {id: 10, description: First Value}]
[{id: 2, description: Second}, {id: 20, description: Second Value}]

statement ok
drop table t_with_cast;

# Test 4: Explicit CAST for partial field overlap scenarios
# When columns have different field sets, use explicit CAST to unify schemas
query ?
select [
  CAST({id: 1} AS STRUCT(id INT, description VARCHAR)),
  CAST({id: 10, description: 'Value'} AS STRUCT(id INT, description VARCHAR))
];
----
[{id: 1, description: NULL}, {id: 10, description: Value}]

# Test 5: Complex nested structs with field reordering
# Nested fields must have the exact same field set for array construction
statement ok
create table t_nested (
  col_1 struct(id int, outer struct(x int, y int)),
  col_2 struct(id int, outer struct(x int, y int))
) as values
  ({id: 100, outer: {x: 1, y: 2}}, {id: 101, outer: {x: 4, y: 3}}),
  ({id: 200, outer: {x: 5, y: 6}}, {id: 201, outer: {x: 8, y: 7}});

# Verify nested struct in unified schema
query T
select arrow_typeof([col_1, col_2]) from t_nested limit 1;
----
List(Struct("id": Int32, "outer": Struct("x": Int32, "y": Int32)))

# Verify nested field values are correctly mapped
query ?
select [col_1, col_2] from t_nested order by col_1.id;
----
[{id: 100, outer: {x: 1, y: 2}}, {id: 101, outer: {x: 4, y: 3}}]
[{id: 200, outer: {x: 5, y: 6}}, {id: 201, outer: {x: 8, y: 7}}]

statement ok
drop table t_nested;

# Test 6: NULL handling with matching field sets
statement ok
create table t_nulls (
  col_a struct(val int, flag boolean),
  col_b struct(val int, flag boolean)
) as values
  ({val: 1, flag: true}, {val: 10, flag: false}),
  ({val: NULL, flag: false}, {val: NULL, flag: true});

# Verify NULL values are preserved
query ?
select [col_a, col_b] from t_nulls order by col_a.val;
----
[{val: 1, flag: true}, {val: 10, flag: false}]
[{val: NULL, flag: false}, {val: NULL, flag: true}]

statement ok
drop table t_nulls;

# Test 7: Multiple columns with complete field matching
statement ok
create table t_multi (
  col1 struct(a int, b int, c int),
  col2 struct(a int, b int, c int)
) as values
  ({a: 1, b: 2, c: 3}, {a: 10, b: 20, c: 30}),
  ({a: 4, b: 5, c: 6}, {a: 40, b: 50, c: 60});

# Verify array with complete field matching
query T
select arrow_typeof([col1, col2]) from t_multi limit 1;
----
List(Struct("a": Int32, "b": Int32, "c": Int32))

# Verify values are correctly unified
query ?
select [col1, col2] from t_multi order by col1.a;
----
[{a: 1, b: 2, c: 3}, {a: 10, b: 20, c: 30}]
[{a: 4, b: 5, c: 6}, {a: 40, b: 50, c: 60}]

statement ok
drop table t_multi;

############################
# Comprehensive Implicit Struct Coercion Suite
############################

# Test 1: VALUES clause with field reordering coerced by name into declared schema
statement ok
create table implicit_values_reorder (
  s struct(a int, b int)
) as values
  ({a: 1, b: 2}),
  ({b: 3, a: 4});

query T
select arrow_typeof(s) from implicit_values_reorder limit 1;
----
Struct("a": Int32, "b": Int32)

query ?
select s from implicit_values_reorder order by s.a;
----
{a: 1, b: 2}
{a: 4, b: 3}

statement ok
drop table implicit_values_reorder;

# Test 2: Array literal coercion with reordered struct fields
query IIII
select 
  [{a: 1, b: 2}, {b: 3, a: 4}][1]['a'],
  [{a: 1, b: 2}, {b: 3, a: 4}][1]['b'],
  [{a: 1, b: 2}, {b: 3, a: 4}][2]['a'],
  [{a: 1, b: 2}, {b: 3, a: 4}][2]['b'];
----
1 2 4 3

# Test 3: Array construction from columns with reordered struct fields
statement ok
create table struct_columns_order (
  s1 struct(a int, b int),
  s2 struct(b int, a int)
) as values
  ({a: 1, b: 2}, {b: 3, a: 4}),
  ({a: 5, b: 6}, {b: 7, a: 8});

query IIII
select 
  [s1, s2][1]['a'],
  [s1, s2][1]['b'],
  [s1, s2][2]['a'],
  [s1, s2][2]['b']
from struct_columns_order
order by s1['a'];
----
1 2 4 3
5 6 8 7

statement ok
drop table struct_columns_order;

# Test 4: UNION with struct field reordering
query II
select s['a'], s['b']
from (
  select {a: 1, b: 2} as s
  union all
  select {b: 3, a: 4} as s
) t
order by s['a'];
----
1 2
4 3

# Test 5: CTE with struct coercion across branches
query II
with 
  t1 as (select {a: 1, b: 2} as s),
  t2 as (select {b: 3, a: 4} as s)
select t1.s['a'], t1.s['b'] from t1
union all
select t2.s['a'], t2.s['b'] from t2
order by 1;
----
1 2
4 3

# Test 6: Struct aggregation retains name-based mapping
statement ok
create table agg_structs_reorder (
  k int,
  s struct(x int, y int)
) as values
  (1, {x: 1, y: 2}),
  (1, {y: 3, x: 4}),
  (2, {x: 5, y: 6});

query I?
select k, array_agg(s) from agg_structs_reorder group by k order by k;
----
1 [{x: 1, y: 2}, {x: 4, y: 3}]
2 [{x: 5, y: 6}]

statement ok
drop table agg_structs_reorder;

# Test 7: Nested struct coercion with reordered inner fields
query IIII
with nested as (
  select [{outer: {inner: 1, value: 2}}, {outer: {value: 3, inner: 4}}] as arr
)
select 
  arr[1]['outer']['inner'],
  arr[1]['outer']['value'],
  arr[2]['outer']['inner'],
  arr[2]['outer']['value']
from nested;
----
1 2 4 3

# Test 8: Partial name overlap - currently errors (field count mismatch detected)
# This is a documented limitation: structs must have exactly same field set for coercion
query error DataFusion error: Error during planning: Inconsistent data type across values list
select column1 from (values ({a: 1, b: 2}), ({b: 3, c: 4})) order by column1['a'];

# Negative test: mismatched struct field counts are rejected (documented limitation)
query error DataFusion error: .*
select [{a: 1}, {a: 2, b: 3}];

# Test 9: INSERT with name-based struct coercion into target schema
statement ok
create table target_struct_insert (s struct(a int, b int));

statement ok
insert into target_struct_insert values ({b: 1, a: 2});

query ?
select s from target_struct_insert;
----
{a: 2, b: 1}

statement ok
drop table target_struct_insert;

# Test 10: CASE expression with different struct field orders
query II
select 
  (case when true then {a: 1, b: 2} else {b: 3, a: 4} end)['a'] as a_val,
  (case when true then {a: 1, b: 2} else {b: 3, a: 4} end)['b'] as b_val;
----
1 2

############################
# JOIN Coercion Tests
############################

# Test: Struct coercion in JOIN ON condition
statement ok
create table t_left (
  id int,
  s struct(x int, y int)
) as values
  (1, {x: 1, y: 2}),
  (2, {x: 3, y: 4});

statement ok
create table t_right (
  id int,
  s struct(y int, x int)
) as values
  (1, {y: 2, x: 1}),
  (2, {y: 4, x: 3});

# JOIN on reordered struct fields - matched by name
query IIII
select t_left.id, t_left.s['x'], t_left.s['y'], t_right.id
from t_left
join t_right on t_left.s = t_right.s
order by t_left.id;
----
1 1 2 1
2 3 4 2

statement ok
drop table t_left;

statement ok
drop table t_right;

# Test: Struct coercion with filtered JOIN
statement ok
create table orders (
  order_id int,
  customer struct(name varchar, id int)
) as values
  (1, {name: 'Alice', id: 100}),
  (2, {name: 'Bob', id: 101}),
  (3, {name: 'Charlie', id: 102});

statement ok
create table customers (
  customer_id int,
  info struct(id int, name varchar)
) as values
  (100, {id: 100, name: 'Alice'}),
  (101, {id: 101, name: 'Bob'}),
  (103, {id: 103, name: 'Diana'});

# Join with struct field reordering - names matched, not positions
query I
select count(*) from orders
join customers on orders.customer = customers.info
where orders.order_id <= 2;
----
2

statement ok
drop table orders;

statement ok
drop table customers;

############################
# WHERE Predicate Coercion Tests
############################

# Test: Struct equality in WHERE clause with field reordering
statement ok
create table t_where (
  id int,
  s struct(x int, y int)
) as values
  (1, {x: 1, y: 2}),
  (2, {x: 3, y: 4}),
  (3, {x: 1, y: 2});

# WHERE clause with struct comparison - coerced by name
query I
select id from t_where
where s = {y: 2, x: 1}
order by id;
----
1
3

statement ok
drop table t_where;

# Test: Struct IN clause with reordering
statement ok
create table t_in (
  id int,
  s struct(a int, b varchar)
) as values
  (1, {a: 1, b: 'x'}),
  (2, {a: 2, b: 'y'}),
  (3, {a: 1, b: 'x'});

# IN clause with reordered struct literals
query I
select id from t_in
where s in ({b: 'x', a: 1}, {b: 'y', a: 2})
order by id;
----
1
2
3

statement ok
drop table t_in;

# Test: Struct BETWEEN (not supported, but documents limitation)
# Structs don't support BETWEEN, but can use comparison operators

statement ok
create table t_between (
  id int,
  s struct(val int)
) as values
  (1, {val: 10}),
  (2, {val: 20}),
  (3, {val: 30});

# Comparison via field extraction works
query I
select id from t_between
where s['val'] >= 20
order by id;
----
2
3

statement ok
drop table t_between;

############################
# Window Function Coercion Tests
############################

# Test: Struct in window function PARTITION BY
statement ok
create table t_window (
  id int,
  s struct(category int, value int)
) as values
  (1, {category: 1, value: 10}),
  (2, {category: 1, value: 20}),
  (3, {category: 2, value: 30}),
  (4, {category: 2, value: 40});

# Window partition on struct field via extraction
query III
select 
  id,
  s['value'],
  row_number() over (partition by s['category'] order by s['value'])
from t_window
order by id;
----
1 10 1
2 20 2
3 30 1
4 40 2

statement ok
drop table t_window;

# Test: Struct in window function ORDER BY with coercion
statement ok
create table t_rank (
  id int,
  s struct(rank_val int, group_id int)
) as values
  (1, {rank_val: 10, group_id: 1}),
  (2, {rank_val: 20, group_id: 1}),
  (3, {rank_val: 15, group_id: 2});

# Window ranking with struct field extraction
query III
select 
  id,
  s['rank_val'],
  rank() over (partition by s['group_id'] order by s['rank_val'])
from t_rank
order by id;
----
1 10 1
2 20 2
3 15 1

statement ok
drop table t_rank;

# Test: Aggregate function with struct coercion across window partitions
statement ok
create table t_agg_window (
  id int,
  partition_id int,
  s struct(amount int)
) as values
  (1, 1, {amount: 100}),
  (2, 1, {amount: 200}),
  (3, 2, {amount: 150});

# Running sum via extracted struct field
query III
select 
  id,
  partition_id,
  sum(s['amount']) over (partition by partition_id order by id)
from t_agg_window
order by id;
----
1 1 100
2 1 300
3 2 150

statement ok
drop table t_agg_window;