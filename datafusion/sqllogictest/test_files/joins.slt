# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


####
# Configuration
####

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 8192;

statement ok
set datafusion.explain.logical_plan_only = true;


####
# Data Setup
####

statement ok
set datafusion.execution.target_partitions = 1;

statement ok
CREATE TABLE join_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4);

statement ok
CREATE TABLE join_t2(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3);

statement ok
CREATE TABLE join_t3(s3 struct<id INT>)
  AS VALUES
  (NULL),
  (struct(1)),
  (struct(2));

statement ok
CREATE TABLE join_t4(s4 struct<id INT>)
  AS VALUES
  (NULL),
  (struct(2)),
  (struct(3));

# Left semi anti join

statement ok
CREATE TABLE lsaj_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4),
(NULL, 'e', 0);

statement ok
CREATE TABLE lsaj_t2(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3),
(NULL, 'v', 0);

statement ok
CREATE TABLE left_semi_anti_join_table_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4),
(NULL, 'e', 0);

statement ok
CREATE TABLE left_semi_anti_join_table_t2(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3),
(NULL, 'v', 0);


statement ok
CREATE TABLE right_semi_anti_join_table_t1(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4),
(NULL, 'e', 0);

statement ok
CREATE TABLE right_semi_anti_join_table_t2(t2_id INT UNSIGNED, t2_name VARCHAR)
AS VALUES
(11, 'a'),
(11, 'x'),
(NULL, NULL);

# Table with all of the supported timestamp types values
#
# Columns are named:
# "nanos" --> TimestampNanosecondArray
# "micros" --> TimestampMicrosecondArray
# "millis" --> TimestampMillisecondArray
# "secs" --> TimestampSecondArray
# "names" --> StringArray
statement ok
CREATE TABLE test_timestamps_table_source(ts varchar, names varchar)
AS VALUES
('2018-11-13T17:11:10.011375885995', 'Row 0'),
('2011-12-13T11:13:10.12345', 'Row 1'),
(NULL, 'Row 2'),
('2021-01-01T05:11:10.432', 'Row 3');


statement ok
CREATE TABLE test_timestamps_table as
SELECT
  arrow_cast(ts::timestamp::bigint, 'Timestamp(Nanosecond, None)') as nanos,
  arrow_cast(ts::timestamp::bigint / 1000, 'Timestamp(Microsecond, None)') as micros,
  arrow_cast(ts::timestamp::bigint / 1000000, 'Timestamp(Millisecond, None)') as millis,
  arrow_cast(ts::timestamp::bigint / 1000000000, 'Timestamp(Second, None)') as secs,
  names
FROM
  test_timestamps_table_source;

# create a table of timestamps with time zone
statement ok
CREATE TABLE test_timestamps_tz_table as
SELECT
  arrow_cast(ts::timestamp::bigint, 'Timestamp(Nanosecond, Some("UTC"))') as nanos,
  arrow_cast(ts::timestamp::bigint / 1000, 'Timestamp(Microsecond, Some("UTC"))') as micros,
  arrow_cast(ts::timestamp::bigint / 1000000, 'Timestamp(Millisecond, Some("UTC"))') as millis,
  arrow_cast(ts::timestamp::bigint / 1000000000, 'Timestamp(Second, Some("UTC"))') as secs,
  names
FROM
  test_timestamps_table_source;


statement ok
CREATE TABLE hashjoin_datatype_table_t1_source(c1 INT, c2 BIGINT, c3 DECIMAL(5,2), c4 VARCHAR)
AS VALUES
(1,    86400000,  1.23,    'abc'),
(2,    172800000, 456.00,  'def'),
(null, 259200000, 789.000, 'ghi'),
(3,    null,      -123.12, 'jkl')
;

statement ok
CREATE TABLE hashjoin_datatype_table_t1
AS SELECT
  arrow_cast(c1, 'Date32') as c1,
  arrow_cast(c2, 'Date64') as c2,
  c3,
  arrow_cast(c4, 'Dictionary(Int32, Utf8)') as c4
FROM
  hashjoin_datatype_table_t1_source

statement ok
CREATE TABLE hashjoin_datatype_table_t2_source(c1 INT, c2 BIGINT, c3 DECIMAL(10,2), c4 VARCHAR)
AS VALUES
(1,    86400000,  -123.12,   'abc'),
(null, null,      100000.00, 'abcdefg'),
(null, 259200000, 0.00,      'qwerty'),
(3,   null,       789.000,   'qwe')
;

statement ok
CREATE TABLE hashjoin_datatype_table_t2
AS SELECT
  arrow_cast(c1, 'Date32') as c1,
  arrow_cast(c2, 'Date64') as c2,
  c3,
  arrow_cast(c4, 'Dictionary(Int32, Utf8)') as c4
FROM
  hashjoin_datatype_table_t2_source



statement ok
set datafusion.execution.target_partitions = 2;

# make sure to a batch size smaller than row number of the table.
statement ok
set datafusion.execution.batch_size = 2;

##########
## Joins Tests
##########

# create table t1
statement ok
CREATE TABLE t1(a INT, b INT, c INT) AS VALUES
(1, 10, 50),
(2, 20, 60),
(3, 30, 70),
(4, 40, 80)

# create table t2
statement ok
CREATE TABLE t2(a INT, b INT, c INT) AS VALUES
(1, 100, 500),
(2, 200, 600),
(9, 300, 700),
(4, 400, 800)

# equijoin
query II nosort
SELECT t1.a, t2.b FROM t1 INNER JOIN t2 ON t1.a = t2.a ORDER BY t1.a
----
1 100
2 200
4 400

query II nosort
SELECT t1.a, t2.b FROM t1 INNER JOIN t2 ON t2.a = t1.a ORDER BY t1.a
----
1 100
2 200
4 400

# inner_join_nulls
query ??
SELECT * FROM (SELECT null AS id1) t1
INNER JOIN (SELECT null AS id2) t2 ON id1 = id2
----

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2


# create table a
statement ok
CREATE TABLE a(a INT, b INT, c INT) AS VALUES
(1, 10, 50),
(2, 20, 60),
(3, 30, 70),
(4, 40, 80)

# create table b
statement ok
CREATE TABLE b(a INT, b INT, c INT) AS VALUES
(1, 100, 500),
(2, 200, 600),
(9, 300, 700),
(4, 400, 800)

# issue_3002
#    // repro case for https://github.com/apache/datafusion/issues/3002

query II
select a.a, b.b from a join b on a.a = b.b
----

statement ok
DROP TABLE a

statement ok
DROP TABLE b

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR) AS VALUES
(11, 'a'),
(22, 'b'),
(33, 'c'),
(44, 'd'),
(77, 'e')

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR) AS VALUES
(11, 'z'),
(22, 'y'),
(44, 'x'),
(55, 'w')

# left_join_unbalanced
#     // the t1_id is larger than t2_id so the join_selection optimizer should kick in
query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id ORDER BY t1_id
----
11 a z
22 b y
33 c NULL
44 d x
77 e NULL

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 LEFT JOIN t2 ON t2_id = t1_id ORDER BY t1_id
----
11 a z
22 b y
33 c NULL
44 d x
77 e NULL


# cross_join_unbalanced
query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z
77 e w
77 e x
77 e y
77 e z

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR) AS VALUES
(11, 'a'),
(22, 'b'),
(33, 'c'),
(44, 'd'),
(77, 'e'),
(88, NULL),
(99, NULL)

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR) AS VALUES
(11, 'z'),
(22, NULL),
(44, 'x'),
(55, 'w'),
(99, 'u')

# left_join_null_filter
#    // Since t2 is the non-preserved side of the join, we cannot push down a NULL filter.
#   // Note that this is only true because IS NULL does not remove nulls. For filters that
#   // remove nulls, we can rewrite the join as an inner join and then push down the filter.
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_name IS NULL ORDER BY t1_id
----
22 22 NULL
33 NULL NULL
77 NULL NULL
88 NULL NULL

# left_join_null_filter_on_join_column
#    // Again, since t2 is the non-preserved side of the join, we cannot push down a NULL filter.
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_id IS NULL ORDER BY t1_id
----
33 NULL NULL
77 NULL NULL
88 NULL NULL

# left_join_not_null_filter
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_name IS NOT NULL ORDER BY t1_id
----
11 11 z
44 44 x
99 99 u

# left_join_not_null_filter_on_join_column
query IIT nosort
SELECT t1_id, t2_id, t2_name FROM t1 LEFT JOIN t2 ON t1_id = t2_id WHERE t2_id IS NOT NULL ORDER BY t1_id
----
11 11 z
22 22 NULL
44 44 x
99 99 u

# self_join_non_equijoin
query II nosort
SELECT x.t1_id, y.t1_id FROM t1 x JOIN t1 y ON x.t1_id = 11 AND y.t1_id = 44
----
11 44

# right_join_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_name IS NULL ORDER BY t2_id
----
NULL NULL 55
99 NULL 99

# right_join_null_filter_on_join_column
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_id IS NULL ORDER BY t2_id
----
NULL NULL 55

# right_join_not_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_name IS NOT NULL ORDER BY t2_id
----
11 a 11
22 b 22
44 d 44

# right_join_not_null_filter_on_join_column
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 RIGHT JOIN t2 ON t1_id = t2_id WHERE t1_id IS NOT NULL ORDER BY t2_id
----
11 a 11
22 b 22
44 d 44
99 NULL 99

# full_join_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 FULL OUTER JOIN t2 ON t1_id = t2_id WHERE t1_name IS NULL ORDER BY t1_id
----
88 NULL NULL
99 NULL 99
NULL NULL 55

# full_join_not_null_filter
query ITI nosort
SELECT t1_id, t1_name, t2_id FROM t1 FULL OUTER JOIN t2 ON t1_id = t2_id WHERE t1_name IS NOT NULL ORDER BY t1_id
----
11 a 11
22 b 22
33 c NULL
44 d 44
77 e NULL

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(id INT, t1_name VARCHAR, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4)

# create table t2
statement ok
CREATE TABLE t2(id INT, t2_name VARCHAR, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3)

# left_join_using

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = true

query ITT nosort
SELECT id, t1_name, t2_name FROM t1 LEFT JOIN t2 USING (id) ORDER BY id
----
11 a z
22 b y
33 c NULL
44 d x

# set repartition_joins to false
statement ok
set datafusion.optimizer.repartition_joins = false

query ITT nosort
SELECT id, t1_name, t2_name FROM t1 LEFT JOIN t2 USING (id) ORDER BY id
----
11 a z
22 b y
33 c NULL
44 d x

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# create table t1
statement ok
CREATE TABLE t1(t1_id INT, t1_name VARCHAR, t1_int INT) AS VALUES
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4)

# create table t2
statement ok
CREATE TABLE t2(t2_id INT, t2_name VARCHAR, t2_int INT) AS VALUES
(11, 'z', 3),
(22, 'y', 1),
(44, 'x', 3),
(55, 'w', 3)

# cross_join

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = true

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 WHERE 1=1 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITITI rowsort
SELECT * FROM (SELECT t1_id, t1_name FROM t1 UNION ALL SELECT t1_id, t1_name FROM t1) AS t1 CROSS JOIN t2
----
11 a 11 z 3
11 a 11 z 3
11 a 22 y 1
11 a 22 y 1
11 a 44 x 3
11 a 44 x 3
11 a 55 w 3
11 a 55 w 3
22 b 11 z 3
22 b 11 z 3
22 b 22 y 1
22 b 22 y 1
22 b 44 x 3
22 b 44 x 3
22 b 55 w 3
22 b 55 w 3
33 c 11 z 3
33 c 11 z 3
33 c 22 y 1
33 c 22 y 1
33 c 44 x 3
33 c 44 x 3
33 c 55 w 3
33 c 55 w 3
44 d 11 z 3
44 d 11 z 3
44 d 22 y 1
44 d 22 y 1
44 d 44 x 3
44 d 44 x 3
44 d 55 w 3
44 d 55 w 3

query ITT rowsort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN (SELECT t2_name FROM t2 UNION ALL SELECT t2_name FROM t2) AS t2_data
----
11 a w
11 a w
11 a x
11 a x
11 a y
11 a y
11 a z
11 a z
22 b w
22 b w
22 b x
22 b x
22 b y
22 b y
22 b z
22 b z
33 c w
33 c w
33 c x
33 c x
33 c y
33 c y
33 c z
33 c z
44 d w
44 d w
44 d x
44 d x
44 d y
44 d y
44 d z
44 d z

# set repartition_joins to true
statement ok
set datafusion.optimizer.repartition_joins = false

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1, t2 WHERE 1=1 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITT nosort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN t2 ORDER BY t1_id, t1_name, t2_name
----
11 a w
11 a x
11 a y
11 a z
22 b w
22 b x
22 b y
22 b z
33 c w
33 c x
33 c y
33 c z
44 d w
44 d x
44 d y
44 d z

query ITITI rowsort
SELECT * FROM (SELECT t1_id, t1_name FROM t1 UNION ALL SELECT t1_id, t1_name FROM t1) AS t1 CROSS JOIN t2
----
11 a 11 z 3
11 a 11 z 3
11 a 22 y 1
11 a 22 y 1
11 a 44 x 3
11 a 44 x 3
11 a 55 w 3
11 a 55 w 3
22 b 11 z 3
22 b 11 z 3
22 b 22 y 1
22 b 22 y 1
22 b 44 x 3
22 b 44 x 3
22 b 55 w 3
22 b 55 w 3
33 c 11 z 3
33 c 11 z 3
33 c 22 y 1
33 c 22 y 1
33 c 44 x 3
33 c 44 x 3
33 c 55 w 3
33 c 55 w 3
44 d 11 z 3
44 d 11 z 3
44 d 22 y 1
44 d 22 y 1
44 d 44 x 3
44 d 44 x 3
44 d 55 w 3
44 d 55 w 3

query ITT rowsort
SELECT t1_id, t1_name, t2_name FROM t1 CROSS JOIN (SELECT t2_name FROM t2 UNION ALL SELECT t2_name FROM t2) AS t2_data
----
11 a w
11 a w
11 a x
11 a x
11 a y
11 a y
11 a z
11 a z
22 b w
22 b w
22 b x
22 b x
22 b y
22 b y
22 b z
22 b z
33 c w
33 c w
33 c x
33 c x
33 c y
33 c y
33 c z
33 c z
44 d w
44 d w
44 d x
44 d x
44 d y
44 d y
44 d z
44 d z

statement ok
DROP TABLE t1

statement ok
DROP TABLE t2

# Join timestamp

statement ok
CREATE TABLE timestamp(time TIMESTAMP) AS VALUES
    (131964190213133),
    (131964190213134),
    (131964190213135);

query PP
SELECT *
FROM timestamp as a
JOIN (SELECT * FROM timestamp) as b
ON a.time = b.time
ORDER BY a.time
----
1970-01-02T12:39:24.190213133 1970-01-02T12:39:24.190213133
1970-01-02T12:39:24.190213134 1970-01-02T12:39:24.190213134
1970-01-02T12:39:24.190213135 1970-01-02T12:39:24.190213135

statement ok
DROP TABLE timestamp;

# Join float32

statement ok
CREATE TABLE population(city VARCHAR, population FLOAT) AS VALUES
    ('a', 838.698),
    ('b', 1778.934),
    ('c', 626.443);

query TRTR
SELECT *
FROM population as a
JOIN (SELECT * FROM population) as b
ON a.population = b.population
ORDER BY a.population
----
c 626.443 c 626.443
a 838.698 a 838.698
b 1778.934 b 1778.934

statement ok
DROP TABLE population;

# Join float64

statement ok
CREATE TABLE population(city VARCHAR, population DOUBLE) AS VALUES
    ('a', 838.698),
    ('b', 1778.934),
    ('c', 626.443);

query TRTR
SELECT *
FROM population as a
JOIN (SELECT * FROM population) as b
ON a.population = b.population
ORDER BY a.population
----
c 626.443 c 626.443
a 838.698 a 838.698
b 1778.934 b 1778.934

statement ok
DROP TABLE population;

# Inner join qualified names

statement ok
CREATE TABLE t1 (a INT, b INT, c INT) AS VALUES
    (1, 10, 50),
    (2, 20, 60),
    (3, 30, 70),
    (4, 40, 80);

statement ok
CREATE TABLE t2 (a INT, b INT, c INT) AS VALUES
    (1, 100, 500),
    (2, 200, 600),
    (9, 300, 700),
    (4, 400, 800);

query IIIIII
SELECT t1.a, t1.b, t1.c, t2.a, t2.b, t2.c
FROM t1
INNER JOIN t2 ON t1.a = t2.a
ORDER BY t1.a
----
1 10 50 1 100 500
2 20 60 2 200 600
4 40 80 4 400 800

query IIIIII
SELECT t1.a, t1.b, t1.c, t2.a, t2.b, t2.c
FROM t1
INNER JOIN t2 ON t2.a = t1.a
ORDER BY t1.a
----
1 10 50 1 100 500
2 20 60 2 200 600
4 40 80 4 400 800

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

# TODO: nestedjoin_with_alias

# Nested join without alias

query IIII
select * from (select 1 as a, 2 as b) c INNER JOIN (select 1 as a, 3 as d) e on c.a = e.a
----
1 2 1 3

# Join tables with duplicated column name not in on constraint

statement ok
CREATE TABLE countries (id INT, country VARCHAR) AS VALUES
    (1, 'Germany'),
    (2, 'Sweden'),
    (3, 'Japan');

statement ok
CREATE TABLE cities (id INT, country_id INT, city VARCHAR) AS VALUES
    (1, 1, 'Hamburg'),
    (2, 2, 'Stockholm'),
    (3, 3, 'Osaka'),
    (4, 1, 'Berlin'),
    (5, 2, 'Göteborg'),
    (6, 3, 'Tokyo'),
    (7, 3, 'Kyoto');

query IITT
SELECT t1.id, t2.id, t1.city, t2.country FROM cities AS t1 JOIN countries AS t2 ON t1.country_id = t2.id ORDER BY t1.id
----
1 1 Hamburg Germany
2 2 Stockholm Sweden
3 3 Osaka Japan
4 1 Berlin Germany
5 2 Göteborg Sweden
6 3 Tokyo Japan
7 3 Kyoto Japan

statement ok
DROP TABLE countries;

statement ok
DROP TABLE cities;

# TODO: join_timestamp

# Left join and right join should not panic with empty side

statement ok
CREATE TABLE t1 (t1_id BIGINT, ti_value VARCHAR NOT NULL) AS VALUES
    (5247, 'a'),
    (3821, 'b'),
    (6321, 'c'),
    (8821, 'd'),
    (7748, 'e');

statement ok
CREATE TABLE t2 (t2_id BIGINT, t2_value BOOLEAN) AS VALUES
    (358, true),
    (2820, false),
    (3804, NULL),
    (7748, NULL);

query ITIB rowsort
SELECT * FROM t1 LEFT JOIN t2 ON t1_id = t2_id
----
3821 b NULL NULL
5247 a NULL NULL
6321 c NULL NULL
7748 e 7748 NULL
8821 d NULL NULL

query IBIT rowsort
SELECT * FROM t2 RIGHT JOIN t1 ON t1_id = t2_id
----
7748 NULL 7748 e
NULL NULL 3821 b
NULL NULL 5247 a
NULL NULL 6321 c
NULL NULL 8821 d

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

# TODO: left_join_using_2

# TODO: left_join_using_join_key_projection

# TODO: left_join_2

# TODO: join_partitioned

# TODO: hash_join_with_date32

# TODO: hash_join_with_date64

# TODO: hash_join_with_decimal

# TODO: hash_join_with_dictionary


###
# Configuration setup
###

statement ok
set datafusion.optimizer.repartition_joins = false;

# Reduce left join 1 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
LEFT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_id < 100
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id
02)--Filter: join_t1.t1_id < UInt32(100)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--Filter: join_t2.t2_id < UInt32(100)
05)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce left join 2 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
LEFT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_int < 10 or (join_t1.t1_int > 2 and join_t2.t2_name != 'w')
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id Filter: join_t2.t2_int < UInt32(10) OR join_t1.t1_int > UInt32(2) AND join_t2.t2_name != Utf8View("w")
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--Filter: join_t2.t2_int < UInt32(10) OR join_t2.t2_name != Utf8View("w")
04)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce left join 3 (to inner join)

query TT
EXPLAIN
SELECT *
FROM (
    SELECT join_t1.*
    FROM join_t1
    LEFT JOIN join_t2 ON join_t1.t1_id = join_t2.t2_id
    WHERE join_t2.t2_int < 3
) t3
LEFT JOIN join_t2 on t3.t1_int = join_t2.t2_int
WHERE t3.t1_id < 100
----
logical_plan
01)Left Join: t3.t1_int = join_t2.t2_int
02)--SubqueryAlias: t3
03)----Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
04)------Inner Join: join_t1.t1_id = join_t2.t2_id
05)--------Filter: join_t1.t1_id < UInt32(100)
06)----------TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
07)--------Projection: join_t2.t2_id
08)----------Filter: join_t2.t2_int < UInt32(3) AND join_t2.t2_id < UInt32(100)
09)------------TableScan: join_t2 projection=[t2_id, t2_int]
10)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce right join 1 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
RIGHT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_int IS NOT NULL
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id
02)--Filter: join_t1.t1_int IS NOT NULL
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce right join 2 (to inner join)

query TT
EXPLAIN
SELECT *
FROM join_t1
RIGHT JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE NOT (join_t1.t1_int = join_t2.t2_int)
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id Filter: join_t2.t2_int != join_t1.t1_int
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to right join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t2.t2_name IS NOT NULL
----
logical_plan
01)Right Join: join_t1.t1_id = join_t2.t2_id
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--Filter: join_t2.t2_name IS NOT NULL
04)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to left join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 ON join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_name != 'b'
----
logical_plan
01)Left Join: join_t1.t1_id = join_t2.t2_id
02)--Filter: join_t1.t1_name != Utf8View("b")
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce full join to inner join

query TT
EXPLAIN
SELECT *
FROM join_t1
FULL JOIN join_t2 on join_t1.t1_id = join_t2.t2_id
WHERE join_t1.t1_name != 'b' and join_t2.t2_name = 'x'
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id
02)--Filter: join_t1.t1_name != Utf8View("b")
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--Filter: join_t2.t2_name = Utf8View("x")
05)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

###
# Configuration teardown
###

statement ok
set datafusion.optimizer.repartition_joins = true;


# Sort merge equijoin

query ITT
SELECT t1_id, t1_name, t2_name
FROM join_t1
JOIN join_t2 ON t1_id = t2_id
ORDER BY t1_id
----
11 a z
22 b y
44 d x

query ITT
SELECT t1_id, t1_name, t2_name
FROM join_t1
JOIN join_t2 ON t2_id = t1_id
ORDER BY t1_id
----
11 a z
22 b y
44 d x

# TODO: sort_merge_join_on_date32

# TODO: sort_merge_join_on_decimal


# TODO: Left semi join

# Left semi join pushdown

query TT
EXPLAIN
SELECT lsaj_t1.t1_id, lsaj_t1.t1_name
FROM lsaj_t1
LEFT SEMI JOIN lsaj_t2 ON (lsaj_t1.t1_id = lsaj_t2.t2_id and lsaj_t2.t2_int > 1)
----
logical_plan
01)LeftSemi Join: lsaj_t1.t1_id = lsaj_t2.t2_id
02)--TableScan: lsaj_t1 projection=[t1_id, t1_name]
03)--Projection: lsaj_t2.t2_id
04)----Filter: lsaj_t2.t2_int > UInt32(1)
05)------TableScan: lsaj_t2 projection=[t2_id, t2_int]

# Left anti join

statement ok
set datafusion.optimizer.repartition_joins = false;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

query I
SELECT t1_id
FROM lsaj_t1
EXCEPT SELECT t2_id FROM lsaj_t2
ORDER BY t1_id
----
33

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
LEFT ANTI JOIN lsaj_t2 ON (t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

statement ok
set datafusion.optimizer.repartition_joins = true;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

query I
SELECT t1_id
FROM lsaj_t1
EXCEPT SELECT t2_id FROM lsaj_t2
ORDER BY t1_id
----
33

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
LEFT ANTI JOIN lsaj_t2 ON (t1_id = t2_id)
ORDER BY t1_id
----
33 c
NULL e

# Error left anti join
# https://github.com/apache/datafusion/issues/4366

statement ok
set datafusion.optimizer.repartition_joins = false;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id and t1_id > 11)
ORDER BY t1_id
----
11 a
11 a
33 c
NULL e

statement ok
set datafusion.optimizer.repartition_joins = true;

query IT
SELECT t1_id, t1_name
FROM lsaj_t1
WHERE NOT EXISTS (SELECT 1 FROM lsaj_t2 WHERE t1_id = t2_id and t1_id > 11)
ORDER BY t1_id
----
11 a
11 a
33 c
NULL e

# TODO: null_aware_left_anti_join

# TODO: right_semi_join

# Join and aggregate on same key

statement ok
set datafusion.explain.logical_plan_only = false;

query TT
EXPLAIN
select distinct(join_t1.t1_id)
from join_t1
inner join join_t2 on join_t1.t1_id = join_t2.t2_id
----
logical_plan
01)Aggregate: groupBy=[[join_t1.t1_id]], aggr=[[]]
02)--Projection: join_t1.t1_id
03)----Inner Join: join_t1.t1_id = join_t2.t2_id
04)------TableScan: join_t1 projection=[t1_id]
05)------TableScan: join_t2 projection=[t2_id]
physical_plan
01)AggregateExec: mode=FinalPartitioned, gby=[t1_id@0 as t1_id], aggr=[]
02)--CoalesceBatchesExec: target_batch_size=2
03)----RepartitionExec: partitioning=Hash([t1_id@0], 2), input_partitions=2
04)------AggregateExec: mode=Partial, gby=[t1_id@0 as t1_id], aggr=[]
05)--------CoalesceBatchesExec: target_batch_size=2
06)----------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_id@0, t2_id@0)], projection=[t1_id@0]
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
09)--------------DataSourceExec: partitions=1, partition_sizes=[1]

# Join on struct
query TT
explain select join_t3.s3, join_t4.s4
from join_t3
inner join join_t4 on join_t3.s3 = join_t4.s4
----
logical_plan
01)Inner Join: join_t3.s3 = join_t4.s4
02)--TableScan: join_t3 projection=[s3]
03)--TableScan: join_t4 projection=[s4]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(s3@0, s4@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[1]
04)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
05)------DataSourceExec: partitions=1, partition_sizes=[1]

query ??
select join_t3.s3, join_t4.s4
from join_t3
inner join join_t4 on join_t3.s3 = join_t4.s4
----
{id: 2} {id: 2}

# join with struct key and nulls
# Note that intersect or except applies `null_equality` as `NullEquality::NullEqualsNull` for Join.
query ?
SELECT * FROM join_t3
EXCEPT
SELECT * FROM join_t4
----
{id: 1}

query TT
EXPLAIN
select count(*)
from (select * from join_t1 inner join join_t2 on join_t1.t1_id = join_t2.t2_id)
group by t1_id
----
logical_plan
01)Projection: count(Int64(1)) AS count(*)
02)--Aggregate: groupBy=[[join_t1.t1_id]], aggr=[[count(Int64(1))]]
03)----Projection: join_t1.t1_id
04)------Inner Join: join_t1.t1_id = join_t2.t2_id
05)--------TableScan: join_t1 projection=[t1_id]
06)--------TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[count(Int64(1))@1 as count(*)]
02)--AggregateExec: mode=FinalPartitioned, gby=[t1_id@0 as t1_id], aggr=[count(Int64(1))]
03)----CoalesceBatchesExec: target_batch_size=2
04)------RepartitionExec: partitioning=Hash([t1_id@0], 2), input_partitions=2
05)--------AggregateExec: mode=Partial, gby=[t1_id@0 as t1_id], aggr=[count(Int64(1))]
06)----------CoalesceBatchesExec: target_batch_size=2
07)------------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_id@0, t2_id@0)], projection=[t1_id@0]
08)--------------DataSourceExec: partitions=1, partition_sizes=[1]
09)--------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
10)----------------DataSourceExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN
select count(distinct join_t1.t1_id)
from join_t1
inner join join_t2 on join_t1.t1_id = join_t2.t2_id
----
logical_plan
01)Projection: count(alias1) AS count(DISTINCT join_t1.t1_id)
02)--Aggregate: groupBy=[[]], aggr=[[count(alias1)]]
03)----Aggregate: groupBy=[[join_t1.t1_id AS alias1]], aggr=[[]]
04)------Projection: join_t1.t1_id
05)--------Inner Join: join_t1.t1_id = join_t2.t2_id
06)----------TableScan: join_t1 projection=[t1_id]
07)----------TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[count(alias1)@0 as count(DISTINCT join_t1.t1_id)]
02)--AggregateExec: mode=Final, gby=[], aggr=[count(alias1)]
03)----CoalescePartitionsExec
04)------AggregateExec: mode=Partial, gby=[], aggr=[count(alias1)]
05)--------AggregateExec: mode=FinalPartitioned, gby=[alias1@0 as alias1], aggr=[]
06)----------CoalesceBatchesExec: target_batch_size=2
07)------------RepartitionExec: partitioning=Hash([alias1@0], 2), input_partitions=2
08)--------------AggregateExec: mode=Partial, gby=[t1_id@0 as alias1], aggr=[]
09)----------------CoalesceBatchesExec: target_batch_size=2
10)------------------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_id@0, t2_id@0)], projection=[t1_id@0]
11)--------------------DataSourceExec: partitions=1, partition_sizes=[1]
12)--------------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
13)----------------------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.explain.logical_plan_only = true;

# Reduce cross join with expr join key all (to inner join)

query TT
EXPLAIN
select *
from join_t1
cross join join_t2
where join_t1.t1_id + 12 = join_t2.t2_id + 1
----
logical_plan
01)Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = CAST(join_t2.t2_id AS Int64) + Int64(1)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

# Reduce cross join with cast expr join key (to inner join)

query TT
EXPLAIN
select join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
from join_t1
cross join join_t2 where join_t1.t1_id + 11 = cast(join_t2.t2_id as BIGINT)
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]


#####
# Config setup
#####

statement ok
set datafusion.explain.logical_plan_only = false;

# Reduce cross join with wildcard and expr (to inner join)

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
select *, join_t1.t1_id + 11
from join_t1, join_t2
where join_t1.t1_id + 11 = join_t2.t2_id
----
logical_plan
01)Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int, join_t2.t2_id, join_t2.t2_name, join_t2.t2_int, CAST(join_t1.t1_id AS Int64) + Int64(11)
02)--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
01)ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@3 as t2_id, t2_name@4 as t2_name, t2_int@5 as t2_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t1.t1_id + Int64(11)@3, CAST(join_t2.t2_id AS Int64)@3)], projection=[t1_id@0, t1_name@1, t1_int@2, t2_id@4, t2_name@5, t2_int@6]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, CAST(t2_id@0 AS Int64) as CAST(join_t2.t2_id AS Int64)]
09)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
10)----------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
select *, join_t1.t1_id + 11
from join_t1, join_t2
where join_t1.t1_id + 11 = join_t2.t2_id
----
logical_plan
01)Projection: join_t1.t1_id, join_t1.t1_name, join_t1.t1_int, join_t2.t2_id, join_t2.t2_name, join_t2.t2_int, CAST(join_t1.t1_id AS Int64) + Int64(11)
02)--Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)----TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
01)ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, t2_id@3 as t2_id, t2_name@4 as t2_name, t2_int@5 as t2_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t1.t1_id + Int64(11)@3, CAST(join_t2.t2_id AS Int64)@3)], projection=[t1_id@0, t1_name@1, t1_int@2, t2_id@4, t2_name@5, t2_int@6]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_int@2 as t1_int, CAST(t1_id@0 AS Int64) + 11 as join_t1.t1_id + Int64(11)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, CAST(t2_id@0 AS Int64) as CAST(join_t2.t2_id AS Int64)]
09)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
10)----------DataSourceExec: partitions=1, partition_sizes=[1]

# Both side expr key inner join

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id + cast(12 as INT UNSIGNED) = join_t2.t2_id + cast(1 as INT UNSIGNED)
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id + UInt32(12) = join_t2.t2_id + UInt32(1)
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t2.t2_id + UInt32(1)@1, join_t1.t1_id + UInt32(12)@2)], projection=[t2_id@0, t1_id@2, t1_name@3]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t2_id@0 as t2_id, t2_id@0 + 1 as join_t2.t2_id + UInt32(1)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_id@0 + 12 as join_t1.t1_id + UInt32(12)]
09)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
10)----------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id + cast(12 as INT UNSIGNED) = join_t2.t2_id + cast(1 as INT UNSIGNED)
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id + UInt32(12) = join_t2.t2_id + UInt32(1)
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t2.t2_id + UInt32(1)@1, join_t1.t1_id + UInt32(12)@2)], projection=[t2_id@0, t1_id@2, t1_name@3]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t2_id@0 as t2_id, t2_id@0 + 1 as join_t2.t2_id + UInt32(1)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_id@0 + 12 as join_t1.t1_id + UInt32(12)]
09)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
10)----------DataSourceExec: partitions=1, partition_sizes=[1]

# Left side expr key inner join

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id + cast(11 as INT UNSIGNED)  = join_t2.t2_id
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id + UInt32(11) = join_t2.t2_id
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t2_id@0, join_t1.t1_id + UInt32(11)@2)], projection=[t2_id@0, t1_id@1, t1_name@2]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_id@0 + 11 as join_t1.t1_id + UInt32(11)]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id + cast(11 as INT UNSIGNED)  = join_t2.t2_id
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id + UInt32(11) = join_t2.t2_id
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t2_id@0, join_t1.t1_id + UInt32(11)@2)], projection=[t2_id@0, t1_id@1, t1_name@2]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------ProjectionExec: expr=[t1_id@0 as t1_id, t1_name@1 as t1_name, t1_id@0 + 11 as join_t1.t1_id + UInt32(11)]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

# Right side expr key inner join

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id = join_t2.t2_id - cast(11 as INT UNSIGNED)
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id = join_t2.t2_id - UInt32(11)
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t2.t2_id - UInt32(11)@1, t1_id@0)], projection=[t2_id@0, t1_id@2, t1_name@3]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t2_id@0 as t2_id, t2_id@0 - 11 as join_t2.t2_id - UInt32(11)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
09)--------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id = join_t2.t2_id - cast(11 as INT UNSIGNED)
----
logical_plan
01)Projection: join_t1.t1_id, join_t2.t2_id, join_t1.t1_name
02)--Inner Join: join_t1.t1_id = join_t2.t2_id - UInt32(11)
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)----TableScan: join_t2 projection=[t2_id]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id, t1_name@2 as t1_name]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(join_t2.t2_id - UInt32(11)@1, t1_id@0)], projection=[t2_id@0, t1_id@2, t1_name@3]
04)------CoalescePartitionsExec
05)--------ProjectionExec: expr=[t2_id@0 as t2_id, t2_id@0 - 11 as join_t2.t2_id - UInt32(11)]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------DataSourceExec: partitions=1, partition_sizes=[1]
08)------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
09)--------DataSourceExec: partitions=1, partition_sizes=[1]

# Select wildcard with expr key inner join

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT *
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id = join_t2.t2_id - cast(11 as INT UNSIGNED)
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id - UInt32(11)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_id@0, join_t2.t2_id - UInt32(11)@3)], projection=[t1_id@0, t1_name@1, t1_int@2, t2_id@3, t2_name@4, t2_int@5]
03)----DataSourceExec: partitions=1, partition_sizes=[1]
04)----ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, t2_id@0 - 11 as join_t2.t2_id - UInt32(11)]
05)------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
06)--------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT *
FROM join_t1
INNER JOIN join_t2
ON join_t1.t1_id = join_t2.t2_id - cast(11 as INT UNSIGNED)
----
logical_plan
01)Inner Join: join_t1.t1_id = join_t2.t2_id - UInt32(11)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--TableScan: join_t2 projection=[t2_id, t2_name, t2_int]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(t1_id@0, join_t2.t2_id - UInt32(11)@3)], projection=[t1_id@0, t1_name@1, t1_int@2, t2_id@3, t2_name@4, t2_int@5]
03)----DataSourceExec: partitions=1, partition_sizes=[1]
04)----ProjectionExec: expr=[t2_id@0 as t2_id, t2_name@1 as t2_name, t2_int@2 as t2_int, t2_id@0 - 11 as join_t2.t2_id - UInt32(11)]
05)------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
06)--------DataSourceExec: partitions=1, partition_sizes=[1]

#####
# Config teardown
#####

statement ok
set datafusion.explain.logical_plan_only = true;


# Join with type coercion for equi expr

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t2.t2_id
from join_t1
inner join join_t2 on join_t1.t1_id + 11 = join_t2.t2_id
----
logical_plan
01)Inner Join: CAST(join_t1.t1_id AS Int64) + Int64(11) = CAST(join_t2.t2_id AS Int64)
02)--TableScan: join_t1 projection=[t1_id, t1_name]
03)--TableScan: join_t2 projection=[t2_id]

# Join only with filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t2.t2_id
from join_t1
inner join join_t2 on join_t1.t1_id * 4 < join_t2.t2_id
----
logical_plan
01)Inner Join:  Filter: CAST(join_t1.t1_id AS Int64) * Int64(4) < CAST(join_t2.t2_id AS Int64)
02)--TableScan: join_t1 projection=[t1_id, t1_name]
03)--TableScan: join_t2 projection=[t2_id]

# Type coercion join with filter and equi expr

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t2.t2_id
from join_t1
inner join join_t2
on join_t1.t1_id * 5 = join_t2.t2_id and join_t1.t1_id * 4 < join_t2.t2_id
----
logical_plan
01)Inner Join: CAST(join_t1.t1_id AS Int64) * Int64(5) = CAST(join_t2.t2_id AS Int64) Filter: CAST(join_t1.t1_id AS Int64) * Int64(4) < CAST(join_t2.t2_id AS Int64)
02)--TableScan: join_t1 projection=[t1_id, t1_name]
03)--TableScan: join_t2 projection=[t2_id]

# Test cross join to groupby with different key ordering

statement ok
CREATE TABLE tbl(col1 VARCHAR, col2 BIGINT UNSIGNED, col3 BIGINT UNSIGNED)
AS VALUES
('A', 1, 1),
('A', 1, 1),
('A', 2, 1),
('A', 2, 1),
('A', 3, 1),
('A', 3, 1),
('A', 4, 1),
('A', 4, 1),
('BB', 5, 1),
('BB', 5, 1),
('BB', 6, 1),
('BB', 6, 1);

query TIR
select col1, col2, coalesce(sum_col3, 0) as sum_col3
from (select distinct col2 from tbl) AS q1
cross join (select distinct col1 from tbl) AS q2
left outer join (SELECT col1, col2, sum(col3) as sum_col3 FROM tbl GROUP BY col1, col2) AS q3
USING(col2, col1)
ORDER BY col1, col2
----
A 1 2
A 2 2
A 3 2
A 4 2
A 5 0
A 6 0
BB 1 0
BB 2 0
BB 3 0
BB 4 0
BB 5 2
BB 6 2

statement ok
DROP TABLE tbl;

# Subquery to join with both side expr

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in (select join_t2.t2_id + 1 from join_t2)
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1)
05)------TableScan: join_t2 projection=[t2_id]

query ITI rowsort
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in (select join_t2.t2_id + 1 from join_t2)
----
11 a 1
33 c 3
44 d 4

# Subquery to join with multi filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int and join_t2.t2_int > 0
    )
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1) Filter: join_t1.t1_int <= __correlated_sq_1.t2_int
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1), join_t2.t2_int
05)------Filter: join_t2.t2_int > UInt32(0)
06)--------TableScan: join_t2 projection=[t2_id, t2_int]

query ITI rowsort
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int and join_t2.t2_int > 0
    )
----
11 a 1
33 c 3

# Three projection exprs subquery to join

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int
          and join_t1.t1_name != join_t2.t2_name
          and join_t2.t2_int > 0
    )
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1) Filter: join_t1.t1_int <= __correlated_sq_1.t2_int AND join_t1.t1_name != __correlated_sq_1.t2_name
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1), join_t2.t2_int, join_t2.t2_name
05)------Filter: join_t2.t2_int > UInt32(0)
06)--------TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

query ITI rowsort
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int
          and join_t1.t1_name != join_t2.t2_name
          and join_t2.t2_int > 0
    )
----
11 a 1
33 c 3

# In subquery to join with correlated outer filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (select join_t2.t2_id + 1 from join_t2 where join_t1.t1_int > 0)
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1)
02)--Filter: join_t1.t1_int > UInt32(0)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--SubqueryAlias: __correlated_sq_1
05)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1)
06)------TableScan: join_t2 projection=[t2_id]

# Not in subquery to join with correlated outer filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 not in
    (select join_t2.t2_id + 1 from join_t2 where join_t1.t1_int > 0)
----
logical_plan
01)LeftAnti Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1) Filter: join_t1.t1_int > UInt32(0)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1)
05)------TableScan: join_t2 projection=[t2_id]

# In subquery to join with outer filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int
          and join_t1.t1_name != join_t2.t2_name
    )
  and join_t1.t1_id > 0
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1) Filter: join_t1.t1_int <= __correlated_sq_1.t2_int AND join_t1.t1_name != __correlated_sq_1.t2_name
02)--Filter: join_t1.t1_id > UInt32(0)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--SubqueryAlias: __correlated_sq_1
05)----Projection: CAST(join_t2.t2_id AS Int64) + Int64(1), join_t2.t2_int, join_t2.t2_name
06)------TableScan: join_t2 projection=[t2_id, t2_name, t2_int]

query ITI rowsort
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in
    (
        select join_t2.t2_id + 1
        from join_t2
        where join_t1.t1_int <= join_t2.t2_int
          and join_t1.t1_name != join_t2.t2_name
    )
  and join_t1.t1_id > 0
----
11 a 1
33 c 3

# Two in subquery to join with outer filter

query TT
EXPLAIN
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in (select join_t2.t2_id + 1 from join_t2)
  and join_t1.t1_int in (select join_t2.t2_int + 1 from join_t2)
  and join_t1.t1_id > 0
----
logical_plan
01)LeftSemi Join: CAST(join_t1.t1_int AS Int64) = __correlated_sq_2.join_t2.t2_int + Int64(1)
02)--LeftSemi Join: CAST(join_t1.t1_id AS Int64) + Int64(12) = __correlated_sq_1.join_t2.t2_id + Int64(1)
03)----Filter: join_t1.t1_id > UInt32(0)
04)------TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
05)----SubqueryAlias: __correlated_sq_1
06)------Projection: CAST(join_t2.t2_id AS Int64) + Int64(1)
07)--------TableScan: join_t2 projection=[t2_id]
08)--SubqueryAlias: __correlated_sq_2
09)----Projection: CAST(join_t2.t2_int AS Int64) + Int64(1)
10)------TableScan: join_t2 projection=[t2_int]

query ITI
select join_t1.t1_id, join_t1.t1_name, join_t1.t1_int
from join_t1
where join_t1.t1_id + 12 in (select join_t2.t2_id + 1 from join_t2)
  and join_t1.t1_int in (select join_t2.t2_int + 1 from join_t2)
  and join_t1.t1_id > 0
----
44 d 4


#####
# Configuration setup
#####

statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.execution.target_partitions = 4;

# Planning inner nested loop join
# inputs are swapped due to inexact statistics + join reordering caused additional projection

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id > join_t2.t2_id
WHERE join_t1.t1_id > 10 AND join_t2.t2_int > 1
----
logical_plan
01)Inner Join:  Filter: join_t1.t1_id > join_t2.t2_id
02)--Filter: join_t1.t1_id > UInt32(10)
03)----TableScan: join_t1 projection=[t1_id]
04)--Projection: join_t2.t2_id
05)----Filter: join_t2.t2_int > UInt32(1)
06)------TableScan: join_t2 projection=[t2_id, t2_int]
physical_plan
01)ProjectionExec: expr=[t1_id@1 as t1_id, t2_id@0 as t2_id]
02)--NestedLoopJoinExec: join_type=Inner, filter=t1_id@0 > t2_id@1
03)----CoalescePartitionsExec
04)------FilterExec: t2_int@1 > 1, projection=[t2_id@0]
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
06)----------DataSourceExec: partitions=1, partition_sizes=[1]
07)----FilterExec: t1_id@0 > 10
08)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
09)--------DataSourceExec: partitions=1, partition_sizes=[1]

query II
SELECT join_t1.t1_id, join_t2.t2_id
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id > join_t2.t2_id
WHERE join_t1.t1_id > 10 AND join_t2.t2_int > 1
ORDER BY 1
----
22 11
33 11
44 11

# Left as inner table nested loop join

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id
FROM (select t1_id from join_t1 where join_t1.t1_id > 22) as join_t1
RIGHT JOIN (select t2_id from join_t2 where join_t2.t2_id > 11) as join_t2
        ON join_t1.t1_id < join_t2.t2_id
----
logical_plan
01)Right Join:  Filter: join_t1.t1_id < join_t2.t2_id
02)--SubqueryAlias: join_t1
03)----Filter: join_t1.t1_id > UInt32(22)
04)------TableScan: join_t1 projection=[t1_id]
05)--SubqueryAlias: join_t2
06)----Filter: join_t2.t2_id > UInt32(11)
07)------TableScan: join_t2 projection=[t2_id]
physical_plan
01)NestedLoopJoinExec: join_type=Right, filter=t1_id@0 < t2_id@1
02)--CoalescePartitionsExec
03)----FilterExec: t1_id@0 > 22
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------DataSourceExec: partitions=1, partition_sizes=[1]
06)--FilterExec: t2_id@0 > 11
07)----RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
08)------DataSourceExec: partitions=1, partition_sizes=[1]

query II
SELECT join_t1.t1_id, join_t2.t2_id
FROM (select t1_id from join_t1 where join_t1.t1_id > 22) as join_t1
RIGHT JOIN (select t2_id from join_t2 where join_t2.t2_id > 11) as join_t2
        ON join_t1.t1_id < join_t2.t2_id
ORDER BY 1, 2        
----
33 44
33 55
44 55
NULL 22

#####
# Configuration teardown
#####

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.explain.logical_plan_only = true;


# Exists subquery to join expr filter

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftSemi Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----TableScan: join_t2 projection=[t2_id]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
ORDER BY 1
----
22 b 2
33 c 3
44 d 4

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
ORDER BY 1
----
22 b 2
33 c 3
44 d 4

# Exists subquery to join inner filter

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t2.t2_int < 3
)
----
logical_plan
01)LeftSemi Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: join_t2.t2_id
05)------Filter: join_t2.t2_int < UInt32(3)
06)--------TableScan: join_t2 projection=[t2_id, t2_int]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t2.t2_int < 3
)
----
44 d 4

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t2.t2_int < 3
)
----
44 d 4

# Exists subquery to join outer filter

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t1.t1_int < 3
)
----
logical_plan
01)LeftSemi Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--Filter: join_t1.t1_int < UInt32(3)
03)----TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
04)--SubqueryAlias: __correlated_sq_1
05)----TableScan: join_t2 projection=[t2_id]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t1.t1_int < 3
)
----
22 b 2

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2 AND join_t1.t1_int < 3
)
----
22 b 2

# Not exists subquery to join expr filter

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----TableScan: join_t2 projection=[t2_id]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT t2_id
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

# Exists distinct subquery to join

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT DISTINCT t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: join_t2.t2_id
05)------Aggregate: groupBy=[[join_t2.t2_int, join_t2.t2_id]], aggr=[[]]
06)--------Projection: join_t2.t2_int, join_t2.t2_id
07)----------TableScan: join_t2 projection=[t2_id, t2_int]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT DISTINCT t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS (
    SELECT DISTINCT t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

# Exists distinct subquery to join with expr

query TT
EXPLAIN
SELECT *
FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT t2_id + t2_int, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: join_t2.t2_id
05)------Aggregate: groupBy=[[join_t2.t2_id + join_t2.t2_int, join_t2.t2_int, join_t2.t2_id]], aggr=[[]]
06)--------Projection: join_t2.t2_id + join_t2.t2_int, join_t2.t2_int, join_t2.t2_id
07)----------TableScan: join_t2 projection=[t2_id, t2_int]

statement ok
set datafusion.optimizer.repartition_joins = false;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT t2_id + t2_int, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.optimizer.repartition_joins = true;

query ITI
SELECT *
FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT t2_id + t2_int, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

# Exists distinct subquery left anti join with literal

statement ok
set datafusion.optimizer.repartition_joins = false;

query TT
EXPLAIN
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: join_t2.t2_id
05)------Aggregate: groupBy=[[Int64(1), join_t2.t2_int, join_t2.t2_id]], aggr=[[]]
06)--------Projection: Int64(1), join_t2.t2_int, join_t2.t2_id
07)----------TableScan: join_t2 projection=[t2_id, t2_int]

query ITI
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.optimizer.repartition_joins = true;

query TT
EXPLAIN
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
logical_plan
01)LeftAnti Join:  Filter: CAST(join_t1.t1_id AS Int64) + Int64(1) > CAST(__correlated_sq_1.t2_id AS Int64) * Int64(2)
02)--TableScan: join_t1 projection=[t1_id, t1_name, t1_int]
03)--SubqueryAlias: __correlated_sq_1
04)----Projection: join_t2.t2_id
05)------Aggregate: groupBy=[[Int64(1), join_t2.t2_int, join_t2.t2_id]], aggr=[[]]
06)--------Projection: Int64(1), join_t2.t2_int, join_t2.t2_id
07)----------TableScan: join_t2 projection=[t2_id, t2_int]

query ITI
SELECT * FROM join_t1
WHERE NOT EXISTS(
    SELECT DISTINCT 1, t2_int
    FROM join_t2
    WHERE join_t1.t1_id + 1 > join_t2.t2_id * 2
)
----
11 a 1

statement ok
set datafusion.explain.logical_plan_only = false;

# show the contents of the timestamp table
query PPPPT
select * from
test_timestamps_table
----
2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0
2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1
NULL NULL NULL NULL Row 2
2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3

# show the contents of the timestamp with timezone table
query PPPPT
select * from
test_timestamps_tz_table
----
2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0
2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1
NULL NULL NULL NULL Row 2
2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3

# test timestamp join on nanos datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_table as t1 JOIN (SELECT * FROM test_timestamps_table ) as t2 ON t1.nanos = t2.nanos;
----
2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1
2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0 2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0
2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3

# test timestamp with timezone join on nanos datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_tz_table as t1 JOIN (SELECT * FROM test_timestamps_tz_table ) as t2 ON t1.nanos = t2.nanos;
----
2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1
2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0 2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0
2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3

# test timestamp join on micros datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_table as t1 JOIN (SELECT * FROM test_timestamps_table ) as t2 ON t1.micros = t2.micros
----
2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1
2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0 2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0
2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3

# test timestamp with timezone join on micros datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_tz_table as t1 JOIN (SELECT * FROM test_timestamps_tz_table ) as t2 ON t1.micros = t2.micros
----
2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1
2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0 2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0
2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3

# test timestamp join on millis datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_table as t1 JOIN (SELECT * FROM test_timestamps_table ) as t2 ON t1.millis = t2.millis
----
2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123450 2011-12-13T11:13:10.123 2011-12-13T11:13:10 Row 1
2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0 2018-11-13T17:11:10.011375885 2018-11-13T17:11:10.011375 2018-11-13T17:11:10.011 2018-11-13T17:11:10 Row 0
2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10.432 2021-01-01T05:11:10 Row 3

# test timestamp with timezone join on millis datatype
query PPPPTPPPPT rowsort
SELECT * FROM test_timestamps_tz_table as t1 JOIN (SELECT * FROM test_timestamps_tz_table ) as t2 ON t1.millis = t2.millis
----
2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123450Z 2011-12-13T11:13:10.123Z 2011-12-13T11:13:10Z Row 1
2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0 2018-11-13T17:11:10.011375885Z 2018-11-13T17:11:10.011375Z 2018-11-13T17:11:10.011Z 2018-11-13T17:11:10Z Row 0
2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10.432Z 2021-01-01T05:11:10Z Row 3

####
# Config setup
####

statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.optimizer.prefer_hash_join = true;

# explain hash join on timestamp with timezone type
query TT
EXPLAIN SELECT * FROM test_timestamps_tz_table as t1 JOIN test_timestamps_tz_table as t2 ON t1.millis = t2.millis
----
logical_plan
01)Inner Join: t1.millis = t2.millis
02)--SubqueryAlias: t1
03)----TableScan: test_timestamps_tz_table projection=[nanos, micros, millis, secs, names]
04)--SubqueryAlias: t2
05)----TableScan: test_timestamps_tz_table projection=[nanos, micros, millis, secs, names]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(millis@2, millis@2)]
03)----DataSourceExec: partitions=1, partition_sizes=[1]
04)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
05)------DataSourceExec: partitions=1, partition_sizes=[1]

# left_join_using_2
query II
SELECT t1.c1, t2.c2 FROM test_partition_table t1 JOIN test_partition_table t2 USING (c2) ORDER BY t2.c2;
----
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9
0 10

# left_join_using_qualified (snowflake syntax)
query error DataFusion error: This feature is not implemented: Invalid identifier in USING clause\. Expected single identifier, got t2\.c2
SELECT t1.c1, t2.c2 FROM test_partition_table t1 JOIN test_partition_table t2 USING (t2.c2) ORDER BY t2.c2;

# left_join_using_join_key_projection
query III
SELECT t1.c1, t1.c2, t2.c2 FROM test_partition_table t1 JOIN test_partition_table t2 USING (c2) ORDER BY t2.c2
----
0 1 1
0 2 2
0 3 3
0 4 4
0 5 5
0 6 6
0 7 7
0 8 8
0 9 9
0 10 10

# left_join_2
query III
SELECT t1.c1, t1.c2, t2.c2 FROM test_partition_table t1 JOIN test_partition_table t2 ON t1.c2 = t2.c2 ORDER BY t1.c2
----
0 1 1
0 2 2
0 3 3
0 4 4
0 5 5
0 6 6
0 7 7
0 8 8
0 9 9
0 10 10

####
# Config setup
####

statement ok
set datafusion.explain.logical_plan_only = true

# explain hash_join_with_date32
query TT
explain select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t2 t2 on t1.c1 = t2.c1
----
logical_plan
01)Inner Join: t1.c1 = t2.c1
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t2 projection=[c1, c2, c3, c4]

# hash_join_with_date32
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t2 t2 on t1.c1 = t2.c1
----
1970-01-02 1970-01-02T00:00:00 1.23 abc 1970-01-02 1970-01-02T00:00:00 -123.12 abc
1970-01-04 NULL -123.12 jkl 1970-01-04 NULL 789 qwe


# explain hash_join_with_date64
query TT
explain select * from hashjoin_datatype_table_t1 t1 left join hashjoin_datatype_table_t2 t2 on t1.c2 = t2.c2
----
logical_plan
01)Left Join: t1.c2 = t2.c2
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t2 projection=[c1, c2, c3, c4]

# hash_join_with_date64
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 left join hashjoin_datatype_table_t2 t2 on t1.c2 = t2.c2
----
1970-01-02 1970-01-02T00:00:00 1.23 abc 1970-01-02 1970-01-02T00:00:00 -123.12 abc
1970-01-03 1970-01-03T00:00:00 456 def NULL NULL NULL NULL
1970-01-04 NULL -123.12 jkl NULL NULL NULL NULL
NULL 1970-01-04T00:00:00 789 ghi NULL 1970-01-04T00:00:00 0 qwerty


# explain hash_join_with_decimal
query TT
explain select * from hashjoin_datatype_table_t1 t1 right join hashjoin_datatype_table_t1 t2 on t1.c3 = t2.c3
----
logical_plan
01)Right Join: t1.c3 = t2.c3
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]

# hash_join_with_decimal
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 right join hashjoin_datatype_table_t1 t2 on t1.c3 = t2.c3
----
1970-01-02 1970-01-02T00:00:00 1.23 abc 1970-01-02 1970-01-02T00:00:00 1.23 abc
1970-01-03 1970-01-03T00:00:00 456 def 1970-01-03 1970-01-03T00:00:00 456 def
1970-01-04 NULL -123.12 jkl 1970-01-04 NULL -123.12 jkl
NULL 1970-01-04T00:00:00 789 ghi NULL 1970-01-04T00:00:00 789 ghi

# explain hash_join_with_dictionary
query TT
explain select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t1 t2 on t1.c4 = t2.c4
----
logical_plan
01)Inner Join: t1.c4 = t2.c4
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]

# hash_join_with_dictionary
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t2 t2 on t1.c4 = t2.c4
----
1970-01-02 1970-01-02T00:00:00 1.23 abc 1970-01-02 1970-01-02T00:00:00 -123.12 abc

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = false


####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.optimizer.prefer_hash_join = false;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

# explain sort_merge_join_on_date32 inner sort merge join on data type (Date32)
query TT
explain select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t2 t2 on t1.c1 = t2.c1
----
logical_plan
01)Inner Join: t1.c1 = t2.c1
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t2 projection=[c1, c2, c3, c4]
physical_plan
01)SortMergeJoin: join_type=Inner, on=[(c1@0, c1@0)]
02)--SortExec: expr=[c1@0 ASC], preserve_partitioning=[true]
03)----CoalesceBatchesExec: target_batch_size=2
04)------RepartitionExec: partitioning=Hash([c1@0], 2), input_partitions=1
05)--------DataSourceExec: partitions=1, partition_sizes=[1]
06)--SortExec: expr=[c1@0 ASC], preserve_partitioning=[true]
07)----CoalesceBatchesExec: target_batch_size=2
08)------RepartitionExec: partitioning=Hash([c1@0], 2), input_partitions=1
09)--------DataSourceExec: partitions=1, partition_sizes=[1]

# sort_merge_join_on_date32 inner sort merge join on data type (Date32)
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 join hashjoin_datatype_table_t2 t2 on t1.c1 = t2.c1
----
1970-01-02 1970-01-02T00:00:00 1.23 abc 1970-01-02 1970-01-02T00:00:00 -123.12 abc
1970-01-04 NULL -123.12 jkl 1970-01-04 NULL 789 qwe

# explain sort_merge_join_on_decimal right join on data type (Decimal)
query TT
explain select * from hashjoin_datatype_table_t1 t1 right join hashjoin_datatype_table_t2 t2 on t1.c3 = t2.c3
----
logical_plan
01)Right Join: CAST(t1.c3 AS Decimal128(10, 2)) = t2.c3
02)--SubqueryAlias: t1
03)----TableScan: hashjoin_datatype_table_t1 projection=[c1, c2, c3, c4]
04)--SubqueryAlias: t2
05)----TableScan: hashjoin_datatype_table_t2 projection=[c1, c2, c3, c4]
physical_plan
01)ProjectionExec: expr=[c1@0 as c1, c2@1 as c2, c3@2 as c3, c4@3 as c4, c1@5 as c1, c2@6 as c2, c3@7 as c3, c4@8 as c4]
02)--SortMergeJoin: join_type=Right, on=[(CAST(t1.c3 AS Decimal128(10, 2))@4, c3@2)]
03)----SortExec: expr=[CAST(t1.c3 AS Decimal128(10, 2))@4 ASC], preserve_partitioning=[true]
04)------CoalesceBatchesExec: target_batch_size=2
05)--------RepartitionExec: partitioning=Hash([CAST(t1.c3 AS Decimal128(10, 2))@4], 2), input_partitions=2
06)----------ProjectionExec: expr=[c1@0 as c1, c2@1 as c2, c3@2 as c3, c4@3 as c4, CAST(c3@2 AS Decimal128(10, 2)) as CAST(t1.c3 AS Decimal128(10, 2))]
07)------------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
08)--------------DataSourceExec: partitions=1, partition_sizes=[1]
09)----SortExec: expr=[c3@2 ASC], preserve_partitioning=[true]
10)------CoalesceBatchesExec: target_batch_size=2
11)--------RepartitionExec: partitioning=Hash([c3@2], 2), input_partitions=1
12)----------DataSourceExec: partitions=1, partition_sizes=[1]

# sort_merge_join_on_decimal right join on data type (Decimal)
query DDRTDDRT rowsort
select * from hashjoin_datatype_table_t1 t1 right join hashjoin_datatype_table_t2 t2 on t1.c3 = t2.c3
----
1970-01-04 NULL -123.12 jkl 1970-01-02 1970-01-02T00:00:00 -123.12 abc
NULL 1970-01-04T00:00:00 789 ghi 1970-01-04 NULL 789 qwe
NULL NULL NULL NULL NULL 1970-01-04T00:00:00 0 qwerty
NULL NULL NULL NULL NULL NULL 100000 abcdefg

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.optimizer.prefer_hash_join = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;



#Test the left_semi_join scenarios where the current repartition_joins parameter is set to true .
####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.explain.physical_plan_only = true;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

query TT
explain SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE t1_id IN (SELECT t2_id FROM left_semi_anti_join_table_t2 t2) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query IT rowsort
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE t1_id IN (SELECT t2_id FROM left_semi_anti_join_table_t2 t2) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

query IT rowsort
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT 1 FROM left_semi_anti_join_table_t2 t2 WHERE t1_id = t2_id) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

query I rowsort
SELECT t1_id FROM left_semi_anti_join_table_t1 t1 INTERSECT SELECT t2_id FROM left_semi_anti_join_table_t2 t2 ORDER BY t1_id
----
11
22
44
NULL

query TT
explain SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 LEFT SEMI JOIN left_semi_anti_join_table_t2 t2 ON (t1_id = t2_id) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query IT
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 LEFT SEMI JOIN left_semi_anti_join_table_t2 t2 ON (t1_id = t2_id) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

#Test the left_semi_join scenarios where the current repartition_joins parameter is set to false .
####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.explain.physical_plan_only = true;

statement ok
set datafusion.optimizer.repartition_joins = false;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

query TT
explain SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE t1_id IN (SELECT t2_id FROM left_semi_anti_join_table_t2 t2) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query IT rowsort
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE t1_id IN (SELECT t2_id FROM left_semi_anti_join_table_t2 t2) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

query IT rowsort
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT 1 FROM left_semi_anti_join_table_t2 t2 WHERE t1_id = t2_id) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

query I rowsort
SELECT t1_id FROM left_semi_anti_join_table_t1 t1 INTERSECT SELECT t2_id FROM left_semi_anti_join_table_t2 t2 ORDER BY t1_id
----
11
22
44
NULL

query TT
explain SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 LEFT SEMI JOIN left_semi_anti_join_table_t2 t2 ON (t1_id = t2_id) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query IT
SELECT t1_id, t1_name FROM left_semi_anti_join_table_t1 t1 LEFT SEMI JOIN left_semi_anti_join_table_t2 t2 ON (t1_id = t2_id) ORDER BY t1_id
----
11 a
11 a
22 b
44 d

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;


#Test the right_semi_join scenarios where the current repartition_joins parameter is set to true .
####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.explain.physical_plan_only = true;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

query TT
explain SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT * FROM right_semi_anti_join_table_t2 t2 where t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)], filter=t2_name@1 != t1_name@0
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query ITI rowsort
SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT * FROM right_semi_anti_join_table_t2 t2 where t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
11 a 1

query TT
explain SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t2 t2 RIGHT SEMI JOIN right_semi_anti_join_table_t1 t1 on (t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)], filter=t2_name@0 != t1_name@1
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query ITI rowsort
SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t2 t2 RIGHT SEMI JOIN right_semi_anti_join_table_t1 t1 on (t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
11 a 1

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;


#Test the right_semi_join scenarios where the current repartition_joins parameter is set to false .
####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.explain.physical_plan_only = true;

statement ok
set datafusion.optimizer.repartition_joins = false;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;

query TT
explain SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT * FROM right_semi_anti_join_table_t2 t2 where t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)], filter=t2_name@1 != t1_name@0
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query ITI rowsort
SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t1 t1 WHERE EXISTS (SELECT * FROM right_semi_anti_join_table_t2 t2 where t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
11 a 1

query TT
explain SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t2 t2 RIGHT SEMI JOIN right_semi_anti_join_table_t1 t1 on (t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
physical_plan
01)SortPreservingMergeExec: [t1_id@0 ASC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(t2_id@0, t1_id@0)], filter=t2_name@0 != t1_name@1
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[true]
06)--------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

query ITI rowsort
SELECT t1_id, t1_name, t1_int FROM right_semi_anti_join_table_t2 t2 RIGHT SEMI JOIN right_semi_anti_join_table_t1 t1 on (t2.t2_id = t1.t1_id and t2.t2_name <> t1.t1_name) ORDER BY t1_id
----
11 a 1

####
# Config teardown
####
statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.optimizer.repartition_joins = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.execution.batch_size = 2;


####
# Config setup
####
statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.optimizer.prefer_hash_join = false;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
CREATE EXTERNAL TABLE annotated_data (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH ORDER (a ASC NULLS FIRST, b ASC, c ASC)
LOCATION '../core/tests/data/window_2.csv'
OPTIONS ('format.has_header' 'true');

statement ok
set datafusion.optimizer.prefer_existing_sort = true;

# sort merge join should propagate ordering equivalence of the left side
# for inner join. Hence final requirement rn1 ASC is already satisfied at
# the end of SortMergeJoinExec.
query TT
EXPLAIN SELECT *
  FROM (SELECT *, ROW_NUMBER() OVER() as rn1
       FROM annotated_data ) as l_table
  JOIN annotated_data as r_table
  ON l_table.a = r_table.a
  ORDER BY l_table.rn1
----
logical_plan
01)Sort: l_table.rn1 ASC NULLS LAST
02)--Inner Join: l_table.a = r_table.a
03)----SubqueryAlias: l_table
04)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
05)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
06)----------TableScan: annotated_data projection=[a0, a, b, c, d]
07)----SubqueryAlias: r_table
08)------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)SortPreservingMergeExec: [rn1@5 ASC NULLS LAST]
02)--SortMergeJoin: join_type=Inner, on=[(a@1, a@1)]
03)----CoalesceBatchesExec: target_batch_size=2
04)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
05)--------ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
06)----------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
07)------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
08)----CoalesceBatchesExec: target_batch_size=2
09)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
10)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# sort merge join should propagate ordering equivalence of the right side
# for right join. Hence final requirement rn1 ASC is already satisfied at
# the end of SortMergeJoinExec.
query TT
EXPLAIN SELECT *
  FROM annotated_data as l_table
  RIGHT JOIN (SELECT *, ROW_NUMBER() OVER() as rn1
       FROM annotated_data ) as r_table
  ON l_table.a = r_table.a
  ORDER BY r_table.rn1
----
logical_plan
01)Sort: r_table.rn1 ASC NULLS LAST
02)--Right Join: l_table.a = r_table.a
03)----SubqueryAlias: l_table
04)------TableScan: annotated_data projection=[a0, a, b, c, d]
05)----SubqueryAlias: r_table
06)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
07)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
08)----------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)SortPreservingMergeExec: [rn1@10 ASC NULLS LAST]
02)--SortMergeJoin: join_type=Right, on=[(a@1, a@1)]
03)----CoalesceBatchesExec: target_batch_size=2
04)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
06)----CoalesceBatchesExec: target_batch_size=2
07)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
08)--------ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
09)----------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
10)------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

statement ok
set datafusion.optimizer.prefer_existing_sort = false;

# SortMergeJoin should add ordering equivalences of
# right table as lexicographical append to the global ordering
# below query shouldn't add any SortExec for order by clause.
# since its requirement is already satisfied at the output of SortMergeJoinExec
query TT
EXPLAIN SELECT *
  FROM (SELECT *, ROW_NUMBER() OVER() as rn1
       FROM annotated_data ) as l_table
  JOIN (SELECT *, ROW_NUMBER() OVER() as rn1
       FROM annotated_data ) as r_table
  ON l_table.a = r_table.a
  ORDER BY l_table.a ASC NULLS FIRST, l_table.b, l_table.c, r_table.rn1
----
logical_plan
01)Sort: l_table.a ASC NULLS FIRST, l_table.b ASC NULLS LAST, l_table.c ASC NULLS LAST, r_table.rn1 ASC NULLS LAST
02)--Inner Join: l_table.a = r_table.a
03)----SubqueryAlias: l_table
04)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
05)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
06)----------TableScan: annotated_data projection=[a0, a, b, c, d]
07)----SubqueryAlias: r_table
08)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
09)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
10)----------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)SortPreservingMergeExec: [a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST, rn1@11 ASC NULLS LAST]
02)--SortMergeJoin: join_type=Inner, on=[(a@1, a@1)]
03)----CoalesceBatchesExec: target_batch_size=2
04)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
05)--------ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
06)----------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
07)------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
08)----CoalesceBatchesExec: target_batch_size=2
09)------RepartitionExec: partitioning=Hash([a@1], 2), input_partitions=1, maintains_sort_order=true
10)--------ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
11)----------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
12)------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

statement ok
set datafusion.optimizer.prefer_hash_join = true;

# to preserve ordering until Hash join set target partition to 1.
# Otherwise RepartitionExec s inserted may broke ordering.
statement ok
set datafusion.execution.target_partitions = 1;

# hash join should propagate ordering equivalence of the right side for INNER join.
# Hence final requirement rn1 ASC is already satisfied at the end of HashJoinExec.
query TT
EXPLAIN SELECT *
  FROM annotated_data as l_table
  JOIN (SELECT *, ROW_NUMBER() OVER() as rn1
              FROM annotated_data) as r_table
  ON l_table.a = r_table.a
  ORDER BY r_table.rn1
----
logical_plan
01)Sort: r_table.rn1 ASC NULLS LAST
02)--Inner Join: l_table.a = r_table.a
03)----SubqueryAlias: l_table
04)------TableScan: annotated_data projection=[a0, a, b, c, d]
05)----SubqueryAlias: r_table
06)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
07)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
08)----------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(a@1, a@1)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
04)----ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
05)------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
06)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# hash join should propagate ordering equivalence of the right side for RIGHT ANTI join.
# Hence final requirement rn1 ASC is already satisfied at the end of HashJoinExec.
query TT
EXPLAIN SELECT *
  FROM annotated_data as l_table
  RIGHT ANTI JOIN (SELECT *, ROW_NUMBER() OVER() as rn1
              FROM annotated_data) as r_table
  ON l_table.a = r_table.a
  ORDER BY r_table.rn1
----
logical_plan
01)Sort: r_table.rn1 ASC NULLS LAST
02)--RightAnti Join: l_table.a = r_table.a
03)----SubqueryAlias: l_table
04)------TableScan: annotated_data projection=[a]
05)----SubqueryAlias: r_table
06)------Projection: annotated_data.a0, annotated_data.a, annotated_data.b, annotated_data.c, annotated_data.d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING AS rn1
07)--------WindowAggr: windowExpr=[[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]]
08)----------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(a@0, a@1)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a], output_ordering=[a@0 ASC], file_type=csv, has_header=true
04)----ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING@5 as rn1]
05)------BoundedWindowAggExec: wdw=[row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: Field { "row_number() ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING": UInt64 }, frame: ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING], mode=[Sorted]
06)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# Test ordering preservation for RIGHT join
query TT
EXPLAIN SELECT *
FROM annotated_data as l_table
RIGHT JOIN (SELECT * FROM annotated_data) as r_table
ON l_table.b = r_table.b
ORDER BY r_table.a ASC NULLS FIRST, r_table.b, r_table.c, l_table.a ASC NULLS FIRST;
----
logical_plan
01)Sort: r_table.a ASC NULLS FIRST, r_table.b ASC NULLS LAST, r_table.c ASC NULLS LAST, l_table.a ASC NULLS FIRST
02)--Right Join: l_table.b = r_table.b
03)----SubqueryAlias: l_table
04)------TableScan: annotated_data projection=[a0, a, b, c, d]
05)----SubqueryAlias: r_table
06)------TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)CoalesceBatchesExec: target_batch_size=2
02)--HashJoinExec: mode=CollectLeft, join_type=Right, on=[(b@2, b@2)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

query TT
EXPLAIN SELECT l.a, LAST_VALUE(r.b ORDER BY r.a ASC NULLS FIRST) as last_col1
FROM annotated_data as l
JOIN annotated_data as r
ON l.a = r.a
GROUP BY l.a, l.b, l.c
ORDER BY l.a ASC NULLS FIRST;
----
logical_plan
01)Sort: l.a ASC NULLS FIRST
02)--Projection: l.a, last_value(r.b) ORDER BY [r.a ASC NULLS FIRST] AS last_col1
03)----Aggregate: groupBy=[[l.a, l.b, l.c]], aggr=[[last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]]]
04)------Inner Join: l.a = r.a
05)--------SubqueryAlias: l
06)----------TableScan: annotated_data projection=[a, b, c]
07)--------SubqueryAlias: r
08)----------TableScan: annotated_data projection=[a, b]
physical_plan
01)ProjectionExec: expr=[a@0 as a, last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]@3 as last_col1]
02)--AggregateExec: mode=Single, gby=[a@0 as a, b@1 as b, c@2 as c], aggr=[last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]], ordering_mode=PartiallySorted([0])
03)----CoalesceBatchesExec: target_batch_size=2
04)------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(a@0, a@0)]
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], output_ordering=[a@0 ASC, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], file_type=csv, has_header=true
06)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], output_ordering=[a@0 ASC, b@1 ASC NULLS LAST], file_type=csv, has_header=true

# create a table where there more than one valid ordering
# that describes table.
statement ok
CREATE EXTERNAL TABLE multiple_ordered_table (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH ORDER (a ASC, b ASC)
WITH ORDER (c ASC)
LOCATION '../core/tests/data/window_2.csv'
OPTIONS ('format.has_header' 'true');

query TT
EXPLAIN SELECT LAST_VALUE(l.d ORDER BY l.a) AS amount_usd
FROM multiple_ordered_table AS l
INNER JOIN (
    SELECT *, ROW_NUMBER() OVER (ORDER BY r.a) as row_n FROM multiple_ordered_table AS r
)
ON l.d = r.d AND
      l.a >= r.a - 10
GROUP BY row_n
ORDER BY row_n
----
logical_plan
01)Projection: amount_usd
02)--Sort: row_n ASC NULLS LAST
03)----Projection: last_value(l.d) ORDER BY [l.a ASC NULLS LAST] AS amount_usd, row_n
04)------Aggregate: groupBy=[[row_n]], aggr=[[last_value(l.d) ORDER BY [l.a ASC NULLS LAST]]]
05)--------Projection: l.a, l.d, row_n
06)----------Inner Join: l.d = r.d Filter: CAST(l.a AS Int64) >= CAST(r.a AS Int64) - Int64(10)
07)------------SubqueryAlias: l
08)--------------TableScan: multiple_ordered_table projection=[a, d]
09)------------Projection: r.a, r.d, row_number() ORDER BY [r.a ASC NULLS LAST] RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW AS row_n
10)--------------WindowAggr: windowExpr=[[row_number() ORDER BY [r.a ASC NULLS LAST] RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW]]
11)----------------SubqueryAlias: r
12)------------------TableScan: multiple_ordered_table projection=[a, d]
physical_plan
01)ProjectionExec: expr=[last_value(l.d) ORDER BY [l.a ASC NULLS LAST]@1 as amount_usd]
02)--AggregateExec: mode=Single, gby=[row_n@2 as row_n], aggr=[last_value(l.d) ORDER BY [l.a ASC NULLS LAST]], ordering_mode=Sorted
03)----CoalesceBatchesExec: target_batch_size=2
04)------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(d@1, d@1)], filter=CAST(a@0 AS Int64) >= CAST(a@1 AS Int64) - 10, projection=[a@0, d@1, row_n@4]
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, d], output_ordering=[a@0 ASC NULLS LAST], file_type=csv, has_header=true
06)--------ProjectionExec: expr=[a@0 as a, d@1 as d, row_number() ORDER BY [r.a ASC NULLS LAST] RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW@2 as row_n]
07)----------BoundedWindowAggExec: wdw=[row_number() ORDER BY [r.a ASC NULLS LAST] RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: Field { "row_number() ORDER BY [r.a ASC NULLS LAST] RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW": UInt64 }, frame: RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW], mode=[Sorted]
08)------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, d], output_ordering=[a@0 ASC NULLS LAST], file_type=csv, has_header=true

# run query above in multiple partitions
statement ok
set datafusion.execution.target_partitions = 2;

# use bounded variants
statement ok
set datafusion.optimizer.prefer_existing_sort = true;

query TT
EXPLAIN SELECT l.a, LAST_VALUE(r.b ORDER BY r.a ASC NULLS FIRST) as last_col1
FROM annotated_data as l
JOIN annotated_data as r
ON l.a = r.a
GROUP BY l.a, l.b, l.c
ORDER BY l.a ASC NULLS FIRST;
----
logical_plan
01)Sort: l.a ASC NULLS FIRST
02)--Projection: l.a, last_value(r.b) ORDER BY [r.a ASC NULLS FIRST] AS last_col1
03)----Aggregate: groupBy=[[l.a, l.b, l.c]], aggr=[[last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]]]
04)------Inner Join: l.a = r.a
05)--------SubqueryAlias: l
06)----------TableScan: annotated_data projection=[a, b, c]
07)--------SubqueryAlias: r
08)----------TableScan: annotated_data projection=[a, b]
physical_plan
01)SortPreservingMergeExec: [a@0 ASC]
02)--ProjectionExec: expr=[a@0 as a, last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]@3 as last_col1]
03)----AggregateExec: mode=FinalPartitioned, gby=[a@0 as a, b@1 as b, c@2 as c], aggr=[last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]], ordering_mode=PartiallySorted([0])
04)------CoalesceBatchesExec: target_batch_size=2
05)--------RepartitionExec: partitioning=Hash([a@0, b@1, c@2], 2), input_partitions=2, preserve_order=true, sort_exprs=a@0 ASC
06)----------AggregateExec: mode=Partial, gby=[a@0 as a, b@1 as b, c@2 as c], aggr=[last_value(r.b) ORDER BY [r.a ASC NULLS FIRST]], ordering_mode=PartiallySorted([0])
07)------------CoalesceBatchesExec: target_batch_size=2
08)--------------HashJoinExec: mode=Partitioned, join_type=Inner, on=[(a@0, a@0)]
09)----------------CoalesceBatchesExec: target_batch_size=2
10)------------------RepartitionExec: partitioning=Hash([a@0], 2), input_partitions=1, maintains_sort_order=true
11)--------------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, c], output_ordering=[a@0 ASC, b@1 ASC NULLS LAST, c@2 ASC NULLS LAST], file_type=csv, has_header=true
12)----------------CoalesceBatchesExec: target_batch_size=2
13)------------------RepartitionExec: partitioning=Hash([a@0], 2), input_partitions=1, maintains_sort_order=true
14)--------------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], output_ordering=[a@0 ASC, b@1 ASC NULLS LAST], file_type=csv, has_header=true

query TT
EXPLAIN SELECT *
FROM annotated_data as l, annotated_data as r
WHERE l.a > r.a
----
logical_plan
01)Inner Join:  Filter: r.a < l.a
02)--SubqueryAlias: l
03)----TableScan: annotated_data projection=[a0, a, b, c, d]
04)--SubqueryAlias: r
05)----TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)NestedLoopJoinExec: join_type=Inner, filter=a@1 < a@0
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
03)--RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# Currently datafusion can pushdown filter conditions with scalar UDF into
# cross join.
query TT
EXPLAIN SELECT *
FROM annotated_data as t1, annotated_data as t2
WHERE EXAMPLE(t1.a, t2.a) > 3
----
logical_plan
01)Inner Join:  Filter: example(CAST(t1.a AS Float64), CAST(t2.a AS Float64)) > Float64(3)
02)--SubqueryAlias: t1
03)----TableScan: annotated_data projection=[a0, a, b, c, d]
04)--SubqueryAlias: t2
05)----TableScan: annotated_data projection=[a0, a, b, c, d]
physical_plan
01)NestedLoopJoinExec: join_type=Inner, filter=example(join_proj_push_down_1@0, join_proj_push_down_2@1) > 3, projection=[a0@0, a@1, b@2, c@3, d@4, a0@6, a@7, b@8, c@9, d@10]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d, CAST(a@1 AS Float64) as join_proj_push_down_1], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true
03)--ProjectionExec: expr=[a0@0 as a0, a@1 as a, b@2 as b, c@3 as c, d@4 as d, CAST(a@1 AS Float64) as join_proj_push_down_2]
04)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
05)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

####
# Config teardown
####

statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.optimizer.prefer_hash_join = true;

statement ok
set datafusion.execution.target_partitions = 2;

statement ok
set datafusion.optimizer.prefer_existing_sort = false;

statement ok
drop table annotated_data;

####
#  nestedjoin_with_alias_test
####

query IIII
select * from ((select 1 as a, 2 as b) c INNER JOIN (select 1 as c, 3 as d) e on c.a = e.c) f;
----
1 2 1 3

####
#  create_left_semi_anti_join_context_with_null_ids_table_test
####

statement ok
CREATE TABLE join_test_left(t1_id INT UNSIGNED, t1_name VARCHAR, t1_int INT UNSIGNED)
AS VALUES
(11, 'a', 1),
(11, 'a', 1),
(22, 'b', 2),
(33, 'c', 3),
(44, 'd', 4),
(NULL, 'e', 0);

statement ok
CREATE TABLE join_test_right(t2_id INT UNSIGNED, t2_name VARCHAR, t2_int INT UNSIGNED)
AS VALUES
(11, 'z', 3),
(11, 'z', 3),
(22, 'y', 1),
(33, 'x', 3),
(44, 'w', 3),
(NULL, 'v', 0);

query IT
SELECT t1_id, t1_name FROM join_test_left WHERE t1_id NOT IN (SELECT t2_id FROM join_test_right) ORDER BY t1_id;
----
NULL e

####
# join_partitioned_test
####

statement ok
CREATE TABLE join_partitioned_table(c1 INT UNSIGNED, c2 INT UNSIGNED, c3 BOOLEAN)
AS VALUES
(4, 1, true),
(4, 2, false),
(4, 3, true),
(4, 4, false);

query I
SELECT 1 FROM join_partitioned_table JOIN (SELECT c1 AS id1 FROM join_partitioned_table) AS a ON c1=id1;
----
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1


statement ok
set datafusion.explain.logical_plan_only = false;

query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as c, 2 as d
    UNION ALL
    SELECT 1 as c, 3 AS d
) as a FULL JOIN (SELECT 1 as e, 3 AS f) AS rhs ON a.c=rhs.e;
----
logical_plan
01)Full Join: a.c = rhs.e
02)--SubqueryAlias: a
03)----Union
04)------Projection: Int64(1) AS c, Int64(2) AS d
05)--------EmptyRelation: rows=1
06)------Projection: Int64(1) AS c, Int64(3) AS d
07)--------EmptyRelation: rows=1
08)--SubqueryAlias: rhs
09)----Projection: Int64(1) AS e, Int64(3) AS f
10)------EmptyRelation: rows=1
physical_plan
01)ProjectionExec: expr=[c@2 as c, d@3 as d, e@0 as e, f@1 as f]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Full, on=[(e@0, c@0)]
04)------ProjectionExec: expr=[1 as e, 3 as f]
05)--------PlaceholderRowExec
06)------UnionExec
07)--------ProjectionExec: expr=[1 as c, 2 as d]
08)----------PlaceholderRowExec
09)--------ProjectionExec: expr=[1 as c, 3 as d]
10)----------PlaceholderRowExec

query IIII rowsort
SELECT * FROM (
    SELECT 1 as c, 2 as d
    UNION ALL
    SELECT 1 as c, 3 AS d
) as a FULL JOIN (SELECT 1 as e, 3 AS f) AS rhs ON a.c=rhs.e;
----
1 2 1 3
1 3 1 3

statement ok
set datafusion.execution.target_partitions = 1;

query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as c, 2 as d
    UNION ALL
    SELECT 1 as c, 3 AS d
) as a FULL JOIN (SELECT 1 as e, 3 AS f) AS rhs ON a.c=rhs.e;
----
logical_plan
01)Full Join: a.c = rhs.e
02)--SubqueryAlias: a
03)----Union
04)------Projection: Int64(1) AS c, Int64(2) AS d
05)--------EmptyRelation: rows=1
06)------Projection: Int64(1) AS c, Int64(3) AS d
07)--------EmptyRelation: rows=1
08)--SubqueryAlias: rhs
09)----Projection: Int64(1) AS e, Int64(3) AS f
10)------EmptyRelation: rows=1
physical_plan
01)ProjectionExec: expr=[c@2 as c, d@3 as d, e@0 as e, f@1 as f]
02)--CoalesceBatchesExec: target_batch_size=2
03)----HashJoinExec: mode=CollectLeft, join_type=Full, on=[(e@0, c@0)]
04)------ProjectionExec: expr=[1 as e, 3 as f]
05)--------PlaceholderRowExec
06)------UnionExec
07)--------ProjectionExec: expr=[1 as c, 2 as d]
08)----------PlaceholderRowExec
09)--------ProjectionExec: expr=[1 as c, 3 as d]
10)----------PlaceholderRowExec

query IIII rowsort
SELECT * FROM (
    SELECT 1 as c, 2 as d
    UNION ALL
    SELECT 1 as c, 3 AS d
) as a FULL JOIN (SELECT 1 as e, 3 AS f) AS rhs ON a.c=rhs.e;
----
1 2 1 3
1 3 1 3

statement ok
set datafusion.explain.logical_plan_only = true;

statement ok
set datafusion.execution.target_partitions = 2;

# Inner join with empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as a WHERE 1=0
) AS a INNER JOIN (SELECT 1 as a) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Inner join with empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a
) AS a INNER JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left join with empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as a WHERE 1=0
) AS a LEFT JOIN (SELECT 1 as a) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left join with empty left and empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as a WHERE 1=0
) AS a LEFT JOIN (SELECT 1 as a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Right join with empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a
) AS a RIGHT JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Right join with empty right and empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 as a WHERE 1=0
) AS a RIGHT JOIN (SELECT 1 as a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left SEMI join with empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a
) AS a LEFT SEMI JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left SEMI join with empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a WHERE 1=0
) AS a LEFT SEMI JOIN (SELECT 1 AS a) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Right SEMI join with empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a WHERE 1=0
) AS a RIGHT SEMI JOIN (SELECT 1 AS a) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Right SEMI join with empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a
) AS a RIGHT SEMI JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left ANTI join with empty left table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a WHERE 1=0
) AS a LEFT ANTI JOIN (SELECT 1 AS a) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Right ANTI join with empty right table
query TT
EXPLAIN SELECT * FROM (
    SELECT 1 AS a
) AS a RIGHT ANTI JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# FULL OUTER join with empty left and empty right table
query TT
EXPLAIN SELECT * FROM (
	SELECT 1 as a WHERE 1=0
) AS a FULL JOIN (SELECT 1 AS a WHERE 1=0) AS b ON a.a=b.a;
----
logical_plan EmptyRelation: rows=0

# Left ANTI join with empty right table
query TT
EXPLAIN SELECT * FROM (
	SELECT 1 as a
) AS a LEFT ANTI JOIN (SELECT 1 AS a WHERE 1=0) as b ON a.a=b.a;
----
logical_plan
01)SubqueryAlias: a
02)--Projection: Int64(1) AS a
03)----EmptyRelation: rows=1

# Right ANTI join with empty left table
query TT
EXPLAIN SELECT * FROM (
	SELECT 1 as a WHERE 1=0
) AS a RIGHT ANTI JOIN (SELECT 1 AS a) as b ON a.a=b.a;
----
logical_plan
01)SubqueryAlias: b
02)--Projection: Int64(1) AS a
03)----EmptyRelation: rows=1


statement ok
set datafusion.execution.target_partitions = 1;

statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
set datafusion.execution.batch_size = 3;

# Right Hash Joins preserve the right ordering
# No nulls on build side:
statement ok
CREATE TABLE left_table_no_nulls(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(11, 1),
(12, 3),
(13, 5),
(14, 2),
(15, 4);

statement ok
CREATE TABLE right_table_no_nulls(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(21, 1),
(22, 2),
(23, 3),
(24, 4);

query IIII
SELECT * FROM (
    SELECT * from left_table_no_nulls
) as lhs RIGHT JOIN (
    SELECT * from right_table_no_nulls
    ORDER BY b
    LIMIT 10
) AS rhs ON lhs.b=rhs.b
----
11 1 21 1
12 3 23 3
14 2 22 2
15 4 24 4

query TT
EXPLAIN SELECT * FROM (
    SELECT * from left_table_no_nulls
) as lhs RIGHT JOIN (
    SELECT * from right_table_no_nulls
    ORDER BY b
    LIMIT 10
) AS rhs ON lhs.b=rhs.b
----
logical_plan
01)Right Join: lhs.b = rhs.b
02)--SubqueryAlias: lhs
03)----TableScan: left_table_no_nulls projection=[a, b]
04)--SubqueryAlias: rhs
05)----Sort: right_table_no_nulls.b ASC NULLS LAST, fetch=10
06)------TableScan: right_table_no_nulls projection=[a, b]
physical_plan
01)ProjectionExec: expr=[a@2 as a, b@3 as b, a@0 as a, b@1 as b]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Left, on=[(b@1, b@1)]
04)------SortExec: TopK(fetch=10), expr=[b@1 ASC NULLS LAST], preserve_partitioning=[false]
05)--------DataSourceExec: partitions=1, partition_sizes=[2]
06)------DataSourceExec: partitions=1, partition_sizes=[2]



# Missing probe index in the middle of the batch:
statement ok
CREATE TABLE left_table_missing_probe(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(11, 1),
(12, 2),
(13, 3),
(14, 6),
(15, 8);

statement ok
CREATE TABLE right_table_missing_probe(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(21, 1),
(22, 4),
(23, 6),
(24, 7),
(25, 8);

query IIII
SELECT * FROM (
    SELECT * from left_table_missing_probe
) as lhs RIGHT JOIN (
    SELECT * from right_table_missing_probe
    ORDER BY b
    LIMIT 10
) AS rhs ON lhs.b=rhs.b
----
11 1 21 1
NULL NULL 22 4
14 6 23 6
NULL NULL 24 7
15 8 25 8

query TT
EXPLAIN SELECT * FROM (
    SELECT * from left_table_no_nulls
) as lhs RIGHT JOIN (
    SELECT * from right_table_no_nulls
    ORDER BY b
) AS rhs ON lhs.b=rhs.b
----
logical_plan
01)Right Join: lhs.b = rhs.b
02)--SubqueryAlias: lhs
03)----TableScan: left_table_no_nulls projection=[a, b]
04)--SubqueryAlias: rhs
05)----TableScan: right_table_no_nulls projection=[a, b]
physical_plan
01)ProjectionExec: expr=[a@2 as a, b@3 as b, a@0 as a, b@1 as b]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Left, on=[(b@1, b@1)]
04)------DataSourceExec: partitions=1, partition_sizes=[2]
05)------DataSourceExec: partitions=1, partition_sizes=[2]


# Null build indices:
statement ok
CREATE TABLE left_table_append_null_build(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(11, 1),
(12, 1),
(13, 5),
(14, 5),
(15, 3);

statement ok
CREATE TABLE right_table_append_null_build(a INT UNSIGNED, b INT UNSIGNED)
AS VALUES
(21, 4),
(22, 5),
(23, 6),
(24, 7),
(25, 8);

query IIII
SELECT * FROM (
    SELECT * from left_table_append_null_build
) as lhs RIGHT JOIN (
    SELECT * from right_table_append_null_build
    ORDER BY b
    LIMIT 10
) AS rhs ON lhs.b=rhs.b
----
NULL NULL 21 4
13 5 22 5
14 5 22 5
NULL NULL 23 6
NULL NULL 24 7
NULL NULL 25 8


query TT
EXPLAIN SELECT * FROM (
    SELECT * from left_table_no_nulls
) as lhs RIGHT JOIN (
    SELECT * from right_table_no_nulls
    ORDER BY b
    LIMIT 10
) AS rhs ON lhs.b=rhs.b
----
logical_plan
01)Right Join: lhs.b = rhs.b
02)--SubqueryAlias: lhs
03)----TableScan: left_table_no_nulls projection=[a, b]
04)--SubqueryAlias: rhs
05)----Sort: right_table_no_nulls.b ASC NULLS LAST, fetch=10
06)------TableScan: right_table_no_nulls projection=[a, b]
physical_plan
01)ProjectionExec: expr=[a@2 as a, b@3 as b, a@0 as a, b@1 as b]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Left, on=[(b@1, b@1)]
04)------SortExec: TopK(fetch=10), expr=[b@1 ASC NULLS LAST], preserve_partitioning=[false]
05)--------DataSourceExec: partitions=1, partition_sizes=[2]
06)------DataSourceExec: partitions=1, partition_sizes=[2]


# Test CROSS JOIN LATERAL syntax (planning)
query TT
explain select t1_id, t1_name, i from join_t1 t1 cross join lateral (select * from unnest(generate_series(1, t1_int))) as series(i);
----
logical_plan
01)Cross Join: 
02)--SubqueryAlias: t1
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)--SubqueryAlias: series
05)----Subquery:
06)------Projection: UNNEST(generate_series(Int64(1),outer_ref(t1.t1_int))) AS i
07)--------Subquery:
08)----------Projection: __unnest_placeholder(generate_series(Int64(1),outer_ref(t1.t1_int)),depth=1) AS UNNEST(generate_series(Int64(1),outer_ref(t1.t1_int)))
09)------------Unnest: lists[__unnest_placeholder(generate_series(Int64(1),outer_ref(t1.t1_int)))|depth=1] structs[]
10)--------------Projection: generate_series(Int64(1), CAST(outer_ref(t1.t1_int) AS Int64)) AS __unnest_placeholder(generate_series(Int64(1),outer_ref(t1.t1_int)))
11)----------------EmptyRelation: rows=1
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "t1_int", data_type: UInt32, nullable: true }, Column { relation: Some(Bare { table: "t1" }), name: "t1_int" })


# Test CROSS JOIN LATERAL syntax (execution)
# TODO: https://github.com/apache/datafusion/issues/10048
query error DataFusion error: This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn\(Field \{ name: "t1_int", data_type: UInt32, nullable: true \}, Column \{ relation: Some\(Bare \{ table: "t1" \}\), name: "t1_int" \}\)
select t1_id, t1_name, i from join_t1 t1 cross join lateral (select * from unnest(generate_series(1, t1_int))) as series(i);


# Test INNER JOIN LATERAL syntax (planning)
query TT
explain select t1_id, t1_name, i from join_t1 t2 inner join lateral (select * from unnest(generate_series(1, t1_int))) as series(i) on(t1_id > i);
----
logical_plan
01)Inner Join:  Filter: CAST(t2.t1_id AS Int64) > series.i
02)--SubqueryAlias: t2
03)----TableScan: join_t1 projection=[t1_id, t1_name]
04)--SubqueryAlias: series
05)----Subquery:
06)------Projection: UNNEST(generate_series(Int64(1),outer_ref(t2.t1_int))) AS i
07)--------Subquery:
08)----------Projection: __unnest_placeholder(generate_series(Int64(1),outer_ref(t2.t1_int)),depth=1) AS UNNEST(generate_series(Int64(1),outer_ref(t2.t1_int)))
09)------------Unnest: lists[__unnest_placeholder(generate_series(Int64(1),outer_ref(t2.t1_int)))|depth=1] structs[]
10)--------------Projection: generate_series(Int64(1), CAST(outer_ref(t2.t1_int) AS Int64)) AS __unnest_placeholder(generate_series(Int64(1),outer_ref(t2.t1_int)))
11)----------------EmptyRelation: rows=1
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "t1_int", data_type: UInt32, nullable: true }, Column { relation: Some(Bare { table: "t2" }), name: "t1_int" })


# Test INNER JOIN LATERAL syntax (execution)
# TODO: https://github.com/apache/datafusion/issues/10048
query error DataFusion error: This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn\(Field \{ name: "t1_int", data_type: UInt32, nullable: true \}, Column \{ relation: Some\(Bare \{ table: "t2" \}\), name: "t1_int" \}\)
select t1_id, t1_name, i from join_t1 t2 inner join lateral (select * from unnest(generate_series(1, t1_int))) as series(i) on(t1_id > i);

# Test RIGHT JOIN LATERAL syntax (unsupported)
query error DataFusion error: This feature is not implemented: LATERAL syntax is not supported for FULL OUTER and RIGHT \[OUTER \| ANTI \| SEMI\] joins
select t1_id, t1_name, i from join_t1 t1 right join lateral (select * from unnest(generate_series(1, t1_int))) as series(i);


# Functional dependencies across a join
statement ok
CREATE TABLE sales_global (
    ts TIMESTAMP,
    sn INTEGER,
    amount INTEGER,
    currency VARCHAR NOT NULL,
    primary key(sn)
);

statement ok
CREATE TABLE exchange_rates (
  ts TIMESTAMP,
  sn INTEGER,
  currency_from VARCHAR NOT NULL,
  currency_to VARCHAR NOT NULL,
  rate FLOAT,
  primary key(sn)
);

query TT
EXPLAIN SELECT s.*, s.amount * LAST_VALUE(e.rate) AS amount_usd
FROM sales_global AS s
JOIN exchange_rates AS e
ON s.currency = e.currency_from AND
   e.currency_to = 'USD' AND
   s.ts >= e.ts
GROUP BY s.sn
ORDER BY s.sn
----
logical_plan
01)Sort: s.sn ASC NULLS LAST
02)--Projection: s.ts, s.sn, s.amount, s.currency, CAST(s.amount AS Float32) * last_value(e.rate) AS amount_usd
03)----Aggregate: groupBy=[[s.sn, s.ts, s.amount, s.currency]], aggr=[[last_value(e.rate)]]
04)------Projection: s.ts, s.sn, s.amount, s.currency, e.rate
05)--------Inner Join: s.currency = e.currency_from Filter: s.ts >= e.ts
06)----------SubqueryAlias: s
07)------------TableScan: sales_global projection=[ts, sn, amount, currency]
08)----------SubqueryAlias: e
09)------------Projection: exchange_rates.ts, exchange_rates.currency_from, exchange_rates.rate
10)--------------Filter: exchange_rates.currency_to = Utf8View("USD")
11)----------------TableScan: exchange_rates projection=[ts, currency_from, currency_to, rate]
physical_plan
01)SortExec: expr=[sn@1 ASC NULLS LAST], preserve_partitioning=[false]
02)--ProjectionExec: expr=[ts@1 as ts, sn@0 as sn, amount@2 as amount, currency@3 as currency, CAST(amount@2 AS Float32) * last_value(e.rate)@4 as amount_usd]
03)----AggregateExec: mode=Single, gby=[sn@1 as sn, ts@0 as ts, amount@2 as amount, currency@3 as currency], aggr=[last_value(e.rate)]
04)------CoalesceBatchesExec: target_batch_size=3
05)--------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(currency@3, currency_from@1)], filter=ts@0 >= ts@1, projection=[ts@0, sn@1, amount@2, currency@3, rate@6]
06)----------DataSourceExec: partitions=1, partition_sizes=[0]
07)----------FilterExec: currency_to@2 = USD, projection=[ts@0, currency_from@1, rate@3]
08)------------DataSourceExec: partitions=1, partition_sizes=[0]

statement ok
DROP TABLE sales_global;

statement ok
DROP TABLE exchange_rates;

# HashJoinExec and NestedLoopJoinExec can propagate SortExec down through its right child.

statement ok
CREATE TABLE left_table(a INT, b INT, c INT)

statement ok
CREATE TABLE right_table(x INT, y INT, z INT)

query TT
EXPLAIN SELECT * FROM left_table JOIN right_table ON left_table.a<right_table.x ORDER BY x;
----
logical_plan
01)Sort: right_table.x ASC NULLS LAST
02)--Inner Join:  Filter: left_table.a < right_table.x
03)----TableScan: left_table projection=[a, b, c]
04)----TableScan: right_table projection=[x, y, z]
physical_plan
01)SortExec: expr=[x@3 ASC NULLS LAST], preserve_partitioning=[false]
02)--NestedLoopJoinExec: join_type=Inner, filter=a@0 < x@1
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
EXPLAIN SELECT * FROM left_table JOIN right_table ON left_table.a<right_table.x AND left_table.b=right_table.y ORDER BY x;
----
logical_plan
01)Sort: right_table.x ASC NULLS LAST
02)--Inner Join: left_table.b = right_table.y Filter: left_table.a < right_table.x
03)----TableScan: left_table projection=[a, b, c]
04)----TableScan: right_table projection=[x, y, z]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(b@1, y@1)], filter=a@0 < x@1
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----SortExec: expr=[x@0 ASC NULLS LAST], preserve_partitioning=[false]
05)------DataSourceExec: partitions=1, partition_sizes=[0]

# Test full join with limit
statement ok
CREATE TABLE t0(c1 INT UNSIGNED, c2 INT UNSIGNED)
AS VALUES
(1, 1),
(2, 2),
(3, 3),
(4, 4);

statement ok
CREATE TABLE t1(c1 INT UNSIGNED, c2 INT UNSIGNED, c3 BOOLEAN)
AS VALUES
(2, 2, true),
(2, 2, false),
(3, 3, true),
(3, 3, false);

query IIIIB rowsort
-- Note: using LIMIT value higher than cardinality before LIMIT to avoid query non-determinism
SELECT * FROM t0 FULL JOIN t1 ON t0.c1 = t1.c1 LIMIT 20;
----
1 1 NULL NULL NULL
2 2 2 2 false
2 2 2 2 true
3 3 3 3 false
3 3 3 3 true
4 4 NULL NULL NULL

query IIIIB rowsort
-- Note: using LIMIT value higher than cardinality before LIMIT to avoid query non-determinism
SELECT * FROM t0 FULL JOIN t1 ON t0.c2 >= t1.c2 LIMIT 20;
----
1 1 NULL NULL NULL
2 2 2 2 false
2 2 2 2 true
3 3 2 2 false
3 3 2 2 true
3 3 3 3 false
3 3 3 3 true
4 4 2 2 false
4 4 2 2 true
4 4 3 3 false
4 4 3 3 true

query IIIIB rowsort
-- Note: using LIMIT value higher than cardinality before LIMIT to avoid query non-determinism
SELECT * FROM t0 FULL JOIN t1 ON t0.c1 = t1.c1 AND t0.c2 >= t1.c2 LIMIT 20;
----
1 1 NULL NULL NULL
2 2 2 2 false
2 2 2 2 true
3 3 3 3 false
3 3 3 3 true
4 4 NULL NULL NULL

## Test !join.on.is_empty() && join.filter.is_none()
query TT
EXPLAIN SELECT * FROM t0 FULL JOIN t1 ON t0.c1 = t1.c1 LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Full Join: t0.c1 = t1.c1
03)----TableScan: t0 projection=[c1, c2]
04)----TableScan: t1 projection=[c1, c2, c3]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3, fetch=2
02)--HashJoinExec: mode=CollectLeft, join_type=Full, on=[(c1@0, c1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[2]
04)----DataSourceExec: partitions=1, partition_sizes=[2]

## Test join.on.is_empty() && join.filter.is_some() -> single filter now a PWMJ
query TT
EXPLAIN SELECT * FROM t0 FULL JOIN t1 ON t0.c2 >= t1.c2 LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Full Join:  Filter: t0.c2 >= t1.c2
03)----TableScan: t0 projection=[c1, c2]
04)----TableScan: t1 projection=[c1, c2, c3]
physical_plan
01)GlobalLimitExec: skip=0, fetch=2
02)--NestedLoopJoinExec: join_type=Full, filter=c2@0 >= c2@1
03)----DataSourceExec: partitions=1, partition_sizes=[2]
04)----DataSourceExec: partitions=1, partition_sizes=[2]

## Test !join.on.is_empty() && join.filter.is_some()
query TT
EXPLAIN SELECT * FROM t0 FULL JOIN t1 ON t0.c1 = t1.c1 AND t0.c2 >= t1.c2 LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Full Join: t0.c1 = t1.c1 Filter: t0.c2 >= t1.c2
03)----TableScan: t0 projection=[c1, c2]
04)----TableScan: t1 projection=[c1, c2, c3]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3, fetch=2
02)--HashJoinExec: mode=CollectLeft, join_type=Full, on=[(c1@0, c1@0)], filter=c2@0 >= c2@1
03)----DataSourceExec: partitions=1, partition_sizes=[2]
04)----DataSourceExec: partitions=1, partition_sizes=[2]

## Add more test cases for join limit pushdown
statement ok
drop table t1

## Test limit pushdown through OUTER JOIN including left/right and full outer join cases
statement ok
set datafusion.execution.target_partitions = 1;

### Limit pushdown through join

# Note we use csv as MemoryExec does not support limit push down (so doesn't manifest
# bugs if limits are improperly pushed down)
query I
COPY (values (1), (2), (3), (4), (5))  TO 'test_files/scratch/joins/t1.csv'
STORED AS CSV
----
5

# store t2 in different order so the top N rows are not the same as the top N rows of t1
query I
COPY (values (5), (4), (3), (2), (1))  TO 'test_files/scratch/joins/t2.csv'
STORED AS CSV
----
5

statement ok
create external table t1(a int) stored as CSV location 'test_files/scratch/joins/t1.csv';

statement ok
create external table t2(b int) stored as CSV location 'test_files/scratch/joins/t2.csv';

######
## LEFT JOIN w/ LIMIT
######
query II
select * from t1 LEFT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
2 2
1 1

# the output of this query should be two rows from the previous query
# there should be no nulls
query II
select * from t1 LEFT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
2 2
1 1

# can only push down to t1 (preserved side)
query TT
explain select * from t1 LEFT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Left Join: t1.a = t2.b
03)----Limit: skip=0, fetch=2
04)------TableScan: t1 projection=[a], fetch=2
05)----TableScan: t2 projection=[b]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3, fetch=2
02)--HashJoinExec: mode=CollectLeft, join_type=Left, on=[(a@0, b@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t1.csv]]}, projection=[a], limit=2, file_type=csv, has_header=true
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t2.csv]]}, projection=[b], file_type=csv, has_header=true

######
## RIGHT JOIN w/ LIMIT
######

query II
select * from t1 RIGHT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
5 5
4 4

# the output of this query should be two rows from the previous query
# there should be no nulls
query II
select * from t1 RIGHT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
5 5
4 4

# can only push down to t2 (preserved side)
query TT
explain select * from t1 RIGHT JOIN t2 ON t1.a = t2.b LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Right Join: t1.a = t2.b
03)----TableScan: t1 projection=[a]
04)----Limit: skip=0, fetch=2
05)------TableScan: t2 projection=[b], fetch=2
physical_plan
01)CoalesceBatchesExec: target_batch_size=3, fetch=2
02)--HashJoinExec: mode=CollectLeft, join_type=Right, on=[(a@0, b@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t1.csv]]}, projection=[a], file_type=csv, has_header=true
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t2.csv]]}, projection=[b], limit=2, file_type=csv, has_header=true

######
## FULL JOIN w/ LIMIT
######
query II rowsort
select * from t1 FULL JOIN t2 ON t1.a = t2.b;
----
1 1
2 2
3 3
4 4
5 5

# the output of this query should be two rows from the previous query
# there should be no nulls
# Reproducer for https://github.com/apache/datafusion/issues/14335
query II
select * from t1 FULL JOIN t2 ON t1.a = t2.b LIMIT 2;
----
5 5
4 4


# can't push limit for full outer join
query TT
explain select * from t1 FULL JOIN t2 ON t1.a = t2.b LIMIT 2;
----
logical_plan
01)Limit: skip=0, fetch=2
02)--Full Join: t1.a = t2.b
03)----TableScan: t1 projection=[a]
04)----TableScan: t2 projection=[b]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3, fetch=2
02)--HashJoinExec: mode=CollectLeft, join_type=Full, on=[(a@0, b@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t1.csv]]}, projection=[a], file_type=csv, has_header=true
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/joins/t2.csv]]}, projection=[b], file_type=csv, has_header=true

statement ok
drop table t1;

statement ok
drop table t2;

# Test Utf8View as Join Key
# Issue: https://github.com/apache/datafusion/issues/12468
statement ok
CREATE TABLE table1(v1 STRING) AS VALUES ('foo'), (NULL);

statement ok
CREATE TABLE table1_stringview AS SELECT arrow_cast(v1, 'Utf8View') AS v1 FROM table1;

query T
select * from table1 as t1 natural join table1_stringview as t2;
----
foo

query TT
EXPLAIN SELECT count(*)
FROM my_catalog.my_schema.table_with_many_types AS l
JOIN my_catalog.my_schema.table_with_many_types AS r ON l.binary_col = r.binary_col
----
logical_plan
01)Projection: count(Int64(1)) AS count(*)
02)--Aggregate: groupBy=[[]], aggr=[[count(Int64(1))]]
03)----Projection:
04)------Inner Join: l.binary_col = r.binary_col
05)--------SubqueryAlias: l
06)----------TableScan: my_catalog.my_schema.table_with_many_types projection=[binary_col]
07)--------SubqueryAlias: r
08)----------TableScan: my_catalog.my_schema.table_with_many_types projection=[binary_col]
physical_plan
01)ProjectionExec: expr=[count(Int64(1))@0 as count(*)]
02)--AggregateExec: mode=Single, gby=[], aggr=[count(Int64(1))]
03)----ProjectionExec: expr=[]
04)------CoalesceBatchesExec: target_batch_size=3
05)--------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(binary_col@0, binary_col@0)]
06)----------DataSourceExec: partitions=1, partition_sizes=[1]
07)----------DataSourceExec: partitions=1, partition_sizes=[1]

# Test hash join sort push down
# Issue: https://github.com/apache/datafusion/issues/13559
statement ok
CREATE TABLE test(a INT, b INT, c INT)

statement ok
insert into test values (1,2,3), (4,5,6), (null, 7, 8), (8, null, 9), (9, 10, null)

statement ok
set datafusion.execution.target_partitions = 2;

query TT
explain select * from test where a in (select a from test where b > 3) order by c desc nulls first;
----
logical_plan
01)Sort: test.c DESC NULLS FIRST
02)--LeftSemi Join: test.a = __correlated_sq_1.a
03)----TableScan: test projection=[a, b, c]
04)----SubqueryAlias: __correlated_sq_1
05)------Projection: test.a
06)--------Filter: test.b > Int32(3)
07)----------TableScan: test projection=[a, b]
physical_plan
01)SortPreservingMergeExec: [c@2 DESC]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(a@0, a@0)]
04)------CoalescePartitionsExec
05)--------FilterExec: b@1 > 3, projection=[a@0]
06)----------DataSourceExec: partitions=2, partition_sizes=[1, 1]
07)------SortExec: expr=[c@2 DESC], preserve_partitioning=[true]
08)--------DataSourceExec: partitions=2, partition_sizes=[1, 1]

query TT
explain select * from test where a in (select a from test where b > 3) order by c desc nulls last;
----
logical_plan
01)Sort: test.c DESC NULLS LAST
02)--LeftSemi Join: test.a = __correlated_sq_1.a
03)----TableScan: test projection=[a, b, c]
04)----SubqueryAlias: __correlated_sq_1
05)------Projection: test.a
06)--------Filter: test.b > Int32(3)
07)----------TableScan: test projection=[a, b]
physical_plan
01)SortPreservingMergeExec: [c@2 DESC NULLS LAST]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(a@0, a@0)]
04)------CoalescePartitionsExec
05)--------FilterExec: b@1 > 3, projection=[a@0]
06)----------DataSourceExec: partitions=2, partition_sizes=[1, 1]
07)------SortExec: expr=[c@2 DESC NULLS LAST], preserve_partitioning=[true]
08)--------DataSourceExec: partitions=2, partition_sizes=[1, 1]

query III
select * from test where a in (select a from test where b > 3) order by c desc nulls first;
----
9 10 NULL
4 5 6

query III
select * from test where a in (select a from test where b > 3) order by c desc nulls last;
----
4 5 6
9 10 NULL

statement ok
DROP TABLE test

statement ok
set datafusion.execution.target_partitions = 1;

# test using_join_multiple_keys_subquery
statement count 0
create table person(id int, age int, state int);

statement count 0
create table lineitem(c1 int);

query TT
explain SELECT * FROM person a join person b using (id, age);
----
logical_plan
01)Projection: a.id, a.age, a.state, b.state
02)--Inner Join: a.id = b.id, a.age = b.age
03)----SubqueryAlias: a
04)------TableScan: person projection=[id, age, state]
05)----SubqueryAlias: b
06)------TableScan: person projection=[id, age, state]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1)], projection=[id@0, age@1, state@2, state@5]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT age FROM (SELECT * FROM person a join person b using (id, age, state));
----
logical_plan
01)Projection: a.age
02)--Inner Join: a.id = b.id, a.age = b.age, a.state = b.state
03)----SubqueryAlias: a
04)------TableScan: person projection=[id, age, state]
05)----SubqueryAlias: b
06)------TableScan: person projection=[id, age, state]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1), (state@2, state@2)], projection=[age@1]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT a.* FROM person a join person b using (id, age);
----
logical_plan
01)Projection: a.id, a.age, a.state
02)--Inner Join: a.id = b.id, a.age = b.age
03)----SubqueryAlias: a
04)------TableScan: person projection=[id, age, state]
05)----SubqueryAlias: b
06)------TableScan: person projection=[id, age]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1)], projection=[id@0, age@1, state@2]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT a.*, b.* FROM person a join person b using (id, age);
----
logical_plan
01)Inner Join: a.id = b.id, a.age = b.age
02)--SubqueryAlias: a
03)----TableScan: person projection=[id, age, state]
04)--SubqueryAlias: b
05)----TableScan: person projection=[id, age, state]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT * FROM person a join person b using (id, age, state) join person c using (id, age, state);
----
logical_plan
01)Projection: a.id, a.age, a.state
02)--Inner Join: a.id = c.id, a.age = c.age, a.state = c.state
03)----Projection: a.id, a.age, a.state
04)------Inner Join: a.id = b.id, a.age = b.age, a.state = b.state
05)--------SubqueryAlias: a
06)----------TableScan: person projection=[id, age, state]
07)--------SubqueryAlias: b
08)----------TableScan: person projection=[id, age, state]
09)----SubqueryAlias: c
10)------TableScan: person projection=[id, age, state]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1), (state@2, state@2)], projection=[id@0, age@1, state@2]
03)----CoalesceBatchesExec: target_batch_size=3
04)------HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0), (age@1, age@1), (state@2, state@2)], projection=[id@0, age@1, state@2]
05)--------DataSourceExec: partitions=1, partition_sizes=[0]
06)--------DataSourceExec: partitions=1, partition_sizes=[0]
07)----DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT * FROM person a NATURAL JOIN lineitem b;
----
logical_plan
01)Cross Join: 
02)--SubqueryAlias: a
03)----TableScan: person projection=[id, age, state]
04)--SubqueryAlias: b
05)----TableScan: lineitem projection=[c1]
physical_plan
01)CrossJoinExec
02)--DataSourceExec: partitions=1, partition_sizes=[0]
03)--DataSourceExec: partitions=1, partition_sizes=[0]

query TT
explain SELECT * FROM lineitem JOIN lineitem as lineitem2 USING (c1)
----
logical_plan
01)Projection: lineitem.c1
02)--Inner Join: lineitem.c1 = lineitem2.c1
03)----TableScan: lineitem projection=[c1]
04)----SubqueryAlias: lineitem2
05)------TableScan: lineitem projection=[c1]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(c1@0, c1@0)], projection=[c1@0]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[0]

statement count 0
drop table person;

statement count 0
drop table lineitem;

statement count 0
create table j1(j1_string varchar, j1_id int);

statement count 0
create table j2(j2_string varchar, j2_id int);

statement count 0
create table j3(j3_string varchar, j3_id int);

statement count 0
create table j4(j4_string varchar, j4_id int);

query TT
explain SELECT j1_string, j2_string FROM j1, LATERAL (SELECT * FROM j2 WHERE j1_id < j2_id) AS j2;
----
logical_plan
01)Cross Join: 
02)--TableScan: j1 projection=[j1_string]
03)--SubqueryAlias: j2
04)----Projection: j2.j2_string
05)------Subquery:
06)--------Filter: outer_ref(j1.j1_id) < j2.j2_id
07)----------TableScan: j2 projection=[j2_string, j2_id]
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "j1_id", data_type: Int32, nullable: true }, Column { relation: Some(Bare { table: "j1" }), name: "j1_id" })

query TT
explain SELECT * FROM j1 JOIN (j2 JOIN j3 ON(j2_id = j3_id - 2)) ON(j1_id = j2_id), LATERAL (SELECT * FROM j3 WHERE j3_string = j2_string) as j4
----
logical_plan
01)Cross Join: 
02)--Inner Join: CAST(j2.j2_id AS Int64) = CAST(j3.j3_id AS Int64) - Int64(2)
03)----Inner Join: j1.j1_id = j2.j2_id
04)------TableScan: j1 projection=[j1_string, j1_id]
05)------TableScan: j2 projection=[j2_string, j2_id]
06)----TableScan: j3 projection=[j3_string, j3_id]
07)--SubqueryAlias: j4
08)----Subquery:
09)------Filter: j3.j3_string = outer_ref(j2.j2_string)
10)--------TableScan: j3 projection=[j3_string, j3_id]
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "j2_string", data_type: Utf8View, nullable: true }, Column { relation: Some(Bare { table: "j2" }), name: "j2_string" })

query TT
explain SELECT * FROM j1, LATERAL (SELECT * FROM j1, LATERAL (SELECT * FROM j2 WHERE j1_id = j2_id) as j2) as j2;
----
logical_plan
01)Cross Join: 
02)--TableScan: j1 projection=[j1_string, j1_id]
03)--SubqueryAlias: j2
04)----Subquery:
05)------Cross Join: 
06)--------TableScan: j1 projection=[j1_string, j1_id]
07)--------SubqueryAlias: j2
08)----------Subquery:
09)------------Filter: outer_ref(j1.j1_id) = j2.j2_id
10)--------------TableScan: j2 projection=[j2_string, j2_id]
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "j1_id", data_type: Int32, nullable: true }, Column { relation: Some(Bare { table: "j1" }), name: "j1_id" })

query TT
explain SELECT j1_string, j2_string FROM j1 LEFT JOIN LATERAL (SELECT * FROM j2 WHERE j1_id < j2_id) AS j2 ON(true);
----
logical_plan
01)Left Join: 
02)--TableScan: j1 projection=[j1_string]
03)--SubqueryAlias: j2
04)----Projection: j2.j2_string
05)------Subquery:
06)--------Filter: outer_ref(j1.j1_id) < j2.j2_id
07)----------TableScan: j2 projection=[j2_string, j2_id]
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "j1_id", data_type: Int32, nullable: true }, Column { relation: Some(Bare { table: "j1" }), name: "j1_id" })

query TT
explain SELECT * FROM j1, (j2 LEFT JOIN LATERAL (SELECT * FROM j3 WHERE j1_id + j2_id = j3_id) AS j3 ON(true));
----
logical_plan
01)Cross Join: 
02)--TableScan: j1 projection=[j1_string, j1_id]
03)--Left Join: 
04)----TableScan: j2 projection=[j2_string, j2_id]
05)----SubqueryAlias: j3
06)------Subquery:
07)--------Filter: outer_ref(j1.j1_id) + outer_ref(j2.j2_id) = j3.j3_id
08)----------TableScan: j3 projection=[j3_string, j3_id]
physical_plan_error This feature is not implemented: Physical plan does not support logical expression OuterReferenceColumn(Field { name: "j1_id", data_type: Int32, nullable: true }, Column { relation: Some(Bare { table: "j1" }), name: "j1_id" })

query TT
explain SELECT * FROM j1, LATERAL (SELECT 1) AS j2;
----
logical_plan
01)Cross Join: 
02)--TableScan: j1 projection=[j1_string, j1_id]
03)--SubqueryAlias: j2
04)----Projection: Int64(1)
05)------EmptyRelation: rows=1
physical_plan
01)CrossJoinExec
02)--DataSourceExec: partitions=1, partition_sizes=[0]
03)--ProjectionExec: expr=[1 as Int64(1)]
04)----PlaceholderRowExec

statement count 0
drop table j1;

statement count 0
drop table j2;

statement count 0
drop table j3;

statement count 0
drop table j4;

statement count 0
create table person(id int);

statement count 0
create table orders(customer_id int);

query TT
explain SELECT * FROM person INNER JOIN orders ON orders.customer_id * 2 = person.id + 10
----
logical_plan
01)Inner Join: CAST(person.id AS Int64) + Int64(10) = CAST(orders.customer_id AS Int64) * Int64(2)
02)--TableScan: person projection=[id]
03)--TableScan: orders projection=[customer_id]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(person.id + Int64(10)@1, orders.customer_id * Int64(2)@1)], projection=[id@0, customer_id@2]
03)----ProjectionExec: expr=[id@0 as id, CAST(id@0 AS Int64) + 10 as person.id + Int64(10)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)----ProjectionExec: expr=[customer_id@0 as customer_id, CAST(customer_id@0 AS Int64) * 2 as orders.customer_id * Int64(2)]
06)------DataSourceExec: partitions=1, partition_sizes=[0]

statement count 0
drop table person;

statement count 0
drop table orders;

# Create tables for testing compound field access in JOIN conditions
statement ok
CREATE TABLE compound_field_table_t
AS VALUES
({r: 'a', c: 1}),
({r: 'b', c: 2.3});

statement ok
CREATE TABLE compound_field_table_u
AS VALUES
({r: 'a', c: 1}),
({r: 'b', c: 2.3});

# Test compound field access in JOIN condition with table aliases
query ??
SELECT * FROM compound_field_table_t tee JOIN compound_field_table_u you ON tee.column1['r'] = you.column1['r']
----
{r: a, c: 1.0} {r: a, c: 1.0}
{r: b, c: 2.3} {r: b, c: 2.3}

# Test compound field access in JOIN condition without table aliases
query ??
SELECT * FROM compound_field_table_t JOIN compound_field_table_u ON compound_field_table_t.column1['r'] = compound_field_table_u.column1['r']
----
{r: a, c: 1.0} {r: a, c: 1.0}
{r: b, c: 2.3} {r: b, c: 2.3}

# Test compound field access with numeric field access
query ??
SELECT * FROM compound_field_table_t tee JOIN compound_field_table_u you ON tee.column1['c'] = you.column1['c']
----
{r: a, c: 1.0} {r: a, c: 1.0}
{r: b, c: 2.3} {r: b, c: 2.3}

# Test compound field access with mixed field types
query ??
SELECT * FROM compound_field_table_t tee JOIN compound_field_table_u you ON tee.column1['r'] = you.column1['r'] AND tee.column1['c'] = you.column1['c']
----
{r: a, c: 1.0} {r: a, c: 1.0}
{r: b, c: 2.3} {r: b, c: 2.3}

# Clean up compound field tables
statement ok
DROP TABLE compound_field_table_t;

statement ok
DROP TABLE compound_field_table_u;


statement ok
CREATE TABLE t1 (k INT, v INT);

statement ok
CREATE TABLE t2 (k INT, v INT);

statement ok
INSERT INTO t1
  SELECT value AS k, value AS v
  FROM range(1, 10001) AS t(value);

statement ok
INSERT INTO t2 VALUES (1, 1);

## The TopK(Sort with fetch) should not be pushed down to the hash join
query TT
explain
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON t1.k = t2.k
ORDER BY t1.k
LIMIT 2;
----
logical_plan
01)Sort: t1.k ASC NULLS LAST, fetch=2
02)--LeftAnti Join: t1.k = t2.k
03)----TableScan: t1 projection=[k, v]
04)----TableScan: t2 projection=[k]
physical_plan
01)SortExec: TopK(fetch=2), expr=[k@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(k@0, k@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)------DataSourceExec: partitions=1, partition_sizes=[3334]


query II
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON t1.k = t2.k
ORDER BY t1.k
LIMIT 2;
----
2 2
3 3


## Test left anti join without limit, we should support push down sort to the left side
query TT
explain
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON t1.k = t2.k
ORDER BY t1.k;
----
logical_plan
01)Sort: t1.k ASC NULLS LAST
02)--LeftAnti Join: t1.k = t2.k
03)----TableScan: t1 projection=[k, v]
04)----TableScan: t2 projection=[k]
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(k@0, k@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[1]
04)----SortExec: expr=[k@0 ASC NULLS LAST], preserve_partitioning=[false]
05)------DataSourceExec: partitions=1, partition_sizes=[3334]

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;


# Test hash joins with an empty build relation (empty build relation optimization)

statement ok
CREATE TABLE t1 (k1 int, v1 int);

statement ok
CREATE TABLE t2 (k2 int, v2 int);

statement ok
INSERT INTO t1 SELECT i AS k, 1 FROM generate_series(1, 30000) t(i);

statement ok
set datafusion.explain.physical_plan_only = true;

# INNER JOIN
query TT
EXPLAIN
SELECT *
FROM t1
JOIN t2 ON k1 = k2
----
physical_plan
01)ProjectionExec: expr=[k1@2 as k1, v1@3 as v1, k2@0 as k2, v2@1 as v2]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(k2@0, k1@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query IIII
SELECT sum(k1), sum(v1), sum(k2), sum(v2)
FROM t1
JOIN t2 ON k1 = k2
----
NULL NULL NULL NULL

# LEFT JOIN
query TT
EXPLAIN
SELECT *
FROM t1
LEFT JOIN t2 ON k1 = k2
----
physical_plan
01)ProjectionExec: expr=[k1@2 as k1, v1@3 as v1, k2@0 as k2, v2@1 as v2]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Right, on=[(k2@0, k1@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query IIII
SELECT sum(k1), sum(v1), sum(k2), sum(v2)
FROM t1
LEFT JOIN t2 ON k1 = k2
----
450015000 30000 NULL NULL

# RIGHT JOIN
query TT
EXPLAIN
SELECT *
FROM t1
RIGHT JOIN t2 ON k1 = k2
----
physical_plan
01)ProjectionExec: expr=[k1@2 as k1, v1@3 as v1, k2@0 as k2, v2@1 as v2]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Left, on=[(k2@0, k1@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query IIII
SELECT sum(k1), sum(v1), sum(k2), sum(v2)
FROM t1
RIGHT JOIN t2 ON k1 = k2
----
NULL NULL NULL NULL

# LEFT SEMI JOIN
query TT
EXPLAIN
SELECT *
FROM t1
LEFT SEMI JOIN t2 ON k1 = k2
----
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(k2@0, k1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT sum(k1), sum(v1)
FROM t1
LEFT SEMI JOIN t2 ON k1 = k2
----
NULL NULL

# RIGHT SEMI JOIN
query TT
EXPLAIN
SELECT *
FROM t1
RIGHT SEMI JOIN t2 ON k1 = k2
----
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=LeftSemi, on=[(k2@0, k1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT sum(k2), sum(v2)
FROM t1
RIGHT SEMI JOIN t2 ON k1 = k2
----
NULL NULL

# LEFT ANTI JOIN
query TT
EXPLAIN
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
----
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(k2@0, k1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT sum(k1), sum(v1)
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
----
450015000 30000

# RIGHT ANTI JOIN
query TT
EXPLAIN
SELECT *
FROM t1
RIGHT ANTI JOIN t2 ON k1 = k2
----
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=LeftAnti, on=[(k2@0, k1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT sum(k2), sum(v2)
FROM t1
RIGHT ANTI JOIN t2 ON k1 = k2
----
NULL NULL

# FULL JOIN
query TT
EXPLAIN
SELECT *
FROM t1
FULL JOIN t2 ON k1 = k2
----
physical_plan
01)ProjectionExec: expr=[k1@2 as k1, v1@3 as v1, k2@0 as k2, v2@1 as v2]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=Full, on=[(k2@0, k1@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query IIII
SELECT sum(k1), sum(v1), sum(k2), sum(v2)
FROM t1
FULL JOIN t2 ON k1 = k2
----
450015000 30000 NULL NULL

# LEFT MARK JOIN
query TT
EXPLAIN 
SELECT *
FROM t2
WHERE k2 > 0
    OR EXISTS (
        SELECT *
        FROM t1
        WHERE k2 = k1
    )
----
physical_plan
01)FilterExec: k2@0 > 0 OR mark@2, projection=[k2@0, v2@1]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=LeftMark, on=[(k2@0, k1@0)]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT *
FROM t2
WHERE k2 > 0
    OR EXISTS (
        SELECT *
        FROM t1
        WHERE k2 = k1
    )
----

# Projection inside the join (changes the output schema)
query TT
EXPLAIN
SELECT distinct(v1)
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
----
physical_plan
01)AggregateExec: mode=Single, gby=[v1@0 as v1], aggr=[]
02)--CoalesceBatchesExec: target_batch_size=3
03)----HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(k2@0, k1@0)], projection=[v1@1]
04)------DataSourceExec: partitions=1, partition_sizes=[0]
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query I
SELECT distinct(v1)
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
----
1

# Both sides empty
query TT
EXPLAIN
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
WHERE k1 < 0
----
physical_plan
01)CoalesceBatchesExec: target_batch_size=3
02)--HashJoinExec: mode=CollectLeft, join_type=RightAnti, on=[(k2@0, k1@0)]
03)----DataSourceExec: partitions=1, partition_sizes=[0]
04)----FilterExec: k1@0 < 0
05)------DataSourceExec: partitions=1, partition_sizes=[10000]

query II
SELECT *
FROM t1
LEFT ANTI JOIN t2 ON k1 = k2
WHERE k1 < 0
----

# Mark testing
statement ok
CREATE OR REPLACE TABLE t1(b INT, c INT, d INT);

statement ok
INSERT INTO t1 VALUES
  (10, 5, 3),   
  ( 1, 7, 8),  
  ( 2, 9, 7),   
  ( 3, 8,10),   
  ( 5, 6, 6),   
  ( 0, 4, 9),   
  ( 4, 8, 7),   
  (100,6, 5);  

query I rowsort
SELECT c
  FROM t1
 WHERE c > d
    OR EXISTS(SELECT 1 FROM t1 AS x WHERE x.b<t1.b)
    OR (c <= d-2 OR c >= d+2)
----
4
5
6
6
7
8
8
9

# PiecewiseMergeJoin Test
statement ok
set datafusion.optimizer.enable_piecewise_merge_join = true;

query II
SELECT join_t1.t1_id, join_t2.t2_id
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id > join_t2.t2_id
WHERE join_t1.t1_id > 10 AND join_t2.t2_int > 1
ORDER BY 1
----
22 11
33 11
44 11

query TT
EXPLAIN
SELECT join_t1.t1_id, join_t2.t2_id
FROM join_t1
INNER JOIN join_t2 ON join_t1.t1_id > join_t2.t2_id
WHERE join_t1.t1_id > 10 AND join_t2.t2_int > 1
ORDER BY 1
----
physical_plan
01)SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--PiecewiseMergeJoin: operator=Gt, join_type=Inner, on=(t1_id > t2_id)
03)----SortExec: expr=[t1_id@0 ASC], preserve_partitioning=[false]
04)------FilterExec: t1_id@0 > 10
05)--------DataSourceExec: partitions=1, partition_sizes=[1]
06)----FilterExec: t2_int@1 > 1, projection=[t2_id@0]
07)------DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.optimizer.enable_piecewise_merge_join = false;
