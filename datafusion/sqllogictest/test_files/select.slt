
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

statement ok
CREATE EXTERNAL TABLE aggregate_test_100 (
  c1  VARCHAR NOT NULL,
  c2  TINYINT NOT NULL,
  c3  SMALLINT NOT NULL,
  c4  SMALLINT,
  c5  INT,
  c6  BIGINT NOT NULL,
  c7  SMALLINT NOT NULL,
  c8  INT NOT NULL,
  c9  BIGINT UNSIGNED NOT NULL,
  c10 VARCHAR NOT NULL,
  c11 FLOAT NOT NULL,
  c12 DOUBLE NOT NULL,
  c13 VARCHAR NOT NULL
)
STORED AS CSV
LOCATION '../../testing/data/csv/aggregate_test_100.csv'
OPTIONS ('format.has_header' 'true');

statement ok
CREATE EXTERNAL TABLE aggregate_simple (
  c1 FLOAT NOT NULL,
  c2 DOUBLE NOT NULL,
  c3 BOOLEAN NOT NULL
)
STORED AS CSV
LOCATION '../core/tests/data/aggregate_simple.csv'
OPTIONS ('format.has_header' 'true');

##########
## SELECT Tests
##########

##########
## window_null_string_table_test
##########

statement ok
CREATE TABLE window_null_string_value_prepare(x string, y string, z string)
AS VALUES
('one', 'ONE', 'One'),
(NULL, NULL, NULL),
('three', 'THREE', 'Three');

statement ok
CREATE TABLE window_null_string_table
AS SELECT arrow_cast(x, 'Dictionary(Int32, Utf8)') as d1,
y as d2,
arrow_cast(z, 'LargeUtf8') as d3 FROM window_null_string_value_prepare;

query TI
SELECT d1, row_number() OVER (partition by d1) as rn1 FROM window_null_string_table order by d1 asc;
----
one 1
three 1
NULL 1

query TI
SELECT d2, row_number() OVER (partition by d2) as rn1 FROM window_null_string_table ORDER BY d2 asc;
----
ONE 1
THREE 1
NULL 1

query TI
SELECT d2, row_number() OVER (partition by d2 order by d2 desc) as rn1 FROM window_null_string_table ORDER BY d2 desc
----
NULL 1
THREE 1
ONE 1

# Test large string as well
query TI rowsort
SELECT d3, row_number() OVER (partition by d3) as rn1 FROM window_null_string_table;
----
NULL 1
One 1
Three 1


statement ok
CREATE TABLE test (
  c1 BIGINT NOT NULL,
  c2 BIGINT NOT NULL,
  c3 BOOLEAN NOT NULL
) AS VALUES (0, 1, false),
(0, 10, true),
(0, 2, true),
(0, 3, false),
(0, 4, true),
(0, 5, false),
(0, 6, true),
(0, 7, false),
(0, 8, true),
(0, 9, false),
(1, 1, false),
(1, 10, true),
(1, 2, true),
(1, 3, false),
(1, 4, true),
(1, 5, false),
(1, 6, true),
(1, 7, false),
(1, 8, true),
(1, 9, false),
(2, 1, false),
(2, 10, true),
(2, 2, true),
(2, 3, false),
(2, 4, true),
(2, 5, false),
(2, 6, true),
(2, 7, false),
(2, 8, true),
(2, 9, false),
(3, 1, false),
(3, 10, true),
(3, 2, true),
(3, 3, false),
(3, 4, true),
(3, 5, false),
(3, 6, true),
(3, 7, false),
(3, 8, true),
(3, 9, false);


# parallel_query_with_filter
query II
SELECT c1, c2 FROM test WHERE c1 > 0 AND c1 < 3;
----
1 1
1 10
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
2 1
2 10
2 2
2 3
2 4
2 5
2 6
2 7
2 8
2 9

######
# Boolean literal
######
query IB
SELECT c1, c3 FROM test WHERE c1 > 2 AND c3 = true;
----
3 true
3 true
3 true
3 true
3 true

statement ok
drop table test;

######
# struct test
######
# Prepare the table with struct values for testing
statement ok
CREATE TABLE struct_value
AS VALUES
(make_array(0, 1, 2, 3)),
(make_array(4, 5, 6, 7)),
(make_array(8, 9, 10, 11));

statement ok
CREATE TABLE nested_get_indexed_field_on_struct_table
AS SELECT struct(column1) as some_struct from struct_value;

# Original column is micros, convert to millis and check timestamp
query ?
SELECT some_struct['c0'] FROM nested_get_indexed_field_on_struct_table LIMIT 3;
----
[0, 1, 2, 3]
[4, 5, 6, 7]
[8, 9, 10, 11]

# Access to field of struct by CompoundIdentifier
query ?
SELECT some_struct.c0 as l0 FROM nested_get_indexed_field_on_struct_table LIMIT 3;
----
[0, 1, 2, 3]
[4, 5, 6, 7]
[8, 9, 10, 11]

query I
SELECT some_struct['c0'][1] as i0 FROM nested_get_indexed_field_on_struct_table LIMIT 3;
----
0
4
8

# Basic SELECT
####
#  dictionary_test
####

# Prepare the table with dictionary values for testing
statement ok
CREATE TABLE value(x string, y string, z string)
AS VALUES
('one', 'blarg', 'XYZ'),
(NULL, NULL, NULL),
('three', 'three', 'three');

statement ok
CREATE TABLE string_dictionary_table
AS SELECT arrow_cast(x, 'Dictionary(Int32, Utf8)') as d1,
arrow_cast(y, 'Dictionary(Int32, Utf8)') as d2,
z as d3 FROM value;

query T
SELECT d1 FROM string_dictionary_table;
----
one
NULL
three

# basic filtering
query T
SELECT d1 FROM string_dictionary_table WHERE d1 IS NOT NULL;
----
one
three

# comparison with constant
query T
SELECT d1 FROM string_dictionary_table WHERE d1 = 'three';
----
three

# comparison with another dictionary column
query T
SELECT d1 FROM string_dictionary_table WHERE d1 = d2;
----
three

# order comparison with another dictionary column
query T
SELECT d1 FROM string_dictionary_table WHERE d1 <= d2;
----
three

# comparison with a non dictionary column
query T
SELECT d1 FROM string_dictionary_table WHERE d1 = d3;
----
three

# filtering with constant
query T
SELECT d1 FROM string_dictionary_table WHERE d1 = 'three';
----
three

# Expression evaluation
query T
SELECT concat(d1, '-foo') FROM string_dictionary_table;
----
one-foo
-foo
three-foo

# Expression evaluation with two dictionaries
query T
SELECT concat(d1, d2) FROM string_dictionary_table;
----
oneblarg
(empty)
threethree

# aggregation
query I
SELECT COUNT(d1) FROM string_dictionary_table;
----
2

# aggregation min
query T
SELECT MIN(d1) FROM string_dictionary_table;
----
one

# aggregation max
query T
SELECT MAX(d1) FROM string_dictionary_table;
----
three

# grouping
query TI
SELECT d1, COUNT(*) FROM string_dictionary_table group by d1 order by d1;
----
one 1
three 1
NULL 1

# window functions
query TI
SELECT d1, row_number() OVER (partition by d1) as rn1 FROM string_dictionary_table order by d1;
----
one 1
three 1
NULL 1

# select_values_list
statement error DataFusion error: SQL error: ParserError\("Expected: \(, found: EOF"\)
VALUES

statement error DataFusion error: SQL error: ParserError\("Expected: an expression, found: \) at Line: 1, Column: 9"\)
VALUES ()

statement error DataFusion error: SQL error: ParserError\("Expected: an expression, found: \) at Line: 1, Column: 13"\)
VALUES (1),()

statement error DataFusion error: Error during planning: Inconsistent data length across values list: got 2 values in row 1 but expected 1
VALUES (1),(1,2)

query I
VALUES (1),('2')
----
1
2

query R
VALUES (1),(2.0)
----
1
2

query II
VALUES (1,2), (1,'2')
----
1 2
1 2

query IT
VALUES (1,'a'),(NULL,'b'),(3,'c')
----
1 a
NULL b
3 c

query IT
VALUES (NULL,'a'),(NULL,'b'),(3,'c')
----
NULL a
NULL b
3 c

query ?T
VALUES (NULL,'a'),(NULL,'b'),(NULL,'c')
----
NULL a
NULL b
NULL c

query IT
VALUES (1,'a'),(2,NULL),(3,'c')
----
1 a
2 NULL
3 c

query IT
VALUES (1,NULL),(2,NULL),(3,'c')
----
1 NULL
2 NULL
3 c

query IIIIIIIIIIIII?TR
VALUES (1,2,3,4,5,6,7,8,9,10,11,12,13,NULL,'F',3.5)
----
1 2 3 4 5 6 7 8 9 10 11 12 13 NULL F 3.5

# Test non-literal expressions in VALUES
query II
VALUES (1, CASE WHEN RANDOM() > 0.5 THEN 1 ELSE 1 END),
       (2, CASE WHEN RANDOM() > 0.5 THEN 2 ELSE 2 END);
----
1 1
2 2

query IT
SELECT * FROM (VALUES (1,'a'),(2,NULL)) AS t(c1, c2)
----
1 a
2 NULL

query TT
EXPLAIN VALUES (1, 'a', -1, 1.1),(NULL, 'b', -3, 0.5)
----
logical_plan Values: (Int64(1), Utf8("a"), Int64(-1), Float64(1.1)), (Int64(NULL), Utf8("b"), Int64(-3), Float64(0.5))
physical_plan DataSourceExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN VALUES ('1'::float)
----
logical_plan Values: (Float32(1) AS Utf8("1"))
physical_plan DataSourceExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN VALUES (('1'||'2')::int unsigned)
----
logical_plan Values: (UInt32(12) AS Utf8("1") || Utf8("2"))
physical_plan DataSourceExec: partitions=1, partition_sizes=[1]


# all where empty
statement ok
SELECT * FROM aggregate_test_100 WHERE 1=2

# Simple values function
query I
VALUES (1)
----
1

# VALUES with a negative values
query I
VALUES (-1)
----
-1

# foo bar
query IIB
VALUES (2+1,2-1,2>1)
----
3 1 true

# multiple rows values
query I rowsort
VALUES (1),(2)
----
1
2

# multiple rows and columns from VALUES
query IT rowsort
VALUES (1,'a'),(2,'b')
----
1 a
2 b

# table foo for distinct order by
statement ok
CREATE TABLE foo AS VALUES
(1, 2),
(3, 4),
(5, 6);

# multiple rows and columns need type coercion
statement ok
CREATE TABLE foo2(c1 double, c2 double) AS VALUES
(1.1, 4.1),
(2, 5),
(3, 6);

query T
SELECT arrow_typeof(COALESCE(column1, column2)) FROM VALUES (null, 1.2);
----
Float64

# multiple rows and columns with null need type coercion
query TTT
select arrow_typeof(column1), arrow_typeof(column2), arrow_typeof(column3) from (SELECT column1, column2, column3 FROM VALUES
(null, 2, 'a'),
(1.1, null, 'b'),
(2, 5, null)) LIMIT 1;
----
Float64 Int64 Utf8


# foo distinct
query T
select distinct '1' from foo;
----
1

# foo order by
query T
select '1' from foo order by column1;
----
1
1
1

# foo distinct order by
statement error DataFusion error: Error during planning: For SELECT DISTINCT, ORDER BY expressions foo\.column1 must appear in select list
select distinct '1' from foo order by column1;

# distincts for float nan
query BBBBBBBBBBBBBBBBB
select
    'nan'::double is distinct from 'nan'::double v1,
    'nan'::double is not distinct from 'nan'::double v2,
    'nan'::double is not distinct from null v3,
    'nan'::double is distinct from null v4,
    null is distinct from 'nan'::double v5,
    null is not distinct from 'nan'::double v6,
    'nan'::float is distinct from 'nan'::float v7,
    'nan'::float is not distinct from 'nan'::float v8,
    'nan'::float is not distinct from null v9,
    'nan'::float is distinct from null v10,
    null is distinct from 'nan'::float v11,
    null is not distinct from 'nan'::float v12,
    1::float is distinct from 2::float v13,
    'nan'::float is distinct from 1::float v14,
    'nan'::float is not distinct from 1::float v15,
    1::float is not distinct from null v16,
    1::float is distinct from null v17
;
----
false true false true true false false true false true true false true true false false true

# select uppercase alias table
query I
SELECT "T".* from (SELECT 1 a) AS "T"
----
1

# explain select uppercase alias table
query TT
EXPLAIN SELECT * FROM ((SELECT column1 FROM foo) "T1" CROSS JOIN (SELECT column2 FROM foo) "T2") AS "F"
----
logical_plan
01)SubqueryAlias: F
02)--Cross Join:
03)----SubqueryAlias: T1
04)------TableScan: foo projection=[column1]
05)----SubqueryAlias: T2
06)------TableScan: foo projection=[column2]
physical_plan
01)CrossJoinExec
02)--DataSourceExec: partitions=1, partition_sizes=[1]
03)--DataSourceExec: partitions=1, partition_sizes=[1]

# select NaNs
query BBBB
select (isnan('NaN'::double) AND 'NaN'::double > 0) a, (isnan('-NaN'::double) AND '-NaN'::double < 0) b, (isnan('NaN'::float) AND 'NaN'::float > 0) c, (isnan('-NaN'::float) AND '-NaN'::float < 0) d
----
true true true true

# select limit clause
query I
select * from (select 1 a union all select 2) b order by a limit 1;
----
1

# select limit clause invalid
statement error Error during planning: LIMIT must be >= 0, '-1' was provided
select * from (select 1 a union all select 2) b order by a limit -1;

statement error Error during planning: OFFSET must be >=0, '-1' was provided
select * from (select 1 a union all select 2) b order by a offset -1;

statement error Unsupported LIMIT expression
select * from (values(1),(2)) limit (select 1);

statement error Unsupported OFFSET expression
select * from (values(1),(2)) offset (select 1);

# disallow non-integer limit/offset
statement error Expected LIMIT to be an integer or null, but got Float64
select * from (values(1),(2)) limit 0.5;

statement error Expected OFFSET to be an integer or null, but got Utf8
select * from (values(1),(2)) offset '1';

# test with different integer types
query I
select * from (values (1), (2), (3), (4)) limit 2::int OFFSET 1::tinyint
----
2
3

# select limit with basic arithmetic
query I
select * from (select 1 a union all select 2) b order by a limit 1+1;
----
1
2

# select limit with basic arithmetic
query I
select * from (values (1)) LIMIT 10*100;
----
1

# select limit with complex arithmetic
query I
select * from (values (1)) LIMIT 100/10;
----
1

# test constant-folding of LIMIT expr
query I
select * from (values (1), (2), (3), (4)) LIMIT abs(-4) + 4 / -2; -- LIMIT 2
----
1
2

# test constant-folding of OFFSET expr
query I
select * from (values (1), (2), (3), (4)) OFFSET abs(-4) + 4 / -2; -- OFFSET 2
----
3
4

# test constant-folding of LIMIT and OFFSET
query I
select * from (values (1), (2), (3), (4))
  -- LIMIT 2
  LIMIT abs(-4) + -1 * 2
  -- OFFSET 1
  OFFSET case when 1 < 2 then 1 else 0 end;
----
2
3

statement error Schema error: No field named column1.
select * from (values (1)) LIMIT cast(column1 as tinyint);

# select limit clause
query I
select * from (select 1 a union all select 2) b order by a limit null;
----
1
2

# offset null takes no effect
query I
select * from (select 1 a union all select 2) b order by a offset null;
----
1
2

# select limit clause
query I
select * from (select 1 a union all select 2) b order by a limit 0;
----

# select case when type coercion with case expression
query I
select CASE 10.5 WHEN 0 THEN 1 ELSE 2 END;
----
2

# select case when type coercion without case expression
query I
select CASE
  WHEN 10 = 5 THEN 1
  WHEN 'true' THEN 2
  ELSE 3
END;
----
2

# select case when type is null
query I
select CASE
  WHEN NULL THEN 1
  ELSE 2
END;
----
2

# select case then type is null
query I
select CASE
  WHEN 10 > 5 THEN NULL
  ELSE 2
END;
----
NULL

# select case else type is null
query I
select CASE
  WHEN 10 = 5 THEN 1
  ELSE NULL
END;
----
NULL

# Binary Expression for LargeUtf8
# issue: https://github.com/apache/datafusion/issues/5893
statement ok
CREATE TABLE t as select arrow_cast('Bar', 'LargeUtf8') as column1, 'B%' as column2;

query B
select column1 like column2 from t;
----
true

query B
select column1 ilike column2 from t;
----
true

query B
select column1 not like column2 from t;
----
false

query B
select column1 not ilike column2 from t;
----
false

query B
select column1 is distinct from column2 from t;
----
true

query B
select column1 is not distinct from column2 from t;
----
false


# Binary Expression for Binary
statement ok
CREATE TABLE binary_t as select arrow_cast('Bar', 'Binary') as column1, arrow_cast('B%', 'Binary') as column2;

query B
select column1 is distinct from column2 from binary_t;
----
true

query B
select column1 is not distinct from column2 from binary_t;
----
false

# Binary Expression for LargeBinary
statement ok
CREATE TABLE large_binary_t as select arrow_cast('Bar', 'LargeBinary') as column1, arrow_cast('B%', 'LargeBinary') as column2;

query B
select column1 is distinct from column2 from large_binary_t;
----
true

query B
select column1 is not distinct from column2 from large_binary_t;
----
false

# select all
# these two queries should return the same result
query R
SELECT c1 FROM aggregate_simple order by c1
----
0.00001
0.00002
0.00002
0.00003
0.00003
0.00003
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005

query R
SELECT ALL c1 FROM aggregate_simple order by c1
----
0.00001
0.00002
0.00002
0.00003
0.00003
0.00003
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005

# select distinct
query RRB rowsort
SELECT DISTINCT * FROM aggregate_simple
----
0.00001 0.000000000001 true
0.00002 0.000000000002 false
0.00003 0.000000000003 true
0.00004 0.000000000004 false
0.00005 0.000000000005 true

# select distinct with projection and order by
query R
SELECT DISTINCT c1 FROM aggregate_simple order by c1
----
0.00001
0.00002
0.00003
0.00004
0.00005

# select distinct with multi-columns projection and single-column order by
query RR
SELECT DISTINCT c1, c2 FROM aggregate_simple order by c1
----
0.00001 0.000000000001
0.00002 0.000000000002
0.00003 0.000000000003
0.00004 0.000000000004
0.00005 0.000000000005

# select distinct boolean column
query B
SELECT DISTINCT c3 FROM aggregate_simple order by c3
----
false
true

# select distinct with addition expression
query R rowsort
SELECT DISTINCT c1 + c2 AS a FROM aggregate_simple
----
0.000010000001
0.000020000001
0.000030000002
0.000040000003
0.000050000004

# select distinct from
query BBBBBBBB
select
1 IS DISTINCT FROM CAST(NULL as INT) as a,
1 IS DISTINCT FROM 1 as b,
1 IS NOT DISTINCT FROM CAST(NULL as INT) as c,
1 IS NOT DISTINCT FROM 1 as d,
NULL IS DISTINCT FROM NULL as e,
NULL IS NOT DISTINCT FROM NULL as f,
NULL is DISTINCT FROM 1 as g,
NULL is NOT DISTINCT FROM 1 as h
----
true false false true false true true false

query BBBBBBBB
select
NULL IS DISTINCT FROM NULL as a,
NULL IS NOT DISTINCT FROM NULL as b,
NULL is DISTINCT FROM 1 as c,
NULL is NOT DISTINCT FROM 1 as d,
1 IS DISTINCT FROM CAST(NULL as INT) as e,
1 IS DISTINCT FROM 1 as f,
1 IS NOT DISTINCT FROM CAST(NULL as INT) as g,
1 IS NOT DISTINCT FROM 1 as h
----
false true true false true false false true

# select distinct from utf8
query BBBB
select
'x' IS DISTINCT FROM NULL as a,
'x' IS DISTINCT FROM 'x' as b,
'x' IS NOT DISTINCT FROM NULL as c,
'x' IS NOT DISTINCT FROM 'x' as d
----
true false false true

# select between simple expression
query B
SELECT 1 NOT BETWEEN 3 AND 5
----
true


statement ok
create table select_between_data(c1 bigint) as values (1), (2), (3), (4);

# select between complex expression

query B
SELECT abs(c1) BETWEEN 0 AND LoG(c1 * 100 ) FROM select_between_data ORDER BY c1
----
true
true
false
false

# explain select between
query TT
EXPLAIN SELECT c1 BETWEEN 2 AND 3 FROM select_between_data
----
logical_plan
01)Projection: select_between_data.c1 >= Int64(2) AND select_between_data.c1 <= Int64(3) AS select_between_data.c1 BETWEEN Int64(2) AND Int64(3)
02)--TableScan: select_between_data projection=[c1]
physical_plan
01)ProjectionExec: expr=[c1@0 >= 2 AND c1@0 <= 3 as select_between_data.c1 BETWEEN Int64(2) AND Int64(3)]
02)--DataSourceExec: partitions=1, partition_sizes=[1]


# TODO: query_get_indexed_field

# TODO: query_nested_get_indexed_field

# TODO: query_nested_get_indexed_field_on_struct

# TODO: query_on_string_dictionary

# TODO: sort_on_window_null_string


# # Create time tables with different precisions but the same logical values

statement ok
create table time_data(ts bigint, value bigint) as values
  (5000000000000, 2505),
  (5000000000000, 2436),
  (5500000000000, 2384),
  (5500000000000, 1815),
  (5900000000000, 2330),
  (5900000000000, 2065);

statement ok
create table time64_nanos as
select arrow_cast(ts, 'Time64(Nanosecond)') as time, value
from time_data;

statement ok
create table time64_micros as
select arrow_cast(ts / 1000, 'Time64(Microsecond)') as time, value
from time_data;

statement ok
create table time32_millis as
select arrow_cast(arrow_cast(ts / 1000 / 1000, 'Int32'), 'Time32(Millisecond)') as time, value
from time_data;

statement ok
create table time32_s as
select arrow_cast(arrow_cast(ts / 1000 / 1000 / 1000, 'Int32'), 'Time32(Second)') as time, value
from time_data;

# select with time filter and seconds precision
query I rowsort
SELECT value FROM time32_s WHERE time = '01:23:20'
----
2436
2505

# select with time filter and milliseconds precision
query I rowsort
SELECT value FROM time32_millis WHERE time = '01:23:20'
----
2436
2505

# select with time filter and microseconds precision
query I rowsort
SELECT value FROM time64_micros WHERE time = '01:23:20'
----
2436
2505

# select with time filter and nanoseconds precision
query I rowsort
SELECT value FROM time64_nanos WHERE time = '01:23:20'
----
2436
2505


# query cte with alias
# the purpose of this test is just to make sure the query produces a valid plan
statement ok
create table t1(id smallint, a smallint);

query III
WITH
    v1 AS (SELECT * FROM t1),
    v2 AS (SELECT v1.id AS id, v1a.id AS id_a, v1b.id AS id_b
FROM v1, v1 v1a, v1 v1b
WHERE v1a.id = v1.id - 1
  AND v1b.id = v1.id + 1)
SELECT * FROM v2
----

# query cte
query I
WITH t AS (SELECT 1) SELECT * FROM t
----
1

# query cte + union
query I rowsort
WITH t AS (SELECT 1 AS a), u AS (SELECT 2 AS a)
SELECT * FROM t
UNION ALL
SELECT * FROM u
----
1
2

# query cte + join
query I
WITH t AS (SELECT 1 AS id1), u AS (SELECT 1 AS id2, 5 as x)
SELECT x
FROM t
JOIN u ON (id1 = id2)
----
5

# query cte with backward reference
query I
WITH t AS (SELECT 1 AS id1), u AS (SELECT * FROM t) SELECT * from u
----
1

# nested select
query TII
SELECT o1, o2, c3
FROM (
    SELECT c1 AS o1, c2 + 1 AS o2, c3
    FROM (
        SELECT c1, c2, c3, c4
        FROM aggregate_test_100
        WHERE c1 = 'a' AND c2 >= 4
        ORDER BY c2 ASC, c3 ASC
    ) AS a
) AS b
----
a 5 -38
a 5 -54
a 6 36
a 6 -31
a 5 65
a 5 -101
a 6 -101

# nested select without aliases
query TII
SELECT o1, o2, c3
FROM (
    SELECT c1 AS o1, c2 + 1 AS o2, c3
    FROM (
        SELECT c1, c2, c3, c4
        FROM aggregate_test_100
        WHERE c1 = 'a' AND c2 >= 4
        ORDER BY c2 ASC, c3 ASC
    )
)
----
a 5 -38
a 5 -54
a 6 36
a 6 -31
a 5 65
a 5 -101
a 6 -101

# select with join unaliased subqueries
query TIITII
SELECT o1, o2, c3, p1, p2, p3
FROM
    (SELECT c1 AS o1, c2 + 1 AS o2, c3 FROM aggregate_test_100),
    (SELECT c1 AS p1, c2 - 1 AS p2, c3 AS p3 FROM aggregate_test_100)
LIMIT 5
----
c 3 1 c 1 1
c 3 1 d 4 -40
c 3 1 b 0 29
c 3 1 a 0 -85
c 3 1 b 4 -82

# TODO: test_prepare_statement

# TODO: parallel_query_with_filter


# query with filter string type coercion

statement ok
create table utf8_data(str string) as values ('1'), ('2'), ('3'), ('4'), ('5');

statement ok
create table largeutf8_data as
select arrow_cast(str, 'LargeUtf8') as large_str
from utf8_data;

query T
select * from largeutf8_data where large_str = '1'
----
1

query T
select * from largeutf8_data where large_str != '1'
----
2
3
4
5


# query empty table
statement ok
CREATE TABLE empty_table;

statement ok
SELECT * FROM empty_table


# TODO: boolean_literal

# TODO: unprojected_filter


# case sensitive in default dialect

statement ok
CREATE TABLE case_sensitive_table("INT32" int) AS VALUES (1), (2), (3), (4), (5);

statement error DataFusion error: Schema error: No field named int32\. Valid fields are case_sensitive_table\."INT32"\.
select "int32" from case_sensitive_table

query I
select "INT32" from case_sensitive_table;
----
1
2
3
4
5

# Columns in the table are a,b,c,d. Source is DataSourceExec which is ordered by
# a,b,c column. Column a has cardinality 2, column b has cardinality 4.
# Column c has cardinality 100 (unique entries). Column d has cardinality 5.
statement ok
CREATE EXTERNAL TABLE annotated_data_finite2 (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH ORDER (a ASC, b ASC, c ASC)
LOCATION '../core/tests/data/window_2.csv'
OPTIONS ('format.has_header' 'true');

# test_source_projection


#  Final plan shouldn't include SortExec.
query TT
EXPLAIN SELECT a FROM annotated_data_finite2
        ORDER BY a
        LIMIT 5
----
logical_plan
01)Sort: annotated_data_finite2.a ASC NULLS LAST, fetch=5
02)--TableScan: annotated_data_finite2 projection=[a]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a], limit=5, output_ordering=[a@0 ASC NULLS LAST], file_type=csv, has_header=true

query I
SELECT a FROM annotated_data_finite2
        ORDER BY a
        LIMIT 5
----
0
0
0
0
0

# create a table to test SELECT * EXCLUDE, SELECT * EXCEPT syntax
statement ok
CREATE TABLE table1 (
  a int,
  b int,
  c int,
  d int
) as values
  (1, 10, 100, 1000),
  (2, 20, 200, 2000);

# Below query should emit all the columns except a and b
# The syntax is as follows: `SELECT * EXCLUDE(<col_name>, ...)`
# when only single column is excluded, we can either use
# `EXCLUDE <col_name>` or `EXCLUDE(<col_name>)` syntax
query II
SELECT * EXCLUDE(b) FROM (
  SELECT * EXCLUDE a
    FROM table1
    ORDER BY c
    LIMIT 5
  )
----
100 1000
200 2000

# Below query should emit all the columns except a and b
# To exclude some columns, we can use except clause also,
# the behavior is similar to EXCLUDE clause.
# The syntax is as follows: `SELECT * EXCEPT(<col_name>, ...)`
query II
SELECT * EXCEPT(a, b)
FROM table1
ORDER BY c
LIMIT 5
----
100 1000
200 2000

# below query should emit all the columns except a and b
query II
SELECT * EXCLUDE(a, b)
FROM table1
ORDER BY c
LIMIT 5
----
100 1000
200 2000

# when wildcard is prepended with table name, exclude should still work
# below query should emit all the columns except a and b
query II
SELECT table1.* EXCLUDE(a, b)
FROM table1
ORDER BY c
LIMIT 5
----
100 1000
200 2000

# Trying to exclude non-existing column should give error
statement error
SELECT * EXCLUDE e
FROM table1

# similarly, except should raise error if excluded column is not in the table
statement error
SELECT * EXCEPT(e)
FROM table1

# EXCEPT, or EXCLUDE can only be used after wildcard *
# below query should give 4 columns, a1, b1, b, c, d
query IIIII
SELECT a as a1, b as b1, * EXCEPT(a)
FROM table1
----
1 10 10 100 1000
2 20 20 200 2000

# EXCEPT, or EXCLUDE shouldn't contain duplicate column names
statement error
SELECT * EXCLUDE(a, a)
FROM table1

# if EXCEPT all the columns, query should still succeed but return empty
statement ok
SELECT * EXCEPT(a, b, c, d)
FROM table1

# try zero column with LIMIT, 1 row but empty
statement ok
SELECT * EXCEPT (a, b, c, d)
FROM table1
LIMIT 1

# try zero column with GROUP BY, 2 row but empty
statement ok
SELECT * EXCEPT (a, b, c, d)
FROM table1
GROUP BY a

# try zero column with WHERE, 1 row but empty
statement ok
SELECT * EXCEPT (a, b, c, d)
FROM table1
WHERE a = 1

# create table2 the same with table1
statement ok
CREATE TABLE table2 (
  a int,
  b int,
  c int,
  d int
) as values
  (1, 10, 100, 1000),
  (2, 20, 200, 2000);

# try zero column with inner JOIN, 2 row but empty
statement ok
WITH t1 AS (SELECT a AS t1_a FROM table1), t2 AS (SELECT a AS t2_a FROM table2)
SELECT * EXCEPT (t1_a, t2_a)
FROM t1
JOIN t2 ON (t1_a = t2_a)

# try zero column with more JOIN, 2 row but empty
statement ok
SELECT * EXCEPT (b1, b2)
FROM (
  SELECT b AS b1 FROM table1
)
JOIN (
  SELECT b AS b2 FROM table2
) ON b1 = b2

# try zero column with Window, 2 row but empty
statement ok
SELECT * EXCEPT (a, b, row_num)
FROM (
    SELECT
        a,
        b,
        ROW_NUMBER() OVER (ORDER BY b) AS row_num
    FROM table1
)

# EXCLUDE order shouldn't matter
query II
SELECT * EXCLUDE(b, a)
FROM table1
ORDER BY c
LIMIT 5
----
100 1000
200 2000

# EXCLUDE with out of order but duplicate columns should error
statement error DataFusion error: Error during planning: EXCLUDE or EXCEPT contains duplicate column names
SELECT * EXCLUDE(d, b, c, a, a, b, c, d)
FROM table1

# avoiding adding an alias if the column name is the same
query TT
EXPLAIN select a as a FROM table1 order by a
----
logical_plan
01)Sort: table1.a ASC NULLS LAST
02)--TableScan: table1 projection=[a]
physical_plan
01)SortExec: expr=[a@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

# ambiguous column references in on join
query error DataFusion error: Schema error: Ambiguous reference to unqualified field a
EXPLAIN select a as a FROM table1 t1 CROSS JOIN table1 t2 order by a

# run below query in multi partitions
statement ok
set datafusion.execution.target_partitions = 2;

# since query below contains computation
# inside projection expr, increasing partitions
# is beneficial
query TT
EXPLAIN SELECT a, a+b
FROM annotated_data_finite2
ORDER BY a ASC;
----
logical_plan
01)Sort: annotated_data_finite2.a ASC NULLS LAST
02)--Projection: annotated_data_finite2.a, annotated_data_finite2.a + annotated_data_finite2.b
03)----TableScan: annotated_data_finite2 projection=[a, b]
physical_plan
01)SortPreservingMergeExec: [a@0 ASC NULLS LAST]
02)--ProjectionExec: expr=[a@0 as a, a@0 + b@1 as annotated_data_finite2.a + annotated_data_finite2.b]
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST], file_type=csv, has_header=true

# since query below doesn't computation
# inside projection expr, increasing partitions
# is not beneficial. Hence plan doesn't contain
# RepartitionExec
query TT
EXPLAIN SELECT a, b, 2
FROM annotated_data_finite2
ORDER BY a ASC;
----
logical_plan
01)Sort: annotated_data_finite2.a ASC NULLS LAST
02)--Projection: annotated_data_finite2.a, annotated_data_finite2.b, Int64(2)
03)----TableScan: annotated_data_finite2 projection=[a, b]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b, 2 as Int64(2)], output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST], file_type=csv, has_header=true

# source is ordered by a,b,c
# when filter result is constant for column a
# ordering b, c is still satisfied. Final plan shouldn't have
# SortExec.
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE a=0
ORDER BY b, c;
----
logical_plan
01)Sort: annotated_data_finite2.b ASC NULLS LAST, annotated_data_finite2.c ASC NULLS LAST
02)--Filter: annotated_data_finite2.a = Int32(0)
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[annotated_data_finite2.a = Int32(0)]
physical_plan
01)SortPreservingMergeExec: [b@2 ASC NULLS LAST, c@3 ASC NULLS LAST]
02)--FilterExec: a@1 = 0
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# source is ordered by a,b,c
# when filter result is constant for column a and b
# ordering c is still satisfied. Final plan shouldn't have
# SortExec.
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE a=0 and b=0
ORDER BY c;
----
logical_plan
01)Sort: annotated_data_finite2.c ASC NULLS LAST
02)--Filter: annotated_data_finite2.a = Int32(0) AND annotated_data_finite2.b = Int32(0)
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[annotated_data_finite2.a = Int32(0), annotated_data_finite2.b = Int32(0)]
physical_plan
01)SortPreservingMergeExec: [c@3 ASC NULLS LAST]
02)--FilterExec: a@1 = 0 AND b@2 = 0
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# source is ordered by a,b,c
# when filter result is constant for column a and b
# ordering b, c is still satisfied. Final plan shouldn't have
# SortExec.
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE a=0 and b=0
ORDER BY b, c;
----
logical_plan
01)Sort: annotated_data_finite2.b ASC NULLS LAST, annotated_data_finite2.c ASC NULLS LAST
02)--Filter: annotated_data_finite2.a = Int32(0) AND annotated_data_finite2.b = Int32(0)
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[annotated_data_finite2.a = Int32(0), annotated_data_finite2.b = Int32(0)]
physical_plan
01)SortPreservingMergeExec: [b@2 ASC NULLS LAST, c@3 ASC NULLS LAST]
02)--FilterExec: a@1 = 0 AND b@2 = 0
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# source is ordered by a,b,c
# when filter result is constant for column a and b
# ordering a, b, c is still satisfied. Final plan shouldn't have
# SortExec.
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE a=0 and b=0
ORDER BY a, b, c;
----
logical_plan
01)Sort: annotated_data_finite2.a ASC NULLS LAST, annotated_data_finite2.b ASC NULLS LAST, annotated_data_finite2.c ASC NULLS LAST
02)--Filter: annotated_data_finite2.a = Int32(0) AND annotated_data_finite2.b = Int32(0)
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[annotated_data_finite2.a = Int32(0), annotated_data_finite2.b = Int32(0)]
physical_plan
01)SortPreservingMergeExec: [a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST]
02)--FilterExec: a@1 = 0 AND b@2 = 0
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# source is ordered by a,b,c
# when filter result is when filter contains or
# column a, and b may not be constant. Hence final plan
# should contain SortExec
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE a=0 or b=0
ORDER BY c;
----
logical_plan
01)Sort: annotated_data_finite2.c ASC NULLS LAST
02)--Filter: annotated_data_finite2.a = Int32(0) OR annotated_data_finite2.b = Int32(0)
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[annotated_data_finite2.a = Int32(0) OR annotated_data_finite2.b = Int32(0)]
physical_plan
01)SortPreservingMergeExec: [c@3 ASC NULLS LAST]
02)--SortExec: expr=[c@3 ASC NULLS LAST], preserve_partitioning=[true]
03)----FilterExec: a@1 = 0 OR b@2 = 0
04)------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true

# When ordering lost during projection, we shouldn't keep the SortExec.
# in the final physical plan.
query TT
EXPLAIN SELECT c2, COUNT(*)
FROM (SELECT c2
FROM aggregate_test_100
ORDER BY c1, c2
LIMIT 4)
GROUP BY c2;
----
logical_plan
01)Projection: aggregate_test_100.c2, count(Int64(1)) AS count(*)
02)--Aggregate: groupBy=[[aggregate_test_100.c2]], aggr=[[count(Int64(1))]]
03)----Projection: aggregate_test_100.c2
04)------Sort: aggregate_test_100.c1 ASC NULLS LAST, aggregate_test_100.c2 ASC NULLS LAST, fetch=4
05)--------Projection: aggregate_test_100.c2, aggregate_test_100.c1
06)----------TableScan: aggregate_test_100 projection=[c1, c2]
physical_plan
01)ProjectionExec: expr=[c2@0 as c2, count(Int64(1))@1 as count(*)]
02)--AggregateExec: mode=FinalPartitioned, gby=[c2@0 as c2], aggr=[count(Int64(1))]
03)----CoalesceBatchesExec: target_batch_size=8192
04)------RepartitionExec: partitioning=Hash([c2@0], 2), input_partitions=2
05)--------AggregateExec: mode=Partial, gby=[c2@0 as c2], aggr=[count(Int64(1))]
06)----------RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
07)------------ProjectionExec: expr=[c2@0 as c2]
08)--------------SortExec: TopK(fetch=4), expr=[c1@1 ASC NULLS LAST, c2@0 ASC NULLS LAST], preserve_partitioning=[false]
09)----------------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/testing/data/csv/aggregate_test_100.csv]]}, projection=[c2, c1], file_type=csv, has_header=true

# FilterExec can track equality of non-column expressions.
# plan below shouldn't have a SortExec because given column 'a' is ordered.
# 'CAST(ROUND(b) as INT)' is also ordered. After filter is applied.
query TT
EXPLAIN SELECT *
FROM annotated_data_finite2
WHERE CAST(ROUND(b) as INT) = a
ORDER BY CAST(ROUND(b) as INT);
----
logical_plan
01)Sort: CAST(round(CAST(annotated_data_finite2.b AS Float64)) AS Int32) ASC NULLS LAST
02)--Filter: CAST(round(CAST(annotated_data_finite2.b AS Float64)) AS Int32) = annotated_data_finite2.a
03)----TableScan: annotated_data_finite2 projection=[a0, a, b, c, d], partial_filters=[CAST(round(CAST(annotated_data_finite2.b AS Float64)) AS Int32) = annotated_data_finite2.a]
physical_plan
01)SortPreservingMergeExec: [CAST(round(CAST(b@2 AS Float64)) AS Int32) ASC NULLS LAST]
02)--FilterExec: CAST(round(CAST(b@2 AS Float64)) AS Int32) = a@1
03)----RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1, maintains_sort_order=true
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a0, a, b, c, d], output_ordering=[a@1 ASC NULLS LAST, b@2 ASC NULLS LAST, c@3 ASC NULLS LAST], file_type=csv, has_header=true


statement ok
drop table annotated_data_finite2;

statement ok
drop table t;

statement ok
create table t(x bigint, y bigint) as values (1,2), (1,3);

query II
select z+1, y from (select x+1 as z, y from t) where y > 1;
----
3 2
3 3

query TT
EXPLAIN SELECT x/2, x/2+1 FROM t;
----
logical_plan
01)Projection: __common_expr_1 AS t.x / Int64(2), __common_expr_1 AS t.x / Int64(2) + Int64(1)
02)--Projection: t.x / Int64(2) AS __common_expr_1
03)----TableScan: t projection=[x]
physical_plan
01)ProjectionExec: expr=[__common_expr_1@0 as t.x / Int64(2), __common_expr_1@0 + 1 as t.x / Int64(2) + Int64(1)]
02)--ProjectionExec: expr=[x@0 / 2 as __common_expr_1]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

query II
SELECT x/2, x/2+1 FROM t;
----
0 1
0 1

query TT
EXPLAIN SELECT abs(x), abs(x) + abs(y) FROM t;
----
logical_plan
01)Projection: __common_expr_1 AS abs(t.x), __common_expr_1 AS abs(t.x) + abs(t.y)
02)--Projection: abs(t.x) AS __common_expr_1, t.y
03)----TableScan: t projection=[x, y]
physical_plan
01)ProjectionExec: expr=[__common_expr_1@0 as abs(t.x), __common_expr_1@0 + abs(y@1) as abs(t.x) + abs(t.y)]
02)--ProjectionExec: expr=[abs(x@0) as __common_expr_1, y@1 as y]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

query II
SELECT abs(x), abs(x) + abs(y) FROM t;
----
1 3
1 4

statement ok
DROP TABLE t;

# related to https://github.com/apache/datafusion/issues/8814
statement ok
create table t(x int, y int) as values (1,1), (2,2), (3,3), (0,0), (4,0);

query II
SELECT
CASE WHEN B.x > 0 THEN A.x / B.x ELSE 0 END AS value1,
CASE WHEN B.x > 0 AND B.y > 0 THEN A.x / B.x ELSE 0 END AS value3
FROM t AS A, (SELECT * FROM t WHERE x = 0) AS B;
----
0 0
0 0
0 0
0 0
0 0

# Expressions that short circuit should not be refactored out as that may cause side effects (divide by zero)
# at plan time that would not actually happen during execution, so the follow three query should not be extract
# the common sub-expression
query TT
explain select coalesce(1, y/x), coalesce(2, y/x) from t;
----
logical_plan
01)Projection: Int64(1) AS coalesce(Int64(1),t.y / t.x), Int64(2) AS coalesce(Int64(2),t.y / t.x)
02)--TableScan: t projection=[]
physical_plan
01)ProjectionExec: expr=[1 as coalesce(Int64(1),t.y / t.x), 2 as coalesce(Int64(2),t.y / t.x)]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN SELECT y > 0 and 1 / y < 1, x > 0 and y > 0 and 1 / y < 1 / x from t;
----
logical_plan
01)Projection: __common_expr_1 AND Int64(1) / CAST(t.y AS Int64) < Int64(1) AS t.y > Int64(0) AND Int64(1) / t.y < Int64(1), t.x > Int32(0) AND __common_expr_1 AND Int64(1) / CAST(t.y AS Int64) < Int64(1) / CAST(t.x AS Int64) AS t.x > Int64(0) AND t.y > Int64(0) AND Int64(1) / t.y < Int64(1) / t.x
02)--Projection: t.y > Int32(0) AS __common_expr_1, t.x, t.y
03)----TableScan: t projection=[x, y]
physical_plan
01)ProjectionExec: expr=[__common_expr_1@0 AND 1 / CAST(y@2 AS Int64) < 1 as t.y > Int64(0) AND Int64(1) / t.y < Int64(1), x@1 > 0 AND __common_expr_1@0 AND 1 / CAST(y@2 AS Int64) < 1 / CAST(x@1 AS Int64) as t.x > Int64(0) AND t.y > Int64(0) AND Int64(1) / t.y < Int64(1) / t.x]
02)--ProjectionExec: expr=[y@1 > 0 as __common_expr_1, x@0 as x, y@1 as y]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

query TT
EXPLAIN SELECT y = 0 or 1 / y < 1, x = 0 or y = 0 or 1 / y < 1 / x from t;
----
logical_plan
01)Projection: __common_expr_1 OR Int64(1) / CAST(t.y AS Int64) < Int64(1) AS t.y = Int64(0) OR Int64(1) / t.y < Int64(1), t.x = Int32(0) OR __common_expr_1 OR Int64(1) / CAST(t.y AS Int64) < Int64(1) / CAST(t.x AS Int64) AS t.x = Int64(0) OR t.y = Int64(0) OR Int64(1) / t.y < Int64(1) / t.x
02)--Projection: t.y = Int32(0) AS __common_expr_1, t.x, t.y
03)----TableScan: t projection=[x, y]
physical_plan
01)ProjectionExec: expr=[__common_expr_1@0 OR 1 / CAST(y@2 AS Int64) < 1 as t.y = Int64(0) OR Int64(1) / t.y < Int64(1), x@1 = 0 OR __common_expr_1@0 OR 1 / CAST(y@2 AS Int64) < 1 / CAST(x@1 AS Int64) as t.x = Int64(0) OR t.y = Int64(0) OR Int64(1) / t.y < Int64(1) / t.x]
02)--ProjectionExec: expr=[y@1 = 0 as __common_expr_1, x@0 as x, y@1 as y]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

query II
select coalesce(1, y/x), coalesce(2, y/x) from t;
----
1 2
1 2
1 2
1 2
1 2

# due to the reason describe in https://github.com/apache/datafusion/issues/8927,
# the following queries will fail
query error
SELECT y > 0 and 1 / y < 1, x > 0 and y > 0 and 1 / y < 1 / x from t;

query error
SELECT y = 0 or 1 / y < 1, x = 0 or y = 0 or 1 / y < 1 / x from t;

statement ok
DROP TABLE t;

##########
## indexed_field_test
##########
statement ok
CREATE TABLE indexed_field
AS VALUES (make_array(0, 1, 2)),
(make_array(4, 5, 6)),
(make_array(7, 8, 9))

# query_get_indexed_field
query I
SELECT column1[1] AS i0
FROM indexed_field LIMIT 3;
----
0
4
7

##########
## nested_indexed_field_test
##########
statement ok
CREATE TABLE nested_indexed_field
AS VALUES (make_array([0, 1], [2, 3], [3, 4])),
(make_array([5, 6], [7, 8], [9, 10])),
(make_array([11, 12], [13, 14], [15, 16]))

# query nested_indexed_field
query ?
SELECT column1[1] AS i0
FROM nested_indexed_field LIMIT 3;
----
[0, 1]
[5, 6]
[11, 12]

query I
SELECT column1[1][1] AS i0
FROM nested_indexed_field LIMIT 3;
----
0
5
11

query I
SELECT CASE 1 WHEN 2 THEN 4 / 0 END;
----
NULL


######
# Unprojected filter
######

statement ok
CREATE TABLE test(i INT) AS
VALUES (1), (2), (3);

query I
SELECT i + i FROM test WHERE i > 2;
----
6

statement ok
DROP TABLE test;

query error DataFusion error: Arrow error: Parser error: Error parsing timestamp from 'I AM NOT A TIMESTAMP': error parsing date
SELECT to_timestamp('I AM NOT A TIMESTAMP');

query error DataFusion error: Optimizer rule 'simplify_expressions' failed[\s\S]*Arrow error: Cast error: Cannot cast string '' to value of Int32 type
SELECT CAST('' AS int);

# See issue: https://github.com/apache/datafusion/issues/8978
statement ok
create table users (id int, name varchar);

statement ok
insert into users values (1, 'Tom');

statement ok
create view v as select count(id) from users;

query I
select * from v;
----
1

query I
select count(1) from v;
----
1

# Ensure CSE resolves columns correctly
# should be 3, not 1
# https://github.com/apache/datafusion/issues/10413
query I
select a + b from (select 1 as a, 2 as b, 1 as "a + b");
----
3

# Can't reference an output column by expression over projection.
query error DataFusion error: Schema error: No field named a\. Valid fields are "a \+ Int64\(1\)"\.
select a + 1 from (select a+1 from (select 1 as a));

query I
select "a + Int64(1)" + 10 from (select a+1 from (select 1 as a));
----
12

# run below query without logical optimizations
statement ok
set datafusion.optimizer.max_passes=0;

statement ok
CREATE TABLE t(a int, b int);

query I
select a from t;
----

statement count 0
drop table t;

statement ok
set datafusion.optimizer.max_passes=3;

# Test issue: https://github.com/apache/datafusion/issues/12183
statement ok
CREATE TABLE test(a BIGINT) AS VALUES (1);

query I
SELECT "test.a" FROM (SELECT a AS "test.a" FROM test)
----
1

statement ok
DROP TABLE test;

# Can't reference an unqualified column by a qualified name
query error DataFusion error: Schema error: No field named t1\.v1\. Column names are case sensitive\. You can use double quotes to refer to the "t1\.v1" column or set the datafusion\.sql_parser\.enable_ident_normalization configuration\. Valid fields are "t1\.v1"\.
SELECT t1.v1 FROM (SELECT 1 AS "t1.v1");

# Test issue: https://github.com/apache/datafusion/issues/14124
query error DataFusion error: Arrow error: Arithmetic overflow: Overflow happened on: 10000 \* 100000000000000000000000000000000000
SELECT ('0.54321543215432154321543215432154321'::DECIMAL(35,35) + 10000)::VARCHAR

# where_selection_with_ambiguous_column
statement ok
CREATE TABLE t(a int, b int, id int);

query error DataFusion error: Schema error: Ambiguous reference to unqualified field id
select * from t a, t b where id = id + 1;

statement count 0
drop table t;


# test wildcard + other columns
statement count 0
create table t(a int) as values (1), (2), (3), (1);

query II
select *, count(*) over() as ta from t;
----
1 4
2 4
3 4
1 4

statement count 0
drop table t;

# test "user" column
# See https://github.com/apache/datafusion/issues/14141
statement count 0
create table t_with_user(a int, user text) as values (1,'test'), (2,null), (3,'foo');

query T
select t_with_user.user from t_with_user;
----
test
NULL
foo

query IT
select * from t_with_user where t_with_user.user = 'foo';
----
3 foo

query T
select user from t_with_user;
----
test
NULL
foo

query IT
select * from t_with_user where user = 'foo';
----
3 foo

# test "current_time" column
# See https://github.com/apache/datafusion/issues/14141
statement count 0
create table t_with_current_time(a int, current_time text) as values (1,'now'), (2,null), (3,'later');

# here it's clear the column was meant
query B
select t_with_current_time.current_time is not null from t_with_current_time;
----
true
false
true

# here it's the function
query B
select current_time is not null from t_with_current_time;
----
true
true
true

# and here it's the column again
query B
select "current_time" is not null from t_with_current_time;
----
true
false
true
