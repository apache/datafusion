# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#############
## Array Expressions Tests
#############

statement ok
set datafusion.sql_parser.dialect = databricks;

statement ok
CREATE TABLE tt
AS VALUES
([1, 50], 10),
([4, 50], 40);

statement ok
CREATE TABLE t AS SELECT 1 as f, [ [ [2, 3], [2] ], [ [1] ], [ [] ] ] as v, 1 as n;

query I?
SELECT t.n, array_transform([], e1 -> t.n) from t;
----
1 []

query ?
SELECT array_transform([1], e1 -> (select n from t));
----
[1]

query ?
SELECT array_transform(t.v, (v1, i) -> array_transform(v1, (v2, j) -> array_transform(v2, v3 -> j)) ) from t;
----
[[[0, 1], [0]], [[0]], [[]]]

query I?
SELECT t.n, array_transform([1, 2], (e) -> n) from t;
----
1 [1, 1]

# selection pushdown not working yet
query ?
SELECT array_transform([1, 2], (e) -> n) from t;
----
[1, 1]

query ?
SELECT array_transform([1, 2], (e, i) -> i) from t;
----
[0, 1]

# type coercion
query ?
SELECT array_transform([1, 2], (e, i) -> e+i) from t;
----
[1, 3]

query TT
EXPLAIN SELECT array_transform([1, 2], (e, i) -> e+i);
----
logical_plan
01)Projection: array_transform(List([1, 2]), (e, i) -> e + CAST(i AS Int64)) AS array_transform(make_array(Int64(1),Int64(2)),(e, i) -> e + i)
02)--EmptyRelation: rows=1
physical_plan
01)ProjectionExec: expr=[array_transform([1, 2], (e, i) -> e@-1 + CAST(i@-1 AS Int64)) as array_transform(make_array(Int64(1),Int64(2)),(e, i) -> e + i)]
02)--PlaceholderRowExec

#cse
query TT
explain select n + 1, array_transform([1], v -> v + n + 1) from t;
----
logical_plan
01)Projection: t.n + Int64(1), array_transform(List([1]), (v) -> v + t.n + Int64(1)) AS array_transform(make_array(Int64(1)),(v) -> v + t.n + Int64(1))
02)--TableScan: t projection=[n]
physical_plan
01)ProjectionExec: expr=[n@0 + 1 as t.n + Int64(1), array_transform([1], (v) -> v@-1 + n@0 + 1) as array_transform(make_array(Int64(1)),(v) -> v + t.n + Int64(1))]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

query ?
SELECT array_transform([1,2,3,4,5], v -> v*2);
----
[2, 4, 6, 8, 10]

query ?
SELECT array_transform([1,2,3,4,5], v -> 2);
----
[2, 2, 2, 2, 2]

query ?
SELECT array_transform([[1,2],[3,4,5]], v -> array_transform(v, v -> v*2));
----
[[2, 4], [6, 8, 10]]

query ?
SELECT array_transform([1,2,3,4,5], v -> repeat("a", v));
----
[a, aa, aaa, aaaa, aaaaa]

query ?
SELECT array_transform([1,2,3,4,5], v -> list_repeat("a", v));
----
[[a], [a, a], [a, a, a], [a, a, a, a], [a, a, a, a, a]]

query TT
EXPLAIN SELECT array_transform([1,2,3,4,5], v -> v*2);
----
logical_plan
01)Projection: array_transform(List([1, 2, 3, 4, 5]), (v) -> v * Int64(2)) AS array_transform(make_array(Int64(1),Int64(2),Int64(3),Int64(4),Int64(5)),(v) -> v * Int64(2))
02)--EmptyRelation: rows=1
physical_plan
01)ProjectionExec: expr=[array_transform([1, 2, 3, 4, 5], (v) -> v@-1 * 2) as array_transform(make_array(Int64(1),Int64(2),Int64(3),Int64(4),Int64(5)),(v) -> v * Int64(2))]
02)--PlaceholderRowExec

query ?
SELECT array_transform(
	[[1]],
	v -> array_concat(
		array_transform(v, v -> v),
		array_transform(v, v1 -> v1 + v[0])
	)
);
----
[[1, NULL]]

query I??
SELECT t.n, t.v, array_transform(t.v, (v, i) -> array_transform(v, (v, j) -> n) ) from t;
----
1 [[[2, 3], [2]], [[1]], [[]]] [[1, 1], [1], [1]]

query ?
SELECT array_transform([1,2,3,4,5], v -> v*2);
----
[2, 4, 6, 8, 10]


# expr simplifier
query TT
EXPLAIN SELECT v = v, array_transform([1], v -> v = v) from t;
----
logical_plan
01)Projection: Boolean(true) AS t.v = t.v, array_transform(List([1]), (v) -> v IS NOT NULL OR Boolean(NULL)) AS array_transform(make_array(Int64(1)),(v) -> v = v)
02)--TableScan: t projection=[]
physical_plan
01)ProjectionExec: expr=[true as t.v = t.v, array_transform([1], (v) -> v@-1 IS NOT NULL OR NULL) as array_transform(make_array(Int64(1)),(v) -> v = v)]
02)--DataSourceExec: partitions=1, partition_sizes=[1]


query error
select array_transform();
----
DataFusion error: Execution error: array_transform expects a value follewed by a lambda, got []


query error DataFusion error: Execution error: expected list, got Field \{ "Int64\(1\)": Int64 \}
select array_transform(1, v -> v*2);

query error DataFusion error: Execution error: array_transform expects a value follewed by a lambda, got \[Lambda, Value\(Field \{ name: "make_array\(Int64\(1\),Int64\(2\)\)", data_type: List\(Field \{ data_type: Int64, nullable: true \}\), nullable: true \}\)\]
select array_transform(v -> v*2, [1, 2]);

query error DataFusion error: Error during planning: lambda defined 3 params but UDF support only 2
SELECT array_transform([1, 2], (e, i, j) -> i) from t;

#todo: this should error due to duplicate names
query ?
SELECT array_transform([1], (v, v) -> v*2);
----
[0]
