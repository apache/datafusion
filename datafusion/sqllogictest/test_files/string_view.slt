# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

########
## Test setup
########

statement ok
create table test_source as values
  ('Andrew', 'X'),
  ('Xiangpeng', 'Xiangpeng'),
  ('Raphael', 'R'),
  (NULL, 'R');

# Table with the different combination of column types
statement ok
create table test as
SELECT
  arrow_cast(column1, 'Utf8') as column1_utf8,
  arrow_cast(column2, 'Utf8') as column2_utf8,
  arrow_cast(column1, 'LargeUtf8') as column1_large_utf8,
  arrow_cast(column2, 'LargeUtf8') as column2_large_utf8,
  arrow_cast(column1, 'Utf8View') as column1_utf8view,
  arrow_cast(column2, 'Utf8View') as column2_utf8view,
  arrow_cast(column1, 'Dictionary(Int32, Utf8)') as column1_dict,
  arrow_cast(column2, 'Dictionary(Int32, Utf8)') as column2_dict
FROM test_source;

statement ok
drop table test_source

statement ok
set datafusion.explain.logical_plan_only = true;

# || mixed types
# expect all results to be the same for each row as they all have the same values
query TTTTTTTT
SELECT
  column1_utf8view || column2_utf8view,
  column1_utf8 || column2_utf8view,
  column1_large_utf8 || column2_utf8view,
  column1_dict || column2_utf8view,
  -- reverse argument order
  column2_utf8view || column1_utf8view,
  column2_utf8view || column1_utf8,
  column2_utf8view || column1_large_utf8,
  column2_utf8view || column1_dict
FROM test;
----
AndrewX AndrewX AndrewX AndrewX XAndrew XAndrew XAndrew XAndrew
XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng
RaphaelR RaphaelR RaphaelR RaphaelR RRaphael RRaphael RRaphael RRaphael
NULL NULL NULL NULL NULL NULL NULL NULL

# || constants
# expect all results to be the same for each row as they all have the same values
query TTTTTTTT
SELECT
  column1_utf8view || 'foo',
  column1_utf8 || 'foo',
  column1_large_utf8 || 'foo',
  column1_dict || 'foo',
  -- reverse argument order
  'foo' || column1_utf8view,
  'foo' || column1_utf8,
  'foo' || column1_large_utf8,
  'foo' || column1_dict
FROM test;
----
Andrewfoo Andrewfoo Andrewfoo Andrewfoo fooAndrew fooAndrew fooAndrew fooAndrew
Xiangpengfoo Xiangpengfoo Xiangpengfoo Xiangpengfoo fooXiangpeng fooXiangpeng fooXiangpeng fooXiangpeng
Raphaelfoo Raphaelfoo Raphaelfoo Raphaelfoo fooRaphael fooRaphael fooRaphael fooRaphael
NULL NULL NULL NULL NULL NULL NULL NULL

# || same type (column1 has null, so also tests NULL || NULL)
# expect all results to be the same for each row as they all have the same values
query TTT
SELECT
  column1_utf8view || column1_utf8view,
  column1_utf8 || column1_utf8,
  column1_large_utf8 || column1_large_utf8
  -- Dictionary/Dictionary coercion doesn't work
  -- https://github.com/apache/datafusion/issues/12101
  --column1_dict || column1_dict
FROM test;
----
AndrewAndrew AndrewAndrew AndrewAndrew
XiangpengXiangpeng XiangpengXiangpeng XiangpengXiangpeng
RaphaelRaphael RaphaelRaphael RaphaelRaphael
NULL NULL NULL

## Ensure no casts for binary operators
## TODO: https://github.com/apache/datafusion/issues/12180
# `~` operator (regex match)
query TT
EXPLAIN SELECT
  column1_utf8view ~ 'an' AS c1
FROM test;
----
logical_plan
01)Projection: CAST(test.column1_utf8view AS Utf8) LIKE Utf8("%an%") AS c1
02)--TableScan: test projection=[column1_utf8view]

query B
SELECT
  column1_utf8view ~ 'an' AS c1
FROM test;
----
false
true
false
NULL

# `~*` operator (regex match case-insensitive)
query TT
EXPLAIN SELECT
  column1_utf8view ~* '^a.{3}e' AS c1
FROM test;
----
logical_plan
01)Projection: CAST(test.column1_utf8view AS Utf8) ~* Utf8("^a.{3}e") AS c1
02)--TableScan: test projection=[column1_utf8view]

query B
SELECT
  column1_utf8view ~* '^a.{3}e' AS c1
FROM test;
----
true
false
false
NULL

# `!~~` operator (not like match)
query TT
EXPLAIN SELECT
  column1_utf8view !~~ 'xia_g%g' AS c1
FROM test;
----
logical_plan
01)Projection: CAST(test.column1_utf8view AS Utf8) !~~ Utf8("xia_g%g") AS c1
02)--TableScan: test projection=[column1_utf8view]

query B
SELECT
  column1_utf8view !~~ 'xia_g%g' AS c1
FROM test;
----
true
true
true
NULL

# `!~~*` operator (not like match case-insensitive)
query TT
EXPLAIN SELECT
  column1_utf8view !~~* 'xia_g%g' AS c1
FROM test;
----
logical_plan
01)Projection: CAST(test.column1_utf8view AS Utf8) !~~* Utf8("xia_g%g") AS c1
02)--TableScan: test projection=[column1_utf8view]

query B
SELECT
  column1_utf8view !~~* 'xia_g%g' AS c1
FROM test;
----
true
false
true
NULL

statement ok
drop table test;

# coercion from stringview to integer, as input to make_date
query D
select make_date(arrow_cast('2024', 'Utf8View'), arrow_cast('01', 'Utf8View'), arrow_cast('23', 'Utf8View'))
----
2024-01-23

# coercions between stringview and date types
statement ok
create table dates (dt date) as values
    (date '2024-01-23'),
    (date '2023-11-30');

query D
select t.dt from dates t where arrow_cast('2024-01-01', 'Utf8View') < t.dt;
----
2024-01-23

statement ok
drop table dates;

### Tests for `||` with Utf8View specifically

statement ok
create table temp as values
('value1', arrow_cast('rust', 'Utf8View'), arrow_cast('fast', 'Utf8View')),
('value2', arrow_cast('datafusion', 'Utf8View'), arrow_cast('cool', 'Utf8View'));

query TTT
select arrow_typeof(column1), arrow_typeof(column2), arrow_typeof(column3) from temp;
----
Utf8 Utf8View Utf8View
Utf8 Utf8View Utf8View

query T
select column2||' is fast' from temp;
----
rust is fast
datafusion is fast

query T
select column2 || ' is ' || column3 from temp;
----
rust is fast
datafusion is cool

query TT
explain select column2 || 'is' || column3 from temp;
----
logical_plan
01)Projection: temp.column2 || Utf8View("is") || temp.column3 AS temp.column2 || Utf8("is") || temp.column3
02)--TableScan: temp projection=[column2, column3]

# should not cast the column2 to utf8
query TT
explain select column2||' is fast' from temp;
----
logical_plan
01)Projection: temp.column2 || Utf8View(" is fast") AS temp.column2 || Utf8(" is fast")
02)--TableScan: temp projection=[column2]


query T
select column2||column3 from temp;
----
rustfast
datafusioncool

query TT
explain select column2||column3 from temp;
----
logical_plan
01)Projection: temp.column2 || temp.column3
02)--TableScan: temp projection=[column2, column3]

query T
select column2|| ' ' ||column3 from temp;
----
rust fast
datafusion cool
