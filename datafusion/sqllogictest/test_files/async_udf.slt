
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

statement ok
create table data(x int) as values (-10), (2);

# Async udf can be used in aggregation
query I
select min(async_abs(x)) from data;
----
2

query TT
explain select min(async_abs(x)) from data;
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[min(async_abs(data.x))]]
02)--TableScan: data projection=[x]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[min(async_abs(data.x))]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[min(async_abs(data.x))]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------AsyncFuncExec: async_expr=[async_expr(name=__async_fn_0, expr=async_abs(x@0))]
06)----------DataSourceExec: partitions=1, partition_sizes=[1]

# Async udf can be used in aggregation with group by
query I rowsort
select min(async_abs(x)) from data group by async_abs(x);
----
10
2

query TT
explain select min(async_abs(x)) from data group by async_abs(x);
----
logical_plan
01)Projection: min(async_abs(data.x))
02)--Aggregate: groupBy=[[__common_expr_1 AS async_abs(data.x)]], aggr=[[min(__common_expr_1 AS async_abs(data.x))]]
03)----Projection: async_abs(data.x) AS __common_expr_1
04)------TableScan: data projection=[x]
physical_plan
01)ProjectionExec: expr=[min(async_abs(data.x))@1 as min(async_abs(data.x))]
02)--AggregateExec: mode=FinalPartitioned, gby=[async_abs(data.x)@0 as async_abs(data.x)], aggr=[min(async_abs(data.x))]
03)----RepartitionExec: partitioning=Hash([async_abs(data.x)@0], 4), input_partitions=4
04)------AggregateExec: mode=Partial, gby=[__common_expr_1@0 as async_abs(data.x)], aggr=[min(async_abs(data.x))]
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
06)----------ProjectionExec: expr=[__async_fn_0@1 as __common_expr_1]
07)------------AsyncFuncExec: async_expr=[async_expr(name=__async_fn_0, expr=async_abs(x@0))]
08)--------------DataSourceExec: partitions=1, partition_sizes=[1]

# Async udf can be used in filter
query I
select * from data where async_abs(x) < 5;
----
2

query TT
explain select * from data where async_abs(x) < 5;
----
logical_plan
01)Filter: async_abs(data.x) < Int32(5)
02)--TableScan: data projection=[x]
physical_plan
01)FilterExec: __async_fn_0@1 < 5, projection=[x@0]
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----AsyncFuncExec: async_expr=[async_expr(name=__async_fn_0, expr=async_abs(x@0))]
04)------DataSourceExec: partitions=1, partition_sizes=[1]

# Async udf can be used in projection
query I rowsort
select async_abs(x) from data;
----
10
2

query TT
explain select async_abs(x) from data;
----
logical_plan
01)Projection: async_abs(data.x)
02)--TableScan: data projection=[x]
physical_plan
01)ProjectionExec: expr=[__async_fn_0@1 as async_abs(data.x)]
02)--AsyncFuncExec: async_expr=[async_expr(name=__async_fn_0, expr=async_abs(x@0))]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

# Async udf with nesting
query I rowsort
select async_abs(async_abs(x)) from data;
----
10
2

