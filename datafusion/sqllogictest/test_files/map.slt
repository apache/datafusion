# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

statement ok
CREATE EXTERNAL TABLE data
STORED AS PARQUET
LOCATION '../core/tests/data/parquet_map.parquet';

# Show shape of data: 3 columns, 209 rows
query TTT
describe data;
----
ints Map(Field { name: "entries", data_type: Struct([Field { name: "key", data_type: Utf8, nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }, Field { name: "value", data_type: Int64, nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }]), nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }, false) NO
strings Map(Field { name: "entries", data_type: Struct([Field { name: "key", data_type: Utf8, nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }, Field { name: "value", data_type: Utf8, nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }]), nullable: false, dict_id: 0, dict_is_ordered: false, metadata: {} }, false) NO
timestamp Utf8 NO

query ??T
SELECT * FROM data ORDER by ints['bytes'] DESC LIMIT 10;
----
{bytes: 49960} {host: 21.169.210.169, method: GET, protocol: HTTP/1.1, referer: https://up.de/booper/bopper/mooper/mopper, request: /user/booperbot124, status: 500, user-identifier: shaneIxD} 06/Oct/2023:17:53:58
{bytes: 49689} {host: 244.231.56.81, method: PATCH, protocol: HTTP/2.0, referer: https://names.de/this/endpoint/prints/money, request: /controller/setup, status: 500, user-identifier: ahmadajmi} 06/Oct/2023:17:53:54
{bytes: 48768} {host: 127.152.34.105, method: POST, protocol: HTTP/1.1, referer: https://for.com/secret-info/open-sesame, request: /secret-info/open-sesame, status: 200, user-identifier: Karimmove} 06/Oct/2023:17:53:59
{bytes: 48574} {host: 121.67.176.60, method: POST, protocol: HTTP/2.0, referer: https://names.com/this/endpoint/prints/money, request: /apps/deploy, status: 401, user-identifier: benefritz} 06/Oct/2023:17:54:02
{bytes: 48274} {host: 39.37.198.203, method: DELETE, protocol: HTTP/1.0, referer: https://some.de/booper/bopper/mooper/mopper, request: /secret-info/open-sesame, status: 550, user-identifier: ahmadajmi} 06/Oct/2023:17:54:00
{bytes: 47775} {host: 50.89.77.82, method: OPTION, protocol: HTTP/1.0, referer: https://random.com/observability/metrics/production, request: /controller/setup, status: 200, user-identifier: meln1ks} 06/Oct/2023:17:53:54
{bytes: 47557} {host: 108.242.133.203, method: OPTION, protocol: HTTP/2.0, referer: https://we.org/observability/metrics/production, request: /apps/deploy, status: 500, user-identifier: meln1ks} 06/Oct/2023:17:53:48
{bytes: 47552} {host: 206.248.141.240, method: HEAD, protocol: HTTP/1.1, referer: https://up.us/user/booperbot124, request: /wp-admin, status: 400, user-identifier: jesseddy} 06/Oct/2023:17:53:50
{bytes: 47342} {host: 110.222.38.8, method: HEAD, protocol: HTTP/2.0, referer: https://we.com/controller/setup, request: /do-not-access/needs-work, status: 301, user-identifier: ahmadajmi} 06/Oct/2023:17:53:59
{bytes: 47238} {host: 241.134.69.76, method: POST, protocol: HTTP/2.0, referer: https://up.de/do-not-access/needs-work, request: /controller/setup, status: 503, user-identifier: ahmadajmi} 06/Oct/2023:17:53:58

query I
SELECT COUNT(*) FROM data;
----
209

query I
SELECT SUM(ints['bytes']) FROM data;
----
5636785

query I
SELECT SUM(ints['bytes']) FROM data WHERE strings['method'] == 'GET';
----
649668

query TI
SELECT strings['method'] AS method, COUNT(*) as count FROM data GROUP BY method ORDER BY count DESC;
----
POST 41
HEAD 33
PATCH 30
OPTION 29
GET 27
PUT 25
DELETE 24

query T
SELECT strings['not_found'] FROM data LIMIT 1;
----
NULL

# Select non existent key, expect NULL for each row
query I
SELECT COUNT(CASE WHEN strings['not_found'] IS NULL THEN 1 ELSE 0 END) FROM data;
----
209

statement ok
drop table data;

query I?
select * from table_with_map where int_field > 0;
----

# Testing explain on a table with a map filter, registered in test_context.rs.
query TT
explain select * from table_with_map where int_field > 0;
----
logical_plan
01)Filter: table_with_map.int_field > Int64(0)
02)--TableScan: table_with_map projection=[int_field, map_field]
physical_plan
01)CoalesceBatchesExec: target_batch_size=8192
02)--FilterExec: int_field@0 > 0
03)----MemoryExec: partitions=1, partition_sizes=[0]

statement ok
drop table table_with_map;

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 33, 'PATCH', 30, 'OPTION', 29, 'GET', 27, 'PUT', 25, 'DELETE', 24) AS method_count;
----
{POST: 41, HEAD: 33, PATCH: 30, OPTION: 29, GET: 27, PUT: 25, DELETE: 24}

query I
SELECT MAKE_MAP('POST', 41, 'HEAD', 33)['POST'];
----
41

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 33, 'PATCH', null);
----
{POST: 41, HEAD: 33, PATCH: }

query ?
SELECT MAKE_MAP('POST', null, 'HEAD', 33, 'PATCH', null);
----
{POST: , HEAD: 33, PATCH: }

query ?
SELECT MAKE_MAP(1, null, 2, 33, 3, null);
----
{1: , 2: 33, 3: }

query ?
SELECT MAKE_MAP([1,2], ['a', 'b'], [3,4], ['b']);
----
{[1, 2]: [a, b], [3, 4]: [b]}

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 'ab', 'PATCH', 30);
----
{POST: 41, HEAD: ab, PATCH: 30}

query error
SELECT MAKE_MAP('POST', 41, 'HEAD', 33, null, 30);

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 'ab', 'PATCH', 30);
----
{POST: 41, HEAD: ab, PATCH: 30}

query ?
SELECT MAKE_MAP()
----
{}

query error
SELECT MAKE_MAP('POST', 41, 'HEAD');

query ?
SELECT MAP(['POST', 'HEAD', 'PATCH'], [41, 33, 30]);
----
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(['POST', 'HEAD', 'PATCH'], [41, 33, null]);
----
{POST: 41, HEAD: 33, PATCH: }

query ?
SELECT MAP([[1,2], [3,4]], ['a', 'b']);
----
{[1, 2]: a, [3, 4]: b}

query error
SELECT MAP()

query error DataFusion error: Execution error: map requires an even number of arguments, got 1 instead
SELECT MAP(['POST', 'HEAD'])

query error DataFusion error: Execution error: Expected list, large_list or fixed_size_list, got Null
SELECT MAP(null, [41, 33, 30]);

query error DataFusion error: Execution error: map requires key and value lists to have the same length
SELECT MAP(['POST', 'HEAD', 'PATCH'], [41, 33]);

query error DataFusion error: Execution error: map key cannot be null
SELECT MAP(['POST', 'HEAD', null], [41, 33, 30]);

query ?
SELECT MAP(make_array('POST', 'HEAD', 'PATCH'), make_array(41, 33, 30));
----
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(arrow_cast(make_array('POST', 'HEAD', 'PATCH'), 'FixedSizeList(3, Utf8)'), arrow_cast(make_array(41, 33, 30), 'FixedSizeList(3, Int64)'));
----
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(arrow_cast(make_array('POST', 'HEAD', 'PATCH'), 'LargeList(Utf8)'), arrow_cast(make_array(41, 33, 30), 'LargeList(Int64)'));
----
{POST: 41, HEAD: 33, PATCH: 30}

statement ok
create table t as values
('a', 1, 'k1', 10, ['k1', 'k2'], [1, 2]),
('b', 2, 'k3', 30, ['k3'], [3]),
('d', 4, 'k5', 50, ['k5'], [5]);

query error
SELECT make_map(column1, column2, column3, column4) FROM t;
# TODO: support array value
# ----
# {a: 1, k1: 10}
# {b: 2, k3: 30}
# {d: 4, k5: 50}

query error
SELECT map(column5, column6) FROM t;
# TODO: support array value
# ----
# {k1:1, k2:2}
# {k3: 3}
# {k5: 5}

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 33, 'PATCH', 30, 'OPTION', 29, 'GET', 27, 'PUT', 25, 'DELETE', 24) AS method_count from t;
----
{POST: 41, HEAD: 33, PATCH: 30, OPTION: 29, GET: 27, PUT: 25, DELETE: 24}
{POST: 41, HEAD: 33, PATCH: 30, OPTION: 29, GET: 27, PUT: 25, DELETE: 24}
{POST: 41, HEAD: 33, PATCH: 30, OPTION: 29, GET: 27, PUT: 25, DELETE: 24}

query I
SELECT MAKE_MAP('POST', 41, 'HEAD', 33)['POST']  from t;
----
41
41
41

query ?
SELECT MAKE_MAP('POST', 41, 'HEAD', 33, 'PATCH', null) from t;
----
{POST: 41, HEAD: 33, PATCH: }
{POST: 41, HEAD: 33, PATCH: }
{POST: 41, HEAD: 33, PATCH: }

query ?
SELECT MAKE_MAP('POST', null, 'HEAD', 33, 'PATCH', null) from t;
----
{POST: , HEAD: 33, PATCH: }
{POST: , HEAD: 33, PATCH: }
{POST: , HEAD: 33, PATCH: }

query ?
SELECT MAKE_MAP(1, null, 2, 33, 3, null) from t;
----
{1: , 2: 33, 3: }
{1: , 2: 33, 3: }
{1: , 2: 33, 3: }

query ?
SELECT MAKE_MAP([1,2], ['a', 'b'], [3,4], ['b']) from t;
----
{[1, 2]: [a, b], [3, 4]: [b]}
{[1, 2]: [a, b], [3, 4]: [b]}
{[1, 2]: [a, b], [3, 4]: [b]}

query ?
SELECT MAP(['POST', 'HEAD', 'PATCH'], [41, 33, 30]) from t;
----
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(['POST', 'HEAD', 'PATCH'], [41, 33, null]) from t;
----
{POST: 41, HEAD: 33, PATCH: }
{POST: 41, HEAD: 33, PATCH: }
{POST: 41, HEAD: 33, PATCH: }

query ?
SELECT MAP([[1,2], [3,4]], ['a', 'b']) from t;
----
{[1, 2]: a, [3, 4]: b}
{[1, 2]: a, [3, 4]: b}
{[1, 2]: a, [3, 4]: b}

query ?
SELECT MAP(make_array('POST', 'HEAD', 'PATCH'), make_array(41, 33, 30)) from t;
----
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(arrow_cast(make_array('POST', 'HEAD', 'PATCH'), 'FixedSizeList(3, Utf8)'), arrow_cast(make_array(41, 33, 30), 'FixedSizeList(3, Int64)'))  from t;
----
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}

query ?
SELECT MAP(arrow_cast(make_array('POST', 'HEAD', 'PATCH'), 'LargeList(Utf8)'), arrow_cast(make_array(41, 33, 30), 'LargeList(Int64)')) from t;
----
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}
{POST: 41, HEAD: 33, PATCH: 30}


query ?
VALUES (MAP(['a'], [1])), (MAP(['b'], [2])), (MAP(['c', 'a'], [3, 1]))
----
{a: 1}
{b: 2}
{c: 3, a: 1}

query ?
SELECT MAP {'a':1, 'b':2, 'c':3};
----
{a: 1, b: 2, c: 3}

query ?
SELECT MAP {'a':1, 'b':2, 'c':3 } FROM t;
----
{a: 1, b: 2, c: 3}
{a: 1, b: 2, c: 3}
{a: 1, b: 2, c: 3}

query I
SELECT MAP {'a':1, 'b':2, 'c':3}['a'];
----
1

query I
SELECT MAP {'a':1, 'b':2, 'c':3 }['a'] FROM t;
----
1
1
1

# TODO(https://github.com/sqlparser-rs/sqlparser-rs/pull/1361): support parsing an empty map. Enable this after upgrading sqlparser-rs.
# query ?
# SELECT MAP {};
# ----
# {}

# values contain null
query ?
SELECT MAP {'a': 1, 'b': null};
----
{a: 1, b: }

# keys contain null
query error DataFusion error: Execution error: map key cannot be null
SELECT MAP {'a': 1, null: 2}

# array as key
query ?
SELECT MAP {[1,2,3]:1, [2,4]:2};
----
 {[1, 2, 3]: 1, [2, 4]: 2}

# array with different type as key
# expect to fail due to type coercion error
query error
SELECT MAP {[1,2,3]:1, ['a', 'b']:2};

# array as value
query ?
SELECT MAP {'a':[1,2,3], 'b':[2,4]};
----
{a: [1, 2, 3], b: [2, 4]}

# array with different type as value
# expect to fail due to type coercion error
query error
SELECT MAP {'a':[1,2,3], 'b':['a', 'b']};

# struct as key
query ?
SELECT MAP {{'a':1, 'b':2}:1, {'a':3, 'b':4}:2};
----
{{a: 1, b: 2}: 1, {a: 3, b: 4}: 2}

# struct with different fields as key
# expect to fail due to type coercion error
query error
SELECT MAP {{'a':1, 'b':2}:1, {'c':3, 'd':4}:2};

# struct as value
query ?
SELECT MAP {'a':{'b':1, 'c':2}, 'b':{'b':3, 'c':4}};
----
{a: {b: 1, c: 2}, b: {b: 3, c: 4}}

# struct with different fields as value
# expect to fail due to type coercion error
query error
SELECT MAP {'a':{'b':1, 'c':2}, 'b':{'c':3, 'd':4}};

# map as key
query ?
SELECT MAP { MAP {1:'a', 2:'b'}:1, MAP {1:'c', 2:'d'}:2 };
----
{{1: a, 2: b}: 1, {1: c, 2: d}: 2}

# map with different keys as key
query ?
SELECT MAP { MAP {1:'a', 2:'b', 3:'c'}:1, MAP {2:'c', 4:'d'}:2 };
----
 {{1: a, 2: b, 3: c}: 1, {2: c, 4: d}: 2}

# map as value
query ?
SELECT MAP {1: MAP {1:'a', 2:'b'}, 2: MAP {1:'c', 2:'d'} };
----
{1: {1: a, 2: b}, 2: {1: c, 2: d}}

# map with different keys as value
query ?
SELECT MAP {'a': MAP {1:'a', 2:'b', 3:'c'}, 'b': MAP {2:'c', 4:'d'} };
----
{a: {1: a, 2: b, 3: c}, b: {2: c, 4: d}}

# complex map for each row
query ?
SELECT MAP {'a': MAP {1:'a', 2:'b', 3:'c'}, 'b': MAP {2:'c', 4:'d'} } from t;
----
{a: {1: a, 2: b, 3: c}, b: {2: c, 4: d}}
{a: {1: a, 2: b, 3: c}, b: {2: c, 4: d}}
{a: {1: a, 2: b, 3: c}, b: {2: c, 4: d}}

# access map with non-existent key
query ?
SELECT MAP {'a': MAP {1:'a', 2:'b', 3:'c'}, 'b': MAP {2:'c', 4:'d'} }['c'];
----
NULL

# access map with null key
query error
SELECT MAP {'a': MAP {1:'a', 2:'b', 3:'c'}, 'b': MAP {2:'c', 4:'d'} }[NULL];

query ?
SELECT MAP { 'a': 1, 2: 3 };
----
{a: 1, 2: 3}

# TODO(https://github.com/apache/datafusion/issues/11785): fix accessing map with non-string key
# query ?
# SELECT MAP { 1: 'a', 2: 'b', 3: 'c' }[1];
# ----
# a

# TODO(https://github.com/apache/datafusion/issues/11785): fix accessing map with non-string key
# query ?
# SELECT MAP { MAP {1:'a', 2:'b'}:1, MAP {1:'c', 2:'d'}:2 }[MAP {1:'a', 2:'b'}];
# ----
# 1

# TODO(https://github.com/apache/datafusion/issues/11785): fix accessing map with non-string key
# query ?
# SELECT MAKE_MAP(1, null, 2, 33, 3, null)[2];
# ----
# 33

## cardinality

# cardinality scalar function
query IIII
select cardinality(map([1, 2, 3], ['a', 'b', 'c'])), cardinality(MAP {'a': 1, 'b': null}), cardinality(MAP([],[])),
       cardinality(MAP {'a': MAP {1:'a', 2:'b', 3:'c'}, 'b': MAP {2:'c', 4:'d'} });
----
3 2 0 2
