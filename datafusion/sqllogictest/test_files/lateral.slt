# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
## LATERAL Table Functions Tests
## Tests for LATERAL keyword with batched table functions
##########

statement ok
CREATE TABLE ranges (start_val INT, end_val INT);

statement ok
INSERT INTO ranges VALUES (1, 3), (5, 7), (10, 12);

# The 'batched_generate_series' function is registered in the test runner.
# It generates integers from start to stop (inclusive).

##########
## Standalone: Direct table function calls with constants
##########

query I
SELECT * FROM batched_generate_series(1, 5)
ORDER BY value
----
1
2
3
4
5

query I
SELECT COUNT(*) FROM batched_generate_series(1, 100)
----
100

query II
SELECT a.value, b.value
FROM batched_generate_series(1, 2) a
CROSS JOIN batched_generate_series(3, 4) b
ORDER BY a.value, b.value
----
1 3
1 4
2 3
2 4

query I
SELECT series.value FROM batched_generate_series(5, 7) AS series
ORDER BY value
----
5
6
7

##########
## Basic LATERAL functionality
##########

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY ranges.start_val, value
----
1 1
1 2
1 3
5 5
5 6
5 7
10 10
10 11
10 12

query III
SELECT *
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY start_val, end_val, value
----
1 3 1
1 3 2
1 3 3
5 7 5
5 7 6
5 7 7
10 12 10
10 12 11
10 12 12

query I
SELECT value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY value
----
1
2
3
5
6
7
10
11
12

query II
SELECT start_val, end_val
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY start_val, value
----
1 3
1 3
1 3
5 7
5 7
5 7
10 12
10 12
10 12

##########
## LATERAL with filters
##########

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
WHERE start_val < 10
ORDER BY start_val, value
----
1 1
1 2
1 3
5 5
5 6
5 7

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
WHERE value > 6
ORDER BY start_val, value
----
5 7
10 10
10 11
10 12

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
WHERE start_val >= 5 AND value <= 7
ORDER BY start_val, value
----
5 5
5 6
5 7

##########
## LATERAL with aggregation
##########

query I
SELECT COUNT(*)
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
----
9

query I
SELECT SUM(value)
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
----
57

query II
SELECT start_val, COUNT(*)
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
GROUP BY start_val
ORDER BY start_val
----
1 3
5 3
10 3

query II
SELECT start_val, SUM(value)
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
GROUP BY start_val
ORDER BY start_val
----
1 6
5 18
10 33

query RII
SELECT AVG(value), MAX(value), COUNT(value)
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
----
6.333333333333 12 9

##########
## LATERAL with JOIN operations
##########

statement ok
CREATE TABLE multipliers (mult INT);

statement ok
INSERT INTO multipliers VALUES (2), (3);

query IIII
SELECT ranges.start_val, ranges.end_val, multipliers.mult, value
FROM ranges
CROSS JOIN multipliers
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
WHERE multipliers.mult = 2 AND start_val < 10
ORDER BY start_val, value
----
1 3 2 1
1 3 2 2
1 3 2 3
5 7 2 5
5 7 2 6
5 7 2 7

##########
## LATERAL with subqueries
##########

query II
SELECT sub.start_val, value
FROM (SELECT start_val, end_val FROM ranges WHERE start_val < 10) sub
CROSS JOIN LATERAL batched_generate_series(sub.start_val, sub.end_val)
ORDER BY sub.start_val, value
----
1 1
1 2
1 3
5 5
5 6
5 7

##########
## LATERAL with ORDER BY and LIMIT
##########

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY start_val DESC, value DESC
LIMIT 5
----
10 12
10 11
10 10
5 7
5 6

query II
SELECT ranges.start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY value ASC
LIMIT 5
----
1 1
1 2
1 3
5 5
5 6

##########
## LATERAL with aliases
##########

query II
SELECT r.start_val, s.value
FROM ranges r
CROSS JOIN LATERAL batched_generate_series(r.start_val, r.end_val) AS s
ORDER BY r.start_val, s.value
----
1 1
1 2
1 3
5 5
5 6
5 7
10 10
10 11
10 12

##########
## LATERAL with DISTINCT
##########

query I
SELECT DISTINCT value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY value
----
1
2
3
5
6
7
10
11
12

##########
## LATERAL with HAVING
##########

query II
SELECT start_val, COUNT(*) as row_count
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
GROUP BY start_val
HAVING COUNT(*) = 3
ORDER BY start_val
----
1 3
5 3
10 3

##########
## LATERAL with EXPLAIN
##########

statement ok
EXPLAIN SELECT * FROM ranges CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)

##########
## Edge cases
##########

statement ok
CREATE TABLE single_range (val INT);

statement ok
INSERT INTO single_range VALUES (5);

query II
SELECT val, value
FROM single_range
CROSS JOIN LATERAL batched_generate_series(single_range.val, single_range.val)
----
5 5

query II
SELECT start_val, value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
WHERE value > 100
----

##########
## Projection Pushdown Tests
##########

# Test that projection pushdown works with batched table functions
# The optimizer should push down the projection to only select the 'value' column

query I
SELECT value FROM batched_generate_series(1, 5)
ORDER BY value
----
1
2
3
4
5

# Test projection pushdown with LIMIT
query I
SELECT value FROM batched_generate_series(1, 100) LIMIT 3
----
1
2
3

##########
## Multi-Column Table Function Projection Tests
##########

# Standalone: projection of subset of columns from 5-column function
query II
SELECT n_squared, n_cubed FROM batched_multi_column(CAST(1 AS INT), CAST(3 AS INT))
ORDER BY n_squared
----
1 1
4 8
9 27

# Standalone: non-sequential column selection
query III
SELECT n, n_cubed, n_mod_3 FROM batched_multi_column(CAST(1 AS INT), CAST(5 AS INT))
ORDER BY n
----
1 1 1
2 8 2
3 27 0
4 64 1
5 125 2

# LATERAL: create test table
statement ok
CREATE TABLE test_lateral_multi (id INT, max_val INT);

statement ok
INSERT INTO test_lateral_multi VALUES (1, 2), (2, 3);

# LATERAL: projection of subset of columns
query III
SELECT id, n_squared, n_cubed
FROM test_lateral_multi
CROSS JOIN LATERAL batched_multi_column(CAST(1 AS INT), test_lateral_multi.max_val)
ORDER BY id, n_squared
----
1 1 1
1 4 8
2 1 1
2 4 8
2 9 27

# LATERAL: non-sequential column selection
query III
SELECT id, n, n_mod_3
FROM test_lateral_multi
CROSS JOIN LATERAL batched_multi_column(CAST(1 AS INT), test_lateral_multi.max_val)
ORDER BY id, n
----
1 1 1
1 2 2
2 1 1
2 2 2
2 3 0

# Test projection pushdown with LATERAL
query I
SELECT value
FROM ranges
CROSS JOIN LATERAL batched_generate_series(ranges.start_val, ranges.end_val)
ORDER BY value
LIMIT 5
----
1
2
3
5
6

##########
## Filter Pushdown Tests
##########

# Recreate ranges table for filter tests
statement ok
CREATE TABLE ranges_filter_test (start_val INT, end_val INT);

statement ok
INSERT INTO ranges_filter_test VALUES (1, 10), (5, 15), (10, 20);

# Verify filter handling in query plan - filters are not pushed down
query TT
EXPLAIN SELECT value
FROM batched_generate_series(1, 20)
WHERE value > 15 AND value < 18
----
logical_plan
01)Filter: batched_generate_series().value > Int64(15) AND batched_generate_series().value < Int64(18)
02)--StandaloneBatchedTableFunction: batched_generate_series(Int64(1), Int64(20)), projection=[0]
physical_plan
01)FilterExec: value@0 > 15 AND value@0 < 18
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----BatchedTableFunctionExec: function=batched_generate_series, args=[1, 20], projection=[0]
04)------PlaceholderRowExec

# Verify volatile filters stay as Filter operator
query TT
EXPLAIN SELECT value
FROM batched_generate_series(1, 20)
WHERE value > 15 AND random() > 0.5
----
logical_plan
01)Filter: batched_generate_series().value > Int64(15) AND random() > Float64(0.5)
02)--StandaloneBatchedTableFunction: batched_generate_series(Int64(1), Int64(20)), projection=[0]
physical_plan
01)FilterExec: value@0 > 15 AND random() > 0.5
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----BatchedTableFunctionExec: function=batched_generate_series, args=[1, 20], projection=[0]
04)------PlaceholderRowExec

# Verify LATERAL projection pushdown - since generate_series only has 1 column, projection not shown
# Note: Type coercion automatically adds CAST expressions to convert Int32 to Int64
query TT
EXPLAIN SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
----
logical_plan
01)Projection: ranges_filter_test.start_val, batched_generate_series().value
02)--LateralBatchedTableFunction: batched_generate_series(CAST(ranges_filter_test.start_val AS Int64), CAST(ranges_filter_test.end_val AS Int64))
03)----TableScan: ranges_filter_test projection=[start_val, end_val]
physical_plan
01)ProjectionExec: expr=[start_val@0 as start_val, value@2 as value]
02)--BatchedTableFunctionExec: function=batched_generate_series, args=[CAST(start_val@0 AS Int64), CAST(end_val@1 AS Int64)]
03)----DataSourceExec: partitions=1, partition_sizes=[1]

# Verify LATERAL filter handling - filters on table function output are not pushed down
query TT
EXPLAIN SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
WHERE value > 12
----
logical_plan
01)Filter: batched_generate_series().value > Int64(12)
02)--Projection: ranges_filter_test.start_val, batched_generate_series().value
03)----LateralBatchedTableFunction: batched_generate_series(CAST(ranges_filter_test.start_val AS Int64), CAST(ranges_filter_test.end_val AS Int64))
04)------TableScan: ranges_filter_test projection=[start_val, end_val]
physical_plan
01)FilterExec: value@1 > 12
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----ProjectionExec: expr=[start_val@0 as start_val, value@2 as value]
04)------BatchedTableFunctionExec: function=batched_generate_series, args=[CAST(start_val@0 AS Int64), CAST(end_val@1 AS Int64)]
05)--------DataSourceExec: partitions=1, partition_sizes=[1]

# Verify LATERAL filter NOT pushed down when referencing input columns
query TT
EXPLAIN SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
WHERE start_val > 5
----
logical_plan
01)Filter: ranges_filter_test.start_val > Int32(5)
02)--Projection: ranges_filter_test.start_val, batched_generate_series().value
03)----LateralBatchedTableFunction: batched_generate_series(CAST(ranges_filter_test.start_val AS Int64), CAST(ranges_filter_test.end_val AS Int64))
04)------TableScan: ranges_filter_test projection=[start_val, end_val]
physical_plan
01)FilterExec: start_val@0 > 5
02)--RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
03)----ProjectionExec: expr=[start_val@0 as start_val, value@2 as value]
04)------BatchedTableFunctionExec: function=batched_generate_series, args=[CAST(start_val@0 AS Int64), CAST(end_val@1 AS Int64)]
05)--------DataSourceExec: partitions=1, partition_sizes=[1]

# Test filter pushdown on table function output
query I
SELECT value
FROM batched_generate_series(1, 20)
WHERE value > 15
ORDER BY value
----
16
17
18
19
20

# Test filter pushdown with LATERAL - filter on function output
query II
SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
WHERE value > 12
ORDER BY start_val, value
----
5 13
5 14
5 15
10 13
10 14
10 15
10 16
10 17
10 18
10 19
10 20

# Test filter pushdown with LATERAL - filter on input table
query II
SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
WHERE start_val >= 5
ORDER BY start_val, value
----
5 5
5 6
5 7
5 8
5 9
5 10
5 11
5 12
5 13
5 14
5 15
10 10
10 11
10 12
10 13
10 14
10 15
10 16
10 17
10 18
10 19
10 20

# Test filter pushdown with multiple filters
query II
SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
WHERE start_val < 10 AND value >= 8 AND value <= 12
ORDER BY start_val, value
----
1 8
1 9
1 10
5 8
5 9
5 10
5 11
5 12

# Test filter pushdown with aggregation
query I
SELECT COUNT(*)
FROM batched_generate_series(1, 100)
WHERE value <= 10
----
10

##########
## Limit Pushdown Tests
##########

# Verify limit pushdown for StandaloneBatchedTableFunction
query TT
EXPLAIN SELECT value FROM batched_generate_series(1, 100) LIMIT 5
----
logical_plan
01)Limit: skip=0, fetch=5
02)--StandaloneBatchedTableFunction: batched_generate_series(Int64(1), Int64(100)), projection=[0]
physical_plan
01)GlobalLimitExec: skip=0, fetch=5
02)--BatchedTableFunctionExec: function=batched_generate_series, args=[1, 100], projection=[0]
03)----PlaceholderRowExec

# Test limit actually works
query I
SELECT value FROM batched_generate_series(1, 100) LIMIT 5
----
1
2
3
4
5

# Verify limit with LATERAL (limit stays above projection)
query TT
EXPLAIN SELECT start_val, value
FROM ranges_filter_test
CROSS JOIN LATERAL batched_generate_series(ranges_filter_test.start_val, ranges_filter_test.end_val)
LIMIT 3
----
logical_plan
01)Projection: ranges_filter_test.start_val, batched_generate_series().value
02)--Limit: skip=0, fetch=3
03)----LateralBatchedTableFunction: batched_generate_series(CAST(ranges_filter_test.start_val AS Int64), CAST(ranges_filter_test.end_val AS Int64))
04)------TableScan: ranges_filter_test projection=[start_val, end_val]
physical_plan
01)ProjectionExec: expr=[start_val@0 as start_val, value@2 as value]
02)--GlobalLimitExec: skip=0, fetch=3
03)----BatchedTableFunctionExec: function=batched_generate_series, args=[CAST(start_val@0 AS Int64), CAST(end_val@1 AS Int64)]
04)------DataSourceExec: partitions=1, partition_sizes=[1]

# Cleanup filter test table
statement ok
DROP TABLE ranges_filter_test;

##########
## Type Coercion Tests
##########

# Signature::exact - NULL and exact type matches work
query I
SELECT result FROM batched_coercion_exact(NULL, 42);
----
42

query I
SELECT result FROM batched_coercion_exact(10, 32);
----
42

# Signature::coercible - supports NULL and Int64â†’Int32 narrowing
query I
SELECT result FROM batched_coercion_coercible(NULL, 42);
----
42

query I
SELECT result FROM batched_coercion_coercible(10, 32);
----
42

# Coercion in LATERAL joins
statement ok
CREATE TABLE coercion_test(a BIGINT, b BIGINT) AS VALUES (10, 20), (15, 25), (5, 10);

query III
SELECT a, b, result
FROM coercion_test
CROSS JOIN LATERAL batched_coercion_coercible(a, b)
ORDER BY a;
----
5 10 15
10 20 30
15 25 40

statement ok
DROP TABLE coercion_test;

##########
## Projection Handling Tests
## Functions can optionally apply projection; DataFusion applies it automatically if not
##########

# Both functions produce identical results
query III
SELECT n, n_squared, n_cubed FROM batched_multi_column(CAST(1 AS INT), CAST(3 AS INT)) ORDER BY n;
----
1 1 1
2 4 8
3 9 27

query III
SELECT n, n_squared, n_cubed FROM batched_multi_column_no_proj(1, 3) ORDER BY n;
----
1 1 1
2 4 8
3 9 27

# Automatic projection when function doesn't apply it
query II
SELECT n, n_squared FROM batched_multi_column_no_proj(1, 3) ORDER BY n;
----
1 1
2 4
3 9

# Projection with LATERAL join
statement ok
CREATE TABLE proj_test(start BIGINT, stop BIGINT) AS VALUES (1, 2), (3, 4);

query IIII
SELECT start, stop, n, n_squared
FROM proj_test
CROSS JOIN LATERAL batched_multi_column_no_proj(start, stop)
ORDER BY start, n;
----
1 2 1 1
1 2 2 4
3 4 3 9
3 4 4 16

statement ok
DROP TABLE proj_test;

##########
## Comma LATERAL Syntax Tests
## Test that `FROM x, LATERAL y` works the same as `FROM x CROSS JOIN LATERAL y`
##########

# Test basic comma LATERAL syntax
query II
SELECT start_val, value
FROM ranges, LATERAL batched_generate_series(start_val, end_val)
ORDER BY start_val, value;
----
1 1
1 2
1 3
5 5
5 6
5 7
10 10
10 11
10 12

# Verify it produces the same results as CROSS JOIN LATERAL
query II
SELECT start_val, value
FROM ranges CROSS JOIN LATERAL batched_generate_series(start_val, end_val)
ORDER BY start_val, value;
----
1 1
1 2
1 3
5 5
5 6
5 7
10 10
10 11
10 12

# Test multiple LATERAL functions with comma syntax
statement ok
CREATE TABLE lateral_multi_test (start_val INT, end_val INT);

statement ok
INSERT INTO lateral_multi_test VALUES (10, 12);

query IIII
SELECT s.start_val, s.end_val, g1.value as value1, g2.value as value2
FROM lateral_multi_test s,
     LATERAL batched_generate_series(s.start_val, s.end_val) g1,
     LATERAL batched_generate_series(s.start_val, s.start_val + 1) g2
ORDER BY value1, value2;
----
10 12 10 10
10 12 10 11
10 12 11 10
10 12 11 11
10 12 12 10
10 12 12 11

statement ok
DROP TABLE lateral_multi_test;

# Test chained LATERAL functions where second references first
statement ok
CREATE TABLE lateral_chain_test (start_val INT);

statement ok
INSERT INTO lateral_chain_test VALUES (1), (3);

query III
SELECT s.start_val, g1.value as first_value, g2.value as second_value
FROM lateral_chain_test s,
     LATERAL batched_generate_series(s.start_val, s.start_val + 1) g1,
     LATERAL batched_generate_series(g1.value, g1.value + 1) g2
ORDER BY start_val, first_value, second_value;
----
1 1 1
1 1 2
1 2 2
1 2 3
3 3 3
3 3 4
3 4 4
3 4 5

statement ok
DROP TABLE lateral_chain_test;

# Test comma LATERAL with multi-column function
statement ok
CREATE TABLE comma_test(start BIGINT, stop BIGINT) AS VALUES (1, 2), (3, 4);

query IIII
SELECT start, stop, n, n_squared
FROM comma_test, LATERAL batched_multi_column_no_proj(start, stop)
ORDER BY start, n;
----
1 2 1 1
1 2 2 4
3 4 3 9
3 4 4 16

# Verify same as CROSS JOIN LATERAL
query IIII
SELECT start, stop, n, n_squared
FROM comma_test CROSS JOIN LATERAL batched_multi_column_no_proj(start, stop)
ORDER BY start, n;
----
1 2 1 1
1 2 2 4
3 4 3 9
3 4 4 16

# Test EXPLAIN shows correct plan for comma LATERAL
query TT
EXPLAIN SELECT start, stop, value
FROM comma_test, LATERAL batched_generate_series(start, stop);
----
logical_plan
01)LateralBatchedTableFunction: batched_generate_series(comma_test.start, comma_test.stop)
02)--TableScan: comma_test projection=[start, stop]
physical_plan
01)BatchedTableFunctionExec: function=batched_generate_series, args=[start@0, stop@1]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

# Cleanup
statement ok
DROP TABLE comma_test;

##########
## Cleanup
##########

statement ok
DROP TABLE ranges;

statement ok
DROP TABLE multipliers;

statement ok
DROP TABLE single_range;
