# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

statement ok
create table t(a int, b string) as values (1, 'a'), (2, NULL), (NULL, 'c');

# test between simplification
query TT
explain select a from t where a BETWEEN 3 and 3
----
logical_plan
01)Filter: t.a = Int32(3)
02)--TableScan: t projection=[a]
physical_plan
01)FilterExec: a@0 = 3
02)--DataSourceExec: partitions=1, partition_sizes=[1]

# test regex exprs
query TT
explain select b from t where b ~ '.*'
----
logical_plan
01)Filter: t.b ~ Utf8View(".*")
02)--TableScan: t projection=[b]
physical_plan
01)FilterExec: b@0 ~ .*
02)--DataSourceExec: partitions=1, partition_sizes=[1]

query TT
explain select b from t where b !~ '.*'
----
logical_plan
01)Filter: t.b !~ Utf8View(".*")
02)--TableScan: t projection=[b]
physical_plan
01)FilterExec: b@0 !~ .*
02)--DataSourceExec: partitions=1, partition_sizes=[1]

query T
select b from t where b ~ '.*'
----
a
c

query T
select b from t where b !~ '.*'
----

query TT
explain select * from t where a = a;
----
logical_plan
01)Filter: t.a IS NOT NULL OR Boolean(NULL)
02)--TableScan: t projection=[a, b]
physical_plan
01)FilterExec: a@0 IS NOT NULL OR NULL
02)--DataSourceExec: partitions=1, partition_sizes=[1]

statement ok
drop table t;

# test decimal precision
query B
SELECT a * 1.000::DECIMAL(4,3) > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
false

query B
SELECT 1.000::DECIMAL(4,3) * a > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
false

query B
SELECT NULL::DECIMAL(4,3) * a > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
NULL

query B
SELECT a * NULL::DECIMAL(4,3) > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
NULL

query B
SELECT a / 1.000::DECIMAL(4,3) > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
false

query B
SELECT a / NULL::DECIMAL(4,3) > 1.2::decimal(2,1) FROM VALUES (1) AS t(a);
----
NULL

query TT
explain SELECT CASE WHEN 1 > 0 THEN MAP {'x': 100} ELSE MAP {'y': 200} END AS a;
----
logical_plan
01)Projection: Map([{"x":"100"}]) AS a
02)--EmptyRelation: rows=1
physical_plan
01)ProjectionExec: expr=[[{x:100}] as a]
02)--PlaceholderRowExec

# Simplify cases where the end expressions are the same to that expression
query TT
EXPLAIN SELECT
    CASE v when 100 then 1 else 1 end as opt1,
    CASE v when 200 then 2 when 201 then 2 else 2 end as opt2,
    CASE v when 300 then 3 when 301 then 3 else 4 end as noopt1,
    CASE v when 400 then 4 when 401 then 4 end as noopt2
FROM (VALUES (0), (1), (2)) t(v)
----
logical_plan
01)Projection: CASE t.v WHEN Int64(100) THEN Int64(1) ELSE Int64(1) END AS opt1, CASE t.v WHEN Int64(200) THEN Int64(2) WHEN Int64(201) THEN Int64(2) ELSE Int64(2) END AS opt2, CASE t.v WHEN Int64(300) THEN Int64(3) WHEN Int64(301) THEN Int64(3) ELSE Int64(4) END AS noopt1, CASE t.v WHEN Int64(400) THEN Int64(4) WHEN Int64(401) THEN Int64(4) END AS noopt2
02)--SubqueryAlias: t
03)----Projection: column1 AS v
04)------Values: (Int64(0)), (Int64(1)), (Int64(2))
physical_plan
01)ProjectionExec: expr=[CASE column1@0 WHEN 100 THEN 1 ELSE 1 END as opt1, CASE column1@0 WHEN 200 THEN 2 WHEN 201 THEN 2 ELSE 2 END as opt2, CASE column1@0 WHEN 300 THEN 3 WHEN 301 THEN 3 ELSE 4 END as noopt1, CASE column1@0 WHEN 400 THEN 4 WHEN 401 THEN 4 END as noopt2]
02)--DataSourceExec: partitions=1, partition_sizes=[1]
