# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

include ./init_data.slt.part

# --------------------------------------
# Setup test tables with different physical string types
# and repeat tests in `string_query.slt.part`
# --------------------------------------
statement ok
create table test_basic_operator as
select
    arrow_cast(column1, 'Utf8') as ascii_1,
    arrow_cast(column2, 'Utf8') as ascii_2,
    arrow_cast(column3, 'Utf8') as unicode_1,
    arrow_cast(column4, 'Utf8') as unicode_2
from test_source;

statement ok
create table test_substr as
select arrow_cast(col1, 'Utf8') as c1 from test_substr_base;

# TODO: move it back to `string_query.slt.part` after fixing the issue
# see detail: https://github.com/apache/datafusion/issues/12637
# Test pattern with wildcard characters
query TTBBBB
select ascii_1, unicode_1,
       ascii_1 like 'An%' as ascii_like,
       unicode_1 like '%ionæ•°æ®%' as unicode_like,
       ascii_1 ilike 'An%' as ascii_ilike,
       unicode_1 ilike '%ionæ•°æ®%' as unicode_ilik
from test_basic_operator;
----
Andrew datafusionğŸ“ŠğŸ”¥ true false true false
Xiangpeng datafusionæ•°æ®èåˆ false true false true
Raphael datafusionĞ”Ğ°Ñ‚Ğ°Ğ¤ÑƒÑĞ¸Ğ¾Ğ½ false false false false
under_score un iÅ›Ä‡ core false false false false
percent pan Tadeusz ma iÅ›Ä‡ w kÄ…t false false false false
(empty) (empty) false false false false
% (empty) false false false false
_ (empty) false false false false
NULL NULL NULL NULL NULL NULL
NULL NULL NULL NULL NULL NULL

#
# common test for string-like functions and operators
#
include ./string_query.slt.part

# TODO support all String types in sql_like_to_expr and move this test to `string_query.slt.part`
# dynamic LIKE as filter
query TTT rowsort
SELECT ascii_1, 'is LIKE', ascii_2 FROM test_basic_operator WHERE ascii_1 LIKE ascii_2
UNION ALL
SELECT ascii_1, 'is NOT LIKE', ascii_2 FROM test_basic_operator WHERE ascii_1 NOT LIKE ascii_2
UNION ALL
SELECT unicode_1, 'is LIKE', ascii_2 FROM test_basic_operator WHERE unicode_1 LIKE ascii_2
UNION ALL
SELECT unicode_1, 'is NOT LIKE', ascii_2 FROM test_basic_operator WHERE unicode_1 NOT LIKE ascii_2
UNION ALL
SELECT unicode_2, 'is LIKE', ascii_2 FROM test_basic_operator WHERE unicode_2 LIKE ascii_2
UNION ALL
SELECT unicode_2, 'is NOT LIKE', ascii_2 FROM test_basic_operator WHERE unicode_2 NOT LIKE ascii_2
----
% is LIKE \%
(empty) is LIKE %
(empty) is LIKE %
(empty) is LIKE %
(empty) is NOT LIKE \%
(empty) is NOT LIKE \%
(empty) is NOT LIKE \_
(empty) is NOT LIKE \_
Andrew is NOT LIKE X
Pan Tadeusz ma frunÄ…Ä‡ stÄ…d w kÄ…t is NOT LIKE p%t
Raphael is NOT LIKE R
Xiangpeng is LIKE Xiangpeng
_ is LIKE \_
chrzÄ…szcz na Å‚Ä…ce w æ±äº¬éƒ½ is NOT LIKE un_____core
datafusionĞ”Ğ°Ñ‚Ğ°Ğ¤ÑƒÑĞ¸Ğ¾Ğ½ is NOT LIKE R
datafusionæ•°æ®èåˆ is NOT LIKE Xiangpeng
datafusionæ•°æ®èåˆ is NOT LIKE Xiangpeng
datafusionğŸ“ŠğŸ”¥ is NOT LIKE X
pan Tadeusz ma iÅ›Ä‡ w kÄ…t is LIKE p%t
percent is LIKE p%t
un iÅ›Ä‡ core is LIKE un_____core
under_score is LIKE un_____core
Ğ°Ğ¤ÑƒÑ is NOT LIKE R
ğŸ”¥ is NOT LIKE R
ğŸ”¥ is NOT LIKE X

# TODO support all String types in sql_like_to_expr and move this test to `string_query.slt.part`
# dynamic LIKE as projection
query TTTTBBBB rowsort
SELECT
    ascii_1, ascii_2, unicode_1, unicode_2,
    (ascii_1 LIKE ascii_2) AS ascii_1_like_ascii_2,
    (ascii_2 LIKE ascii_1) AS ascii_2_like_ascii_1,
    (unicode_1 LIKE ascii_2) AS unicode_1_like_ascii_2,
    (unicode_2 LIKE ascii_2) AS unicode_2_like_ascii_2
FROM test_basic_operator
----
% \% (empty) (empty) true true false false
(empty) % (empty) (empty) true false true true
Andrew X datafusionğŸ“ŠğŸ”¥ ğŸ”¥ false false false false
NULL % NULL NULL NULL NULL NULL NULL
NULL R NULL ğŸ”¥ NULL NULL NULL false
Raphael R datafusionĞ”Ğ°Ñ‚Ğ°Ğ¤ÑƒÑĞ¸Ğ¾Ğ½ Ğ°Ğ¤ÑƒÑ false false false false
Xiangpeng Xiangpeng datafusionæ•°æ®èåˆ datafusionæ•°æ®èåˆ true true false false
_ \_ (empty) (empty) true false false false
percent p%t pan Tadeusz ma iÅ›Ä‡ w kÄ…t Pan Tadeusz ma frunÄ…Ä‡ stÄ…d w kÄ…t true false true false
under_score un_____core un iÅ›Ä‡ core chrzÄ…szcz na Å‚Ä…ce w æ±äº¬éƒ½ true false true false

# TODO support all String types in sql_like_to_expr and move this test to `string_query.slt.part`
# dynamic ILIKE as filter
query TTT rowsort
SELECT ascii_1, 'is ILIKE', ascii_2 FROM test_basic_operator WHERE ascii_1 ILIKE ascii_2
UNION ALL
SELECT ascii_1, 'is NOT ILIKE', ascii_2 FROM test_basic_operator WHERE ascii_1 NOT ILIKE ascii_2
UNION ALL
SELECT unicode_1, 'is ILIKE', ascii_2 FROM test_basic_operator WHERE unicode_1 ILIKE ascii_2
UNION ALL
SELECT unicode_1, 'is NOT ILIKE', ascii_2 FROM test_basic_operator WHERE unicode_1 NOT ILIKE ascii_2
UNION ALL
SELECT unicode_2, 'is ILIKE', ascii_2 FROM test_basic_operator WHERE unicode_2 ILIKE ascii_2
UNION ALL
SELECT unicode_2, 'is NOT ILIKE', ascii_2 FROM test_basic_operator WHERE unicode_2 NOT ILIKE ascii_2
----
% is ILIKE \%
(empty) is ILIKE %
(empty) is ILIKE %
(empty) is ILIKE %
(empty) is NOT ILIKE \%
(empty) is NOT ILIKE \%
(empty) is NOT ILIKE \_
(empty) is NOT ILIKE \_
Andrew is NOT ILIKE X
Pan Tadeusz ma frunÄ…Ä‡ stÄ…d w kÄ…t is ILIKE p%t
Raphael is NOT ILIKE R
Xiangpeng is ILIKE Xiangpeng
_ is ILIKE \_
chrzÄ…szcz na Å‚Ä…ce w æ±äº¬éƒ½ is NOT ILIKE un_____core
datafusionĞ”Ğ°Ñ‚Ğ°Ğ¤ÑƒÑĞ¸Ğ¾Ğ½ is NOT ILIKE R
datafusionæ•°æ®èåˆ is NOT ILIKE Xiangpeng
datafusionæ•°æ®èåˆ is NOT ILIKE Xiangpeng
datafusionğŸ“ŠğŸ”¥ is NOT ILIKE X
pan Tadeusz ma iÅ›Ä‡ w kÄ…t is ILIKE p%t
percent is ILIKE p%t
un iÅ›Ä‡ core is ILIKE un_____core
under_score is ILIKE un_____core
Ğ°Ğ¤ÑƒÑ is NOT ILIKE R
ğŸ”¥ is NOT ILIKE R
ğŸ”¥ is NOT ILIKE X

# TODO support all String types in sql_like_to_expr and move this test to `string_query.slt.part`
# dynamic ILIKE as projection
query TTTTBBBB rowsort
SELECT
    ascii_1, ascii_2, unicode_1, unicode_2,
    (ascii_1 ILIKE ascii_2) AS ascii_1_ilike_ascii_2,
    (ascii_2 ILIKE ascii_1) AS ascii_2_ilike_ascii_1,
    (unicode_1 ILIKE ascii_2) AS unicode_1_ilike_ascii_2,
    (unicode_2 ILIKE ascii_2) AS unicode_2_ilike_ascii_2
FROM test_basic_operator
----
% \% (empty) (empty) true true false false
(empty) % (empty) (empty) true false true true
Andrew X datafusionğŸ“ŠğŸ”¥ ğŸ”¥ false false false false
NULL % NULL NULL NULL NULL NULL NULL
NULL R NULL ğŸ”¥ NULL NULL NULL false
Raphael R datafusionĞ”Ğ°Ñ‚Ğ°Ğ¤ÑƒÑĞ¸Ğ¾Ğ½ Ğ°Ğ¤ÑƒÑ false false false false
Xiangpeng Xiangpeng datafusionæ•°æ®èåˆ datafusionæ•°æ®èåˆ true true false false
_ \_ (empty) (empty) true false false false
percent p%t pan Tadeusz ma iÅ›Ä‡ w kÄ…t Pan Tadeusz ma frunÄ…Ä‡ stÄ…d w kÄ…t true false true true
under_score un_____core un iÅ›Ä‡ core chrzÄ…szcz na Å‚Ä…ce w æ±äº¬éƒ½ true false true false

# TODO: move it back to `string_query.slt.part` after fixing the issue
# see issue https://github.com/apache/datafusion/issues/13329
query IIII
select bit_length(ascii_1), bit_length(ascii_2), bit_length(unicode_1), bit_length(unicode_2) from test_basic_operator;
----
48 8 144 32
72 72 176 176
56 8 240 64
88 88 104 256
56 24 216 288
0 8 0 0
8 16 0 0
8 16 0 0
NULL 8 NULL NULL
NULL 8 NULL 32

#
# Clean up
#

statement ok
drop table test_basic_operator;

statement ok
drop table test_substr;
