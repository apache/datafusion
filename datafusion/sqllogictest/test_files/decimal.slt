# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.You may obtain a copy of the License at

# http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.See the License for the
# specific language governing permissions and limitations
# under the License.

query TR
select arrow_typeof(cast(1.23 as decimal(10,4))),
       cast(1.23 as decimal(10,4));
----
Decimal128(10, 4) 1.23


query TR
select arrow_typeof(cast(cast(1.23 as decimal(10,3)) as decimal(10,4))),
       cast(cast(1.23 as decimal(10,3)) as decimal(10,4));
----
Decimal128(10, 4) 1.23


query TR
select arrow_typeof(cast(1.2345 as decimal(24,2))), cast(1.2345 as decimal(24,2));
----
Decimal128(24, 2) 1.23


statement ok
CREATE EXTERNAL TABLE decimal_simple (
c1 DECIMAL(10,6) NOT NULL,
c2 DOUBLE NOT NULL,
c3 BIGINT NOT NULL,
c4 BOOLEAN NOT NULL,
c5 DECIMAL(12,7) NOT NULL
)
STORED AS CSV
LOCATION '../core/tests/data/decimal_data.csv'
OPTIONS ('format.has_header' 'true');


query TT
select arrow_typeof(c1), arrow_typeof(c5) from decimal_simple where c1 > c5 limit 1;
----
Decimal128(10, 6) Decimal128(12, 7)


query R rowsort
SELECT c1 from decimal_simple;
----
0.00001
0.00002
0.00002
0.00003
0.00003
0.00003
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005


query R rowsort
select c1 from decimal_simple where c1 > 0.000030;
----
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005


query RRIBR rowsort
select * from decimal_simple where c1 > c5;
----
0.00002 0.000000000002 3 false 0.000019
0.00003 0.000000000003 5 true 0.000011
0.00005 0.000000000005 8 false 0.000033


query TR
select arrow_typeof(min(c1)), min(c1) from decimal_simple where c4=false;
----
Decimal128(10, 6) 0.00002


query TR
select arrow_typeof(max(c1)), max(c1) from decimal_simple where c4=false;
----
Decimal128(10, 6) 0.00005


# inferred precision is 10+10
# inferred scale is the original scale
query TR
select arrow_typeof(sum(c1)), sum(c1) from decimal_simple;
----
Decimal128(20, 6) 0.00055


# inferred precision is original precision + 4
# inferred scale is the original scale + 4
query TR
select arrow_typeof(avg(c1)), avg(c1) from decimal_simple;
----
Decimal128(14, 10) 0.0000366666


query TR
select arrow_typeof(median(c1)), median(c1) from decimal_simple;
----
Decimal128(10, 6) 0.00004


query RRIBR rowsort
select * from decimal_simple where c1=CAST(0.00002 as Decimal(10,8));
----
0.00002 0.000000000002 2 true 0.000025
0.00002 0.000000000002 3 false 0.000019


query RI rowsort
select c2,c3 from decimal_simple where c1!=0.00002;
----
0.000000000001 1
0.000000000003 4
0.000000000003 5
0.000000000003 5
0.000000000004 12
0.000000000004 14
0.000000000004 5
0.000000000004 8
0.000000000005 1
0.000000000005 100
0.000000000005 4
0.000000000005 8
0.000000000005 9


query RRIBR
select * from decimal_simple where 0.00002 > c1;
----
0.00001 0.000000000001 1 true 0.000014


query RRIBR rowsort
select * from decimal_simple where c1 <= 0.00002;
----
0.00001 0.000000000001 1 true 0.000014
0.00002 0.000000000002 2 true 0.000025
0.00002 0.000000000002 3 false 0.000019


query RRIBR rowsort
select * from decimal_simple where c1 > 0.00002;
----
0.00003 0.000000000003 4 true 0.000032
0.00003 0.000000000003 5 false 0.000035
0.00003 0.000000000003 5 true 0.000011
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 8 false 0.000044
0.00005 0.000000000005 1 false 0.0001
0.00005 0.000000000005 100 true 0.000068
0.00005 0.000000000005 4 true 0.000078
0.00005 0.000000000005 8 false 0.000033
0.00005 0.000000000005 9 true 0.000052


query RRIBR rowsort
select * from decimal_simple where c1 >= 0.00002;
----
0.00002 0.000000000002 2 true 0.000025
0.00002 0.000000000002 3 false 0.000019
0.00003 0.000000000003 4 true 0.000032
0.00003 0.000000000003 5 false 0.000035
0.00003 0.000000000003 5 true 0.000011
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 8 false 0.000044
0.00005 0.000000000005 1 false 0.0001
0.00005 0.000000000005 100 true 0.000068
0.00005 0.000000000005 4 true 0.000078
0.00005 0.000000000005 8 false 0.000033
0.00005 0.000000000005 9 true 0.000052


query T
select arrow_typeof(c1+1) from decimal_simple limit 1;
----
Decimal128(27, 6)


query R rowsort
select c1+1 from decimal_simple;
----
1.00001
1.00002
1.00002
1.00003
1.00003
1.00003
1.00004
1.00004
1.00004
1.00004
1.00005
1.00005
1.00005
1.00005
1.00005


# array decimal(10,6) + array decimal(12,7) => decimal(13,7)
query T
select arrow_typeof(c1+c5) from decimal_simple limit 1;
----
Decimal128(13, 7)


query R rowsort
select c1+c5 from decimal_simple;
----
0.000024
0.000039
0.000041
0.000045
0.000062
0.000065
0.00008
0.00008
0.000083
0.000084
0.000084
0.000102
0.000118
0.000128
0.00015


query T
select arrow_typeof(c1-1) from decimal_simple limit 1;
----
Decimal128(27, 6)


query R rowsort
select c1-1 from decimal_simple;
----
-0.99995
-0.99995
-0.99995
-0.99995
-0.99995
-0.99996
-0.99996
-0.99996
-0.99996
-0.99997
-0.99997
-0.99997
-0.99998
-0.99998
-0.99999


query T
select arrow_typeof(c1-c5) from decimal_simple limit 1;
----
Decimal128(13, 7)


query R rowsort
select c1-c5 from decimal_simple;
----
-0.000002
-0.000002
-0.000004
-0.000004
-0.000004
-0.000005
-0.000005
-0.000018
-0.000028
-0.00005
0
0
0.000001
0.000017
0.000019


query T
select arrow_typeof(c1*20) from decimal_simple limit 1;
----
Decimal128(31, 6)


query R rowsort
select c1*20 from decimal_simple;
----
0.0002
0.0004
0.0004
0.0006
0.0006
0.0006
0.0008
0.0008
0.0008
0.0008
0.001
0.001
0.001
0.001
0.001


query T
select arrow_typeof(c1*c5) from decimal_simple limit 1;
----
Decimal128(23, 13)


query R rowsort
select c1*c5 from decimal_simple;
----
0.00000000014
0.00000000033
0.00000000038
0.0000000005
0.00000000096
0.00000000105
0.0000000016
0.0000000016
0.00000000165
0.00000000176
0.00000000176
0.0000000026
0.0000000034
0.0000000039
0.000000005


query T
select arrow_typeof(c1/cast(0.00001 as decimal(5,5))) from decimal_simple limit 1;
----
Decimal128(19, 10)


query R rowsort
select c1/cast(0.00001 as decimal(5,5)) from decimal_simple;
----
1
2
2
3
3
3
4
4
4
4
5
5
5
5
5


query T
select arrow_typeof(c1/c5) from decimal_simple limit 1;
----
Decimal128(21, 10)


query R rowsort
select c1/c5 from decimal_simple;
----
0.5
0.641025641
0.7142857142
0.7352941176
0.8
0.8571428571
0.909090909
0.909090909
0.9375
0.9615384615
1
1
1.0526315789
1.5151515151
2.7272727272


query T
select arrow_typeof(c5%cast(0.00001 as decimal(5,5))) from decimal_simple limit 1;
----
Decimal128(7, 7)


query R rowsort
select c5%cast(0.00001 as decimal(5,5)) from decimal_simple;
----
0
0
0
0.000001
0.000002
0.000002
0.000003
0.000004
0.000004
0.000004
0.000005
0.000005
0.000008
0.000008
0.000009


query T
select arrow_typeof(c1%c5) from decimal_simple limit 1;
----
Decimal128(11, 7)


query R rowsort
select c1%c5 from decimal_simple;
----
0
0
0.000001
0.000008
0.00001
0.000017
0.00002
0.00003
0.00003
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005


query T
select arrow_typeof(abs(c1)) from decimal_simple limit 1;
----
Decimal128(10, 6)


query R rowsort
SELECT abs(c1) from decimal_simple;
----
0.00001
0.00002
0.00002
0.00003
0.00003
0.00003
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005


query RRIBR
select * from decimal_simple where c1 >= 0.00004 order by c1;
----
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00004 0.000000000004 8 false 0.000044
0.00005 0.000000000005 9 true 0.000052
0.00005 0.000000000005 4 true 0.000078
0.00005 0.000000000005 8 false 0.000033
0.00005 0.000000000005 100 true 0.000068
0.00005 0.000000000005 1 false 0.0001


query RRIBR
select * from decimal_simple where c1 >= 0.00004 order by c1, c3 limit 10;
----
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 8 false 0.000044
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00005 0.000000000005 1 false 0.0001
0.00005 0.000000000005 4 true 0.000078
0.00005 0.000000000005 8 false 0.000033
0.00005 0.000000000005 9 true 0.000052
0.00005 0.000000000005 100 true 0.000068

query RRIBR
select * from decimal_simple where c1 >= 0.00004 order by c1, c3 limit 5;
----
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 8 false 0.000044
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00005 0.000000000005 1 false 0.0001


query RRIBR
select * from decimal_simple where c1 >= 0.00004 order by c1 desc;
----
0.00005 0.000000000005 9 true 0.000052
0.00005 0.000000000005 4 true 0.000078
0.00005 0.000000000005 8 false 0.000033
0.00005 0.000000000005 100 true 0.000068
0.00005 0.000000000005 1 false 0.0001
0.00004 0.000000000004 5 true 0.000044
0.00004 0.000000000004 12 false 0.00004
0.00004 0.000000000004 14 true 0.00004
0.00004 0.000000000004 8 false 0.000044


query RRIBR
select * from decimal_simple where c1 < 0.00003 order by c1 desc,c4;
----
0.00002 0.000000000002 3 false 0.000019
0.00002 0.000000000002 2 true 0.000025
0.00001 0.000000000001 1 true 0.000014


query IR
select count(*),c1 from decimal_simple group by c1 order by c1;
----
1 0.00001
2 0.00002
3 0.00003
4 0.00004
5 0.00005


query IRB
select count(*),c1,c4 from decimal_simple group by c1,c4 order by c1,c4;
----
1 0.00001 true
1 0.00002 false
1 0.00002 true
1 0.00003 false
2 0.00003 true
2 0.00004 false
2 0.00004 true
2 0.00005 false
3 0.00005 true


query TR
select arrow_typeof(cast(400420638.54 as decimal(12,2))), cast(400420638.54 as decimal(12,2));
----
Decimal128(12, 2) 400420638.54


query TR
select arrow_typeof(cast(400420638.54 as decimal(12,2)) * 1.0), cast(400420638.54 as decimal(12,2)) * 1.0;
----
Float64 400420638.54


query TB
select arrow_typeof(a < null), a < null from (values (1.1::decimal)) as t(a);
----
Boolean NULL


query TB
select arrow_typeof(null <= a), null <= a from (values (1.1::decimal)) as t(a);
----
Boolean NULL

query R
select try_cast(1234567 as decimal(7,3));
----
NULL

statement ok
create table foo (a DECIMAL(38, 20), b DECIMAL(38, 0));

statement ok
insert into foo VALUES (1, 5);

query R
select a / b from foo;
----
0.2

query R
select AVG(column1) from values (arrow_cast(123, 'Decimal256(5,2)'));
----
123

statement ok
CREATE EXTERNAL TABLE decimal256_simple (
c1 DECIMAL(50,6) NOT NULL,
c2 DOUBLE NOT NULL,
c3 BIGINT NOT NULL,
c4 BOOLEAN NOT NULL,
c5 DECIMAL(52,7) NOT NULL
)
STORED AS CSV
LOCATION '../core/tests/data/decimal_data.csv'
OPTIONS ('format.has_header' 'true');

query TT
select arrow_typeof(c1), arrow_typeof(c5) from decimal256_simple limit 1;
----
Decimal256(50, 6) Decimal256(52, 7)

query R rowsort
SELECT c1 from decimal256_simple;
----
0.00001
0.00002
0.00002
0.00003
0.00003
0.00003
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005

query R rowsort
select c1 from decimal256_simple where c1 > 0.000030;
----
0.00004
0.00004
0.00004
0.00004
0.00005
0.00005
0.00005
0.00005
0.00005

query RRIBR rowsort
select * from decimal256_simple where c1 > c5;
----
0.00002 0.000000000002 3 false 0.000019
0.00003 0.000000000003 5 true 0.000011
0.00005 0.000000000005 8 false 0.000033

query TR
select arrow_typeof(avg(c1)), avg(c1) from decimal256_simple;
----
Decimal256(54, 10) 0.0000366666

query TR
select arrow_typeof(min(c1)), min(c1) from decimal256_simple where c4=false;
----
Decimal256(50, 6) 0.00002

query TR
select arrow_typeof(max(c1)), max(c1) from decimal256_simple where c4=false;
----
Decimal256(50, 6) 0.00005

query TR
select arrow_typeof(sum(c1)), sum(c1) from decimal256_simple;
----
Decimal256(60, 6) 0.00055

query TR
select arrow_typeof(median(c1)), median(c1) from decimal256_simple;
----
Decimal256(50, 6) 0.00004

query IR
select count(*),c1 from decimal256_simple group by c1 order by c1;
----
1 0.00001
2 0.00002
3 0.00003
4 0.00004
5 0.00005

query I
select count(DISTINCT cast(c1 AS DECIMAL(42, 4))) from decimal256_simple;
----
2

query BI
select c4, count(DISTINCT cast(c1 AS DECIMAL(42, 4))) from decimal256_simple GROUP BY c4 ORDER BY c4;
----
false 2
true 2

statement ok
drop table decimal256_simple;


# https://github.com/apache/datafusion/issues/12870
query R
SELECT CAST('0' AS decimal(38,0));
----
0

query RR
SELECT
    cast(cast('0' as decimal(3,0)) as decimal(2,0)),
    cast(cast('5.20' as decimal(4,2)) as decimal(3,2))
----
0 5.2

query RR
SELECT
    arrow_cast(1.23,'Decimal128(3,2)') -  arrow_cast(123, 'UInt64') as subtration_uint,
    arrow_cast(1.23,'Decimal128(3,2)') -  arrow_cast(123, 'Int64') as subtration_int
----
-121.77 -121.77

query RR
SELECT
    arrow_cast(1.23,'Decimal128(3,2)') +  arrow_cast(123, 'UInt64') as addition_uint,
    arrow_cast(1.23,'Decimal128(3,2)') +  arrow_cast(123, 'Int64') as addition_int
----
124.23 124.23

query RR
SELECT
    arrow_cast(1.23,'Decimal128(3,2)') *  arrow_cast(123, 'UInt64') as mulitplication_uint,
    arrow_cast(1.23,'Decimal128(3,2)') *  arrow_cast(123, 'Int64') as multiplication_int
----
151.29 151.29

query RR
SELECT
    arrow_cast(1.23,'Decimal128(3,2)') /  arrow_cast(123, 'UInt64') as divison_uint,
    arrow_cast(1.23,'Decimal128(3,2)') /  arrow_cast(123, 'Int64') as divison_int
----
0.01 0.01

query TR
with tt as (
    select arrow_cast(133333333333333333333333333333333333333333333.34, 'Decimal256(50, 2)') as v1
) select arrow_typeof(v1 + 1.5), v1 + 1.5 from tt;
----
Float64 133333333333333330000000000000000000000000000

# Following tests only make sense if numbers are parsed as decimals
# Remove when `parse_float_as_decimal` is true by default (#14612)
statement ok
set datafusion.sql_parser.parse_float_as_decimal = true;

# smoke test for decimal parsing
query RT
select 100000000000000000000000000000000000::decimal(38,0), arrow_typeof(100000000000000000000000000000000000::decimal(38,0));
----
100000000000000000000000000000000000 Decimal128(38, 0)

# log for small decimal32
query R
select log(arrow_cast(100, 'Decimal32(9, 0)'));
----
2

query R
select log(arrow_cast(100, 'Decimal32(9, 2)'));
----
2

query R
select log(2.0, arrow_cast(12345.67, 'Decimal32(9, 2)'));
----
13

# log for small decimal64
query R
select log(arrow_cast(100, 'Decimal64(18, 0)'));
----
2

query R
select log(arrow_cast(100, 'Decimal64(18, 2)'));
----
2

query R
select log(2.0, arrow_cast(12345.6789, 'Decimal64(15, 4)'));
----
13


# log for small decimal128
query R
select log(arrow_cast(100, 'Decimal128(38, 0)'));
----
2

query R
select log(arrow_cast(100, 'Decimal128(38, 2)'));
----
2

# log for small decimal256
query R
select log(arrow_cast(100, 'Decimal256(76, 0)'));
----
2

query R
select log(arrow_cast(100, 'Decimal256(76, 2)'));
----
2

# log(10^21) for large decimal128
query R
select log(10, 1000000000000000000000::decimal(38,0));
----
21

# log(10^35) for large decimal128
# Must be 35 if parsed as decimal; 34 for floats
query R
select log(100000000000000000000000000000000000::decimal(38,0))
----
35

# Decimal overflow for 10^38
query error Arrow error: Invalid argument error: .* is too large to store in a Decimal128 of precision 38. Max is
select log(100000000000000000000000000000000000000::decimal(38,0))

# log(10^35) for decimal256 for a value able to fit i128
query R
select log(100000000000000000000000000000000000::decimal(76,0));
----
35

# log(10^50) for decimal256 for a value larger than i128
query error Arrow error: Not yet implemented: Log of Decimal256 larger than Decimal128 is not yet supported
select log(100000000000000000000000000000000000000000000000000::decimal(76,0));

# log(10^35) for decimal128 with explicit base
query R
select log(10, 100000000000000000000000000000000000::decimal(38,0));
----
35

# log(10^35) for decimal256 with explicit base - only float as a base
query R
select log(10.0, 100000000000000000000000000000000000::decimal(76,0));
----
35

# log(10^35) for decimal128 with explicit decimal base
query R
select log(10::decimal(38, 0), 100000000000000000000000000000000000::decimal(38,0));
----
35

# log(10^35) for decimal128 with another base
query R
select log(2, 100000000000000000000000000000000000::decimal(38,0));
----
116

# log(10^35) for decimal128 with another base
# TODO: this should be 116.267483321058, error with native decimal log impl
#       https://github.com/apache/datafusion/issues/18524
query R
select log(2.0, 100000000000000000000000000000000000::decimal(38,0));
----
116

# null cases
query R
select log(null, 100);
----
NULL

query R
select log(null, 100000000000000000000000000000000000::decimal(38,0));
----
NULL

query R
select log(null);
----
NULL

query R
select log(2.0, null);
----
NULL

# log with negative scale decimals
# Using scientific notation to create decimals with negative scales
# 1e4 = 10000 with scale -4, log10(10000) = 4.0
query R
select log(1e4);
----
4

# log with negative scale and explicit base 10
query R
select log(10, 1e4);
----
4

# log with negative scale and base 2
# 8e1 = 80 with scale -1, log2(80) ≈ 6.321928
query R
select log(2.0, 8e1);
----
6.321928094887

# log with negative scale and base 2 (another value)
# 16e1 = 160 with scale -1, log2(160) ≈ 7.321928
query R
select log(2.0, 16e1);
----
7.321928094887

# log with negative scale -3
# 5e3 = 5000 with scale -3, log10(5000) ≈ 3.69897
query R
select log(5e3);
----
3.698970004336

# log with negative scale array values
query R rowsort
select log(value) from (values (1e3), (1e4), (1e5)) as t(value);
----
3
4
5

# log with negative scale and different bases
query R rowsort
select log(base, 1e4) from (values (10.0), (2.0), (3.0)) as t(base);
----
13.287712379549
4
8.383613097158

# power with decimals

query RT
SELECT power(2::decimal(38, 0), 4), arrow_typeof(power(2::decimal(38, 0), 4));
----
16 Decimal128(38, 0)

query RT
SELECT power(10000000000::decimal(38, 0), 2), arrow_typeof(power(10000000000::decimal(38, 0), 2));
----
100000000000000000000 Decimal128(38, 0)

query R
SELECT power(2.5, 4)
----
39

query R
SELECT power(2.5, 1)
----
2.5

query R
SELECT power(2.5, 0)
----
1

query R
SELECT power(1e4 ,2)
----
100000000

# int64 base with decimal exponent (coerced to float computation)
query R
SELECT power(10, -2.0)
----
0.01

query R
SELECT power(2, -0.5)
----
0.707106781187

# query error Unsupported data type Decimal128\(2, 1\) for power function
# SELECT power(2.5, 4.0)

# power() with very large exponent returns infinity (Float64 behavior)
query R
SELECT power(2, 100000000000)
----
Infinity

query error Arrow error: Arithmetic overflow: Unsupported exp value
SELECT power(2::decimal(38, 0), -5)

# Expected to have `16 Decimal128(38, 0)`
# Due to type coericion, it becomes Float -> Float -> Float
query RT
SELECT power(2::decimal(38, 0), 4), arrow_typeof(power(2::decimal(38, 0), 4));
----
16 Decimal128(38, 0)

# Arbitrary scale
query RT
SELECT power(2.5::decimal(38, 3), 4), arrow_typeof(power(2.5::decimal(38, 3), 4));
----
39.062 Decimal128(38, 3)

query RT
SELECT power(2.5, 4.0), arrow_typeof(power(2.5, 4.0));
----
39 Decimal128(2, 1)

query error Compute error: Cannot use non-integer exp
SELECT power(2.5, 4.2), arrow_typeof(power(2.5, 4.2));

query error Compute error: Cannot use non-integer exp: NaN
SELECT power(2::decimal(38, 0), arrow_cast('NaN','Float64'))

query error Compute error: Cannot use non-integer exp: inf
SELECT power(2::decimal(38, 0), arrow_cast('INF','Float64'))

# Floating above u32::max
query error Compute error: Cannot use non-integer exp
SELECT power(2::decimal(38, 0), 5000000000.1)

# Integer Above u32::max
query error Arrow error: Arithmetic overflow: Unsupported exp value
SELECT power(2::decimal(38, 0), 5000000000)

query ?T
SELECT power(arrow_cast(2, 'Decimal32(5, 0)'), 4), arrow_typeof(power(arrow_cast(2, 'Decimal32(5, 0)'), 4));
----
16 Decimal32(5, 0)

query ?T
SELECT power(arrow_cast(2, 'Decimal64(5, 0)'), 4), arrow_typeof(power(arrow_cast(2, 'Decimal64(5, 0)'), 4));
----
16 Decimal64(5, 0)

query RT
SELECT power(2::decimal(76, 0), 4), arrow_typeof(power(2::decimal(76, 0), 4));
----
16 Decimal256(76, 0)

query R
SELECT power(2.0, null)
----
NULL

# Array variants of power function
query RR rowsort
SELECT distinct c1*100000, power(c1*100000, 2) from decimal_simple;
----
1 1
2 4
3 9
4 16
5 25

query RR rowsort
SELECT distinct c1*100000, power(c1*100000, 2.0) from decimal_simple;
----
1 1
2 4
3 9
4 16
5 25

# Set parse_float_as_decimal to false to test float parsing
statement ok
set datafusion.sql_parser.parse_float_as_decimal = false;

# smoke test for decimal parsing
query R
select 100000000000000000000000000000000000::decimal(38,0)
----
99999999999999996863366107917975552

# log(10^35) for decimal128 with explicit decimal base
# Float parsing is rounding down
query R
select log(10, 100000000000000000000000000000000000::decimal(38,0));
----
34

# log(10^35) for large decimal128 if parsed as float
# Float parsing is rounding down
query R
select log(100000000000000000000000000000000000::decimal(38,0))
----
34

# Result is decimal since argument is decimal regardless decimals-as-floats parsing
query R
SELECT power(10000000000::decimal(38, 0), 2);
----
100000000000000000000

query RT
SELECT power(10000000000::decimal(38, 0), 2),
       arrow_typeof(power(10000000000::decimal(38, 0), 2));
----
100000000000000000000 Decimal128(38, 0)

query R
SELECT power(2.5, 4.0)
----
39.0625

query R
SELECT power(2.5, 4)
----
39.0625

query R
SELECT power(2, null)
----
NULL

query error Arrow error: Invalid argument error: 1.10 is too large to store in a Decimal128 of precision 2. Max is 0.99
select cast(1.1 as decimal(2, 2)) + 1;
