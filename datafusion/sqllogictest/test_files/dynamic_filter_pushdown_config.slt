# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Tests for dynamic filter pushdown configuration options
# - enable_topk_dynamic_filter_pushdown (for TopK dynamic filters)
# - enable_join_dynamic_filter_pushdown (for Join dynamic filters)
# - enable_aggregate_dynamic_filter_pushdown (for Aggregate dynamic filters)
# - enable_dynamic_filter_pushdown (controls all three)

# Setup: Create parquet test files
statement ok
CREATE TABLE test_data(id INT, value INT, name VARCHAR) AS VALUES
(1, 100, 'a'),
(2, 200, 'b'),
(3, 300, 'c'),
(4, 400, 'd'),
(5, 500, 'e'),
(6, 600, 'f'),
(7, 700, 'g'),
(8, 800, 'h'),
(9, 900, 'i'),
(10, 1000, 'j');

statement ok
CREATE TABLE join_left(id INT, data VARCHAR) AS VALUES
(1, 'left1'),
(2, 'left2'),
(3, 'left3'),
(4, 'left4'),
(5, 'left5');

statement ok
CREATE TABLE join_right(id INT, info VARCHAR) AS VALUES
(1, 'right1'),
(3, 'right3'),
(5, 'right5');

# Copy data to parquet files
query I
COPY test_data TO 'test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet' STORED AS PARQUET;
----
10

query I
COPY join_left TO 'test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet' STORED AS PARQUET;
----
5

query I
COPY join_right TO 'test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet' STORED AS PARQUET;
----
3

# Create external tables from parquet files
statement ok
CREATE EXTERNAL TABLE test_parquet(id INT, value INT, name VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet';

statement ok
CREATE EXTERNAL TABLE left_parquet(id INT, data VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet';

statement ok
CREATE EXTERNAL TABLE right_parquet(id INT, info VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet';

# Test 1: TopK dynamic filter pushdown with Parquet
query TT
EXPLAIN SELECT * FROM test_parquet ORDER BY value DESC LIMIT 3;
----
logical_plan
01)Sort: test_parquet.value DESC NULLS FIRST, fetch=3
02)--TableScan: test_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[value@1 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet]]}, projection=[id, value, name], file_type=parquet, predicate=DynamicFilter [ empty ]

# Disable TopK dynamic filter pushdown
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = false;

query TT
EXPLAIN SELECT * FROM test_parquet ORDER BY value DESC LIMIT 3;
----
logical_plan
01)Sort: test_parquet.value DESC NULLS FIRST, fetch=3
02)--TableScan: test_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[value@1 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet]]}, projection=[id, value, name], file_type=parquet

# Re-enable for next tests
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

# Test 2: Join dynamic filter pushdown with Parquet
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Disable Join dynamic filter pushdown
statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = false;

# Without Join filter, HashJoin should NOT have filter=DynamicFilter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Re-enable for next tests
statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

# Test 3: Test independent control

# Disable TopK, keep Join enabled
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = false;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

# Join should still have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Enable TopK, disable Join
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = false;

# Join should NOT have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Test 4: Aggregate dynamic filter pushdown

# Prepare aggregate-specific parquet data without statistics so aggregate statistics optimizer
# doesn't pre-compute results.
statement ok
CREATE TABLE agg_source(category VARCHAR, score INT) AS VALUES
('alpha', 10),
('alpha', 25),
('beta', 5),
('beta', 12),
('gamma', 42),
('gamma', 8);

statement ok
SET datafusion.execution.parquet.statistics_enabled = 'none';

statement ok
COPY agg_source TO 'test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet' STORED AS PARQUET;

statement ok
SET datafusion.execution.parquet.statistics_enabled = 'page';

statement ok
CREATE EXTERNAL TABLE agg_parquet(category VARCHAR, score INT)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet';

statement ok
SET datafusion.execution.parquet.pushdown_filters = true;

# Aggregate dynamic filter should be pushed into the scan when enabled
# Expecting a `DynamicFilter` inside parquet scanner's predicate
query TT
EXPLAIN SELECT MAX(score) FROM agg_parquet WHERE category = 'alpha'
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[max(agg_parquet.score)]]
02)--Projection: agg_parquet.score
03)----Filter: agg_parquet.category = Utf8View("alpha")
04)------TableScan: agg_parquet projection=[category, score], partial_filters=[agg_parquet.category = Utf8View("alpha")]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[max(agg_parquet.score)]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[max(agg_parquet.score)]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet]]}, projection=[score], file_type=parquet, predicate=category@0 = alpha AND DynamicFilter [ empty ], pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1, required_guarantees=[category in (alpha)]

# Disable aggregate dynamic filters only
statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = false;

# Expecting no `DynamicFilter` inside parquet scanner's predicate
query TT
EXPLAIN SELECT MAX(score) FROM agg_parquet WHERE category = 'alpha'
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[max(agg_parquet.score)]]
02)--Projection: agg_parquet.score
03)----Filter: agg_parquet.category = Utf8View("alpha")
04)------TableScan: agg_parquet projection=[category, score], partial_filters=[agg_parquet.category = Utf8View("alpha")]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[max(agg_parquet.score)]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[max(agg_parquet.score)]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet]]}, projection=[score], file_type=parquet, predicate=category@0 = alpha, pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1, required_guarantees=[category in (alpha)]

statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = true;

statement ok
SET datafusion.execution.parquet.pushdown_filters = false;

# Test 5: Backward compatibility

# First, set both new configs to specific values
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

statement ok
set datafusion.catalog.information_schema = true

# Setting the config should override both
statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = false;

# Verify all configs are now false
query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_topk_dynamic_filter_pushdown';
----
false

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_join_dynamic_filter_pushdown';
----
false

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown';
----
false

statement ok
set datafusion.catalog.information_schema = false

# Join should NOT have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Re-enable
statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = true;

statement ok
set datafusion.catalog.information_schema = true

# Verify all configs are now true
query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_topk_dynamic_filter_pushdown';
----
true

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_join_dynamic_filter_pushdown';
----
true

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown';
----
true

statement ok
set datafusion.catalog.information_schema = false

# Join should have dynamic filter again
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Cleanup

statement ok
DROP TABLE test_data;

statement ok
DROP TABLE join_left;

statement ok
DROP TABLE join_right;

statement ok
DROP TABLE test_parquet;

statement ok
DROP TABLE left_parquet;

statement ok
DROP TABLE right_parquet;

statement ok
DROP TABLE agg_source;

statement ok
DROP TABLE agg_parquet;

# Reset configs to defaults
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = true;

# Test 6: Sort Pushdown for ordered Parquet files

# Create a sorted dataset
statement ok
CREATE TABLE sorted_data(id INT, value INT, name VARCHAR) AS VALUES
(1, 100, 'a'),
(2, 200, 'b'),
(3, 300, 'c'),
(4, 400, 'd'),
(5, 500, 'e'),
(6, 600, 'f'),
(7, 700, 'g'),
(8, 800, 'h'),
(9, 900, 'i'),
(10, 1000, 'j');

# Copy to parquet with sorting
query I
COPY (SELECT * FROM sorted_data ORDER BY id ASC)
TO 'test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet';
----
10

statement ok
CREATE EXTERNAL TABLE sorted_parquet(id INT, value INT, name VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet'
WITH ORDER (id ASC);

# Test 6.1: Sort pushdown with DESC (opposite of ASC)
# Should show reverse_row_groups=true
query TT
EXPLAIN SELECT * FROM sorted_parquet ORDER BY id DESC LIMIT 3;
----
logical_plan
01)Sort: sorted_parquet.id DESC NULLS FIRST, fetch=3
02)--TableScan: sorted_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet]]}, projection=[id, value, name], file_type=parquet, predicate=DynamicFilter [ empty ], reverse_row_groups=true

# Test 6.2: Verify results are correct
query IIT
SELECT * FROM sorted_parquet ORDER BY id DESC LIMIT 3;
----
10 1000 j
9 900 i
8 800 h

# Test 6.3: Should NOT apply for ASC (same direction)
query TT
EXPLAIN SELECT * FROM sorted_parquet ORDER BY id ASC LIMIT 3;
----
logical_plan
01)Sort: sorted_parquet.id ASC NULLS LAST, fetch=3
02)--TableScan: sorted_parquet projection=[id, value, name]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet]]}, projection=[id, value, name], limit=3, output_ordering=[id@0 ASC NULLS LAST], file_type=parquet

# Test 6.4: Disable sort pushdown
statement ok
SET datafusion.optimizer.enable_sort_pushdown = false;

query TT
EXPLAIN SELECT * FROM sorted_parquet ORDER BY id DESC LIMIT 3;
----
logical_plan
01)Sort: sorted_parquet.id DESC NULLS FIRST, fetch=3
02)--TableScan: sorted_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet]]}, projection=[id, value, name], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet, predicate=DynamicFilter [ empty ]

# Re-enable
statement ok
SET datafusion.optimizer.enable_sort_pushdown = true;

# Test 6.5: With OFFSET
query TT
EXPLAIN SELECT * FROM sorted_parquet ORDER BY id DESC LIMIT 3 OFFSET 2;
----
logical_plan
01)Limit: skip=2, fetch=3
02)--Sort: sorted_parquet.id DESC NULLS FIRST, fetch=5
03)----TableScan: sorted_parquet projection=[id, value, name]
physical_plan
01)GlobalLimitExec: skip=2, fetch=3
02)--SortExec: TopK(fetch=5), expr=[id@0 DESC], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_data.parquet]]}, projection=[id, value, name], file_type=parquet, predicate=DynamicFilter [ empty ], reverse_row_groups=true

query IIT
SELECT * FROM sorted_parquet ORDER BY id DESC LIMIT 3 OFFSET 2;
----
8 800 h
7 700 g
6 600 f

# Test 6.6: Reverse scan with row selection (page index pruning)
# This tests that when reverse_row_groups=true, the RowSelection is also properly reversed

# Create a dataset with multiple row groups and enable page index
statement ok
CREATE TABLE multi_rg_data(id INT, category VARCHAR, value INT) AS VALUES
(1, 'alpha', 10),
(2, 'alpha', 20),
(3, 'beta', 30),
(4, 'beta', 40),
(5, 'gamma', 50),
(6, 'gamma', 60),
(7, 'delta', 70),
(8, 'delta', 80);

# Write with small row groups (2 rows each = 4 row groups)
statement ok
SET datafusion.execution.parquet.max_row_group_size = 2;

query I
COPY (SELECT * FROM multi_rg_data ORDER BY id ASC)
TO 'test_files/scratch/dynamic_filter_pushdown_config/multi_rg_sorted.parquet';
----
8

# Reset row group size
statement ok
SET datafusion.execution.parquet.max_row_group_size = 1048576;

statement ok
CREATE EXTERNAL TABLE multi_rg_sorted(id INT, category VARCHAR, value INT)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/multi_rg_sorted.parquet'
WITH ORDER (id ASC);

# Enable page index for better pruning
statement ok
SET datafusion.execution.parquet.enable_page_index = true;

statement ok
SET datafusion.execution.parquet.pushdown_filters = true;

# Test with reverse scan and filter that prunes some row groups
# This will create a RowSelection with partial row group scans
query TT
EXPLAIN SELECT * FROM multi_rg_sorted
WHERE category IN ('alpha', 'gamma')
ORDER BY id DESC LIMIT 5;
----
logical_plan
01)Sort: multi_rg_sorted.id DESC NULLS FIRST, fetch=5
02)--Filter: multi_rg_sorted.category = Utf8View("alpha") OR multi_rg_sorted.category = Utf8View("gamma")
03)----TableScan: multi_rg_sorted projection=[id, category, value], partial_filters=[multi_rg_sorted.category = Utf8View("alpha") OR multi_rg_sorted.category = Utf8View("gamma")]
physical_plan
01)SortExec: TopK(fetch=5), expr=[id@0 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/multi_rg_sorted.parquet]]}, projection=[id, category, value], file_type=parquet, predicate=(category@1 = alpha OR category@1 = gamma) AND DynamicFilter [ empty ], reverse_row_groups=true, pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1 OR category_null_count@2 != row_count@3 AND category_min@0 <= gamma AND gamma <= category_max@1, required_guarantees=[category in (alpha, gamma)]

# Verify the results are correct despite reverse scanning with row selection
# Expected: gamma values (6, 5) then alpha values (2, 1), in DESC order by id
query ITI
SELECT * FROM multi_rg_sorted
WHERE category IN ('alpha', 'gamma')
ORDER BY id DESC LIMIT 5;
----
6 gamma 60
5 gamma 50
2 alpha 20
1 alpha 10

# Test with more complex selection pattern
query ITI
SELECT * FROM multi_rg_sorted
WHERE category IN ('beta', 'delta')
ORDER BY id DESC;
----
8 delta 80
7 delta 70
4 beta 40
3 beta 30

# Test forward scan for comparison (should give same logical results in ASC order)
query ITI
SELECT * FROM multi_rg_sorted
WHERE category IN ('alpha', 'gamma')
ORDER BY id ASC;
----
1 alpha 10
2 alpha 20
5 gamma 50
6 gamma 60

# Disable reverse scan and verify it still works
statement ok
SET datafusion.optimizer.enable_sort_pushdown = false;

query ITI
SELECT * FROM multi_rg_sorted
WHERE category IN ('alpha', 'gamma')
ORDER BY id DESC LIMIT 5;
----
6 gamma 60
5 gamma 50
2 alpha 20
1 alpha 10

# Re-enable
statement ok
SET datafusion.optimizer.enable_sort_pushdown = true;

# Test 6.7: Sort pushdown with more than one partition
# Create multiple parquet files to trigger it

# Split data into multiple files
statement ok
CREATE TABLE sorted_data_part1(id INT, value INT, name VARCHAR) AS VALUES
(1, 100, 'a'),
(2, 200, 'b'),
(3, 300, 'c');

statement ok
CREATE TABLE sorted_data_part2(id INT, value INT, name VARCHAR) AS VALUES
(4, 400, 'd'),
(5, 500, 'e'),
(6, 600, 'f');

statement ok
CREATE TABLE sorted_data_part3(id INT, value INT, name VARCHAR) AS VALUES
(7, 700, 'g'),
(8, 800, 'h'),
(9, 900, 'i'),
(10, 1000, 'j');

# Create directory for multi-file parquet
query I
COPY (SELECT * FROM sorted_data_part1 ORDER BY id ASC)
TO 'test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part1.parquet';
----
3

query I
COPY (SELECT * FROM sorted_data_part2 ORDER BY id ASC)
TO 'test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part2.parquet';
----
3

query I
COPY (SELECT * FROM sorted_data_part3 ORDER BY id ASC)
TO 'test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part3.parquet';
----
4

# Create external table pointing to directory with multiple files
statement ok
CREATE EXTERNAL TABLE sorted_parquet_multi(id INT, value INT, name VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/'
WITH ORDER (id ASC);

# Enable multiple partitions
statement ok
SET datafusion.execution.target_partitions = 4;

# Now we should see RepartitionExec because we have 3 input partitions (3 files)
query TT
EXPLAIN SELECT * FROM sorted_parquet_multi ORDER BY id DESC LIMIT 3;
----
logical_plan
01)Sort: sorted_parquet_multi.id DESC NULLS FIRST, fetch=3
02)--TableScan: sorted_parquet_multi projection=[id, value, name]
physical_plan
01)SortPreservingMergeExec: [id@0 DESC], fetch=3
02)--SortExec: TopK(fetch=3), expr=[id@0 DESC], preserve_partitioning=[true]
03)----DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part1.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/sorted_multi/part3.parquet]]}, projection=[id, value, name], file_type=parquet, predicate=DynamicFilter [ empty ], reverse_row_groups=true

# Verify correctness with repartitioning and multiple files
query IIT
SELECT * FROM sorted_parquet_multi ORDER BY id DESC LIMIT 3;
----
10 1000 j
9 900 i
8 800 h

# Test ASC order (should not trigger reverse scan)
query IIT
SELECT * FROM sorted_parquet_multi ORDER BY id ASC LIMIT 3;
----
1 100 a
2 200 b
3 300 c

# Cleanup
statement ok
DROP TABLE sorted_data_part1;

statement ok
DROP TABLE sorted_data_part2;

statement ok
DROP TABLE sorted_data_part3;

statement ok
DROP TABLE sorted_parquet_multi;

# Reset to default
statement ok
SET datafusion.execution.target_partitions = 4;

# Cleanup
statement ok
DROP TABLE multi_rg_data;

statement ok
DROP TABLE multi_rg_sorted;

statement ok
SET datafusion.execution.parquet.enable_page_index = false;

statement ok
SET datafusion.execution.parquet.pushdown_filters = false;

# Cleanup
statement ok
DROP TABLE sorted_data;

statement ok
DROP TABLE sorted_parquet;

statement ok
SET datafusion.optimizer.enable_sort_pushdown = true;
