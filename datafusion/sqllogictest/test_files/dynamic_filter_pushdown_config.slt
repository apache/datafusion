# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Tests for dynamic filter pushdown configuration options
# - enable_topk_dynamic_filter_pushdown (for TopK dynamic filters)
# - enable_join_dynamic_filter_pushdown (for Join dynamic filters)
# - enable_aggregate_dynamic_filter_pushdown (for Aggregate dynamic filters)
# - enable_dynamic_filter_pushdown (controls all three)

# Setup: Create parquet test files
statement ok
CREATE TABLE test_data(id INT, value INT, name VARCHAR) AS VALUES
(1, 100, 'a'),
(2, 200, 'b'),
(3, 300, 'c'),
(4, 400, 'd'),
(5, 500, 'e'),
(6, 600, 'f'),
(7, 700, 'g'),
(8, 800, 'h'),
(9, 900, 'i'),
(10, 1000, 'j');

statement ok
CREATE TABLE join_left(id INT, data VARCHAR) AS VALUES
(1, 'left1'),
(2, 'left2'),
(3, 'left3'),
(4, 'left4'),
(5, 'left5');

statement ok
CREATE TABLE join_right(id INT, info VARCHAR) AS VALUES
(1, 'right1'),
(3, 'right3'),
(5, 'right5');

# Copy data to parquet files
query I
COPY test_data TO 'test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet' STORED AS PARQUET;
----
10

query I
COPY join_left TO 'test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet' STORED AS PARQUET;
----
5

query I
COPY join_right TO 'test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet' STORED AS PARQUET;
----
3

# Create external tables from parquet files
statement ok
CREATE EXTERNAL TABLE test_parquet(id INT, value INT, name VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet';

statement ok
CREATE EXTERNAL TABLE left_parquet(id INT, data VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet';

statement ok
CREATE EXTERNAL TABLE right_parquet(id INT, info VARCHAR)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet';

# Test 1: TopK dynamic filter pushdown with Parquet
query TT
EXPLAIN SELECT * FROM test_parquet ORDER BY value DESC LIMIT 3;
----
logical_plan
01)Sort: test_parquet.value DESC NULLS FIRST, fetch=3
02)--TableScan: test_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[value@1 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet]]}, projection=[id, value, name], file_type=parquet, predicate=DynamicFilter [ empty ]

statement ok
set datafusion.explain.analyze_level = summary;

query TT
EXPLAIN ANALYZE SELECT id, value AS v, value + id as name FROM test_parquet where value > 3 ORDER BY v DESC LIMIT 3;
----
Plan with Metrics
01)SortPreservingMergeExec: [v@1 DESC], fetch=3, metrics=[output_rows=3, <slt:ignore>]
02)--SortExec: TopK(fetch=3), expr=[v@1 DESC], preserve_partitioning=[true], filter=[v@1 IS NULL OR v@1 > 800], metrics=[output_rows=3, <slt:ignore>]
03)----ProjectionExec: expr=[id@0 as id, value@1 as v, value@1 + id@0 as name], metrics=[output_rows=10, <slt:ignore>]
04)------FilterExec: value@1 > 3, metrics=[output_rows=10, <slt:ignore>, selectivity=100% (10/10)]
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1, metrics=[output_rows=10, <slt:ignore>]
06)----------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet]]}, projection=[id, value], file_type=parquet, predicate=value@1 > 3 AND DynamicFilter [ value@1 IS NULL OR value@1 > 800 ], pruning_predicate=value_null_count@1 != row_count@2 AND value_max@0 > 3 AND (value_null_count@1 > 0 OR value_null_count@1 != row_count@2 AND value_max@0 > 800), required_guarantees=[], metrics=[output_rows=10, <slt:ignore>, files_ranges_pruned_statistics=1 total → 1 matched, row_groups_pruned_statistics=1 total → 1 matched -> 1 fully matched, row_groups_pruned_bloom_filter=1 total → 1 matched, page_index_pages_pruned=1 total → 1 matched, limit_pruned_row_groups=0 total → 0 matched, bytes_scanned=210, metadata_load_time=<slt:ignore>, scan_efficiency_ratio=18% (210/1.16 K)]

statement ok
set datafusion.explain.analyze_level = dev;

query III
SELECT id, value AS v, value + id as name FROM test_parquet where value > 3 ORDER BY v DESC LIMIT 3;
----
10 1000 1010
9 900 909
8 800 808

# Disable TopK dynamic filter pushdown
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = false;

query TT
EXPLAIN SELECT * FROM test_parquet ORDER BY value DESC LIMIT 3;
----
logical_plan
01)Sort: test_parquet.value DESC NULLS FIRST, fetch=3
02)--TableScan: test_parquet projection=[id, value, name]
physical_plan
01)SortExec: TopK(fetch=3), expr=[value@1 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/test_data.parquet]]}, projection=[id, value, name], file_type=parquet

query IIT
SELECT id, value AS v, name FROM (SELECT * FROM test_parquet UNION ALL SELECT * FROM test_parquet) ORDER BY v DESC LIMIT 3;
----
10 1000 j
10 1000 j
9 900 i

# Re-enable for next tests
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

# Test 2: Join dynamic filter pushdown with Parquet
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Disable Join dynamic filter pushdown
statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = false;

# Without Join filter, HashJoin should NOT have filter=DynamicFilter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Re-enable for next tests
statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

# Test 2b: Dynamic filter pushdown for non-inner join types
# LEFT JOIN: optimizer swaps to physical Right join (build=right_parquet, probe=left_parquet).
# Dynamic filter is NOT pushed because Right join needs all probe rows in output.
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
LEFT JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Left Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Right, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# LEFT JOIN correctness: all left rows appear, unmatched right rows produce NULLs
query ITT
SELECT l.id, l.data, r.info
FROM left_parquet l
LEFT JOIN right_parquet r ON l.id = r.id
ORDER BY l.id;
----
1 left1 right1
2 left2 NULL
3 left3 right3
4 left4 NULL
5 left5 right5

# RIGHT JOIN: optimizer swaps to physical Left join (build=right_parquet, probe=left_parquet).
# No self-generated dynamic filter (only Inner joins get that), but parent filters
# on the preserved (build) side can still push down.
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
RIGHT JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Right Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Left, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# RIGHT JOIN correctness: all right rows appear, unmatched left rows produce NULLs
query ITT
SELECT l.id, l.data, r.info
FROM left_parquet l
RIGHT JOIN right_parquet r ON l.id = r.id
ORDER BY r.id;
----
1 left1 right1
3 left3 right3
5 left5 right5

# FULL JOIN: dynamic filter should NOT be pushed (both sides must preserve all rows)
query TT
EXPLAIN SELECT l.id, r.id as rid, l.data, r.info
FROM left_parquet l
FULL JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, r.id AS rid, l.data, r.info
02)--Full Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@2 as id, id@0 as rid, data@3 as data, info@1 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Full, on=[(id@0, id@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# LEFT SEMI JOIN: optimizer swaps to RightSemi (build=right_parquet, probe=left_parquet).
# No self-generated dynamic filter (only Inner joins), but parent filters on
# the preserved (probe) side can push down.
query TT
EXPLAIN SELECT l.*
FROM left_parquet l
WHERE l.id IN (SELECT r.id FROM right_parquet r);
----
logical_plan
01)LeftSemi Join: l.id = __correlated_sq_1.id
02)--SubqueryAlias: l
03)----TableScan: left_parquet projection=[id, data]
04)--SubqueryAlias: __correlated_sq_1
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(id@0, id@0)]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id], file_type=parquet
03)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# LEFT ANTI JOIN: no self-generated dynamic filter, but parent filters can push
# to the preserved (left/build) side.
query TT
EXPLAIN SELECT l.*
FROM left_parquet l
WHERE l.id NOT IN (SELECT r.id FROM right_parquet r);
----
logical_plan
01)LeftAnti Join: l.id = __correlated_sq_1.id
02)--SubqueryAlias: l
03)----TableScan: left_parquet projection=[id, data]
04)--SubqueryAlias: __correlated_sq_1
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=LeftAnti, on=[(id@0, id@0)]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet
03)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id], file_type=parquet

# Test 2c: Parent dynamic filter (from TopK) pushed through semi/anti joins
# Sort on the join key (id) so the TopK dynamic filter pushes to BOTH sides.

# SEMI JOIN with TopK parent: TopK generates a dynamic filter on `id` (join key)
# that pushes through the RightSemi join to both the build and probe sides.
query TT
EXPLAIN SELECT l.*
FROM left_parquet l
WHERE l.id IN (SELECT r.id FROM right_parquet r)
ORDER BY l.id LIMIT 2;
----
logical_plan
01)Sort: l.id ASC NULLS LAST, fetch=2
02)--LeftSemi Join: l.id = __correlated_sq_1.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: __correlated_sq_1
06)------SubqueryAlias: r
07)--------TableScan: right_parquet projection=[id]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--HashJoinExec: mode=CollectLeft, join_type=RightSemi, on=[(id@0, id@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id], file_type=parquet, predicate=DynamicFilter [ empty ]
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Correctness check
query IT
SELECT l.*
FROM left_parquet l
WHERE l.id IN (SELECT r.id FROM right_parquet r)
ORDER BY l.id LIMIT 2;
----
1 left1
3 left3

# ANTI JOIN with TopK parent: TopK generates a dynamic filter on `id` (join key)
# that pushes through the LeftAnti join to both the preserved and non-preserved sides.
query TT
EXPLAIN SELECT l.*
FROM left_parquet l
WHERE l.id NOT IN (SELECT r.id FROM right_parquet r)
ORDER BY l.id LIMIT 2;
----
logical_plan
01)Sort: l.id ASC NULLS LAST, fetch=2
02)--LeftAnti Join: l.id = __correlated_sq_1.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: __correlated_sq_1
06)------SubqueryAlias: r
07)--------TableScan: right_parquet projection=[id]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--HashJoinExec: mode=CollectLeft, join_type=LeftAnti, on=[(id@0, id@0)]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Correctness check
query IT
SELECT l.*
FROM left_parquet l
WHERE l.id NOT IN (SELECT r.id FROM right_parquet r)
ORDER BY l.id LIMIT 2;
----
2 left2
4 left4

# Test 3: Test independent control

# Disable TopK, keep Join enabled
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = false;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

# Join should still have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Enable TopK, disable Join
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = false;

# Join should NOT have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Test 4: Aggregate dynamic filter pushdown

# Prepare aggregate-specific parquet data without statistics so aggregate statistics optimizer
# doesn't pre-compute results.
statement ok
CREATE TABLE agg_source(category VARCHAR, score INT) AS VALUES
('alpha', 10),
('alpha', 25),
('beta', 5),
('beta', 12),
('gamma', 42),
('gamma', 8);

statement ok
SET datafusion.execution.parquet.statistics_enabled = 'none';

statement ok
COPY agg_source TO 'test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet' STORED AS PARQUET;

statement ok
SET datafusion.execution.parquet.statistics_enabled = 'page';

statement ok
CREATE EXTERNAL TABLE agg_parquet(category VARCHAR, score INT)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet';

statement ok
SET datafusion.execution.parquet.pushdown_filters = true;

# Aggregate dynamic filter should be pushed into the scan when enabled
# Expecting a `DynamicFilter` inside parquet scanner's predicate
query TT
EXPLAIN SELECT MAX(score) FROM agg_parquet WHERE category = 'alpha'
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[max(agg_parquet.score)]]
02)--Projection: agg_parquet.score
03)----Filter: agg_parquet.category = Utf8View("alpha")
04)------TableScan: agg_parquet projection=[category, score], partial_filters=[agg_parquet.category = Utf8View("alpha")]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[max(agg_parquet.score)]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[max(agg_parquet.score)]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet]]}, projection=[score], file_type=parquet, predicate=category@0 = alpha AND DynamicFilter [ empty ], pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1, required_guarantees=[category in (alpha)]

# Test 4b: COUNT + MAX — DynamicFilter should NOT appear here in mixed aggregates

query TT
EXPLAIN SELECT COUNT(*), MAX(score) FROM agg_parquet WHERE category = 'alpha';
----
logical_plan
01)Projection: count(Int64(1)) AS count(*), max(agg_parquet.score)
02)--Aggregate: groupBy=[[]], aggr=[[count(Int64(1)), max(agg_parquet.score)]]
03)----Projection: agg_parquet.score
04)------Filter: agg_parquet.category = Utf8View("alpha")
05)--------TableScan: agg_parquet projection=[category, score], partial_filters=[agg_parquet.category = Utf8View("alpha")]
physical_plan
01)ProjectionExec: expr=[count(Int64(1))@0 as count(*), max(agg_parquet.score)@1 as max(agg_parquet.score)]
02)--AggregateExec: mode=Final, gby=[], aggr=[count(Int64(1)), max(agg_parquet.score)]
03)----CoalescePartitionsExec
04)------AggregateExec: mode=Partial, gby=[], aggr=[count(Int64(1)), max(agg_parquet.score)]
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
06)----------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet]]}, projection=[score], file_type=parquet, predicate=category@0 = alpha, pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1, required_guarantees=[category in (alpha)]

# Disable aggregate dynamic filters only
statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = false;

# Expecting no `DynamicFilter` inside parquet scanner's predicate
query TT
EXPLAIN SELECT MAX(score) FROM agg_parquet WHERE category = 'alpha'
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[max(agg_parquet.score)]]
02)--Projection: agg_parquet.score
03)----Filter: agg_parquet.category = Utf8View("alpha")
04)------TableScan: agg_parquet projection=[category, score], partial_filters=[agg_parquet.category = Utf8View("alpha")]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[max(agg_parquet.score)]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[max(agg_parquet.score)]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/agg_data.parquet]]}, projection=[score], file_type=parquet, predicate=category@0 = alpha, pruning_predicate=category_null_count@2 != row_count@3 AND category_min@0 <= alpha AND alpha <= category_max@1, required_guarantees=[category in (alpha)]

statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = true;

statement ok
SET datafusion.execution.parquet.pushdown_filters = false;

# Test 5: Backward compatibility

# First, set both new configs to specific values
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

statement ok
set datafusion.catalog.information_schema = true

# Setting the config should override both
statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = false;

# Verify all configs are now false
query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_topk_dynamic_filter_pushdown';
----
false

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_join_dynamic_filter_pushdown';
----
false

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown';
----
false

statement ok
set datafusion.catalog.information_schema = false

# Join should NOT have dynamic filter
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet

# Re-enable
statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = true;

statement ok
set datafusion.catalog.information_schema = true

# Verify all configs are now true
query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_topk_dynamic_filter_pushdown';
----
true

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_join_dynamic_filter_pushdown';
----
true

query T
SELECT value FROM information_schema.df_settings
WHERE name = 'datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown';
----
true

statement ok
set datafusion.catalog.information_schema = false

# Join should have dynamic filter again
query TT
EXPLAIN SELECT l.*, r.info
FROM left_parquet l
INNER JOIN right_parquet r ON l.id = r.id;
----
logical_plan
01)Projection: l.id, l.data, r.info
02)--Inner Join: l.id = r.id
03)----SubqueryAlias: l
04)------TableScan: left_parquet projection=[id, data]
05)----SubqueryAlias: r
06)------TableScan: right_parquet projection=[id, info]
physical_plan
01)ProjectionExec: expr=[id@1 as id, data@2 as data, info@0 as info]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)], projection=[info@1, id@2, data@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_right.parquet]]}, projection=[id, info], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/dynamic_filter_pushdown_config/join_left.parquet]]}, projection=[id, data], file_type=parquet, predicate=DynamicFilter [ empty ]

# Test 6: Regression test for issue #20213 - dynamic filter applied to wrong table
# when subquery join has same column names on both sides.
#
# The bug: when an outer join pushes a DynamicFilter for column "k" through an
# inner join where both sides have a column named "k", the name-based routing
# incorrectly pushed the filter to BOTH sides instead of only the correct one.
# This caused wrong results (0 rows instead of expected).

# Create tables with same column names (k, v) on both sides
statement ok
CREATE TABLE issue_20213_t1(k INT, v INT) AS
SELECT i as k, i as v FROM generate_series(1, 1000) t(i);

statement ok
CREATE TABLE issue_20213_t2(k INT, v INT) AS
SELECT i + 100 as k, i as v FROM generate_series(1, 100) t(i);

# Use small row groups to make statistics-based pruning more likely to manifest the bug
statement ok
SET datafusion.execution.parquet.max_row_group_size = 10;

query I
COPY issue_20213_t1 TO 'test_files/scratch/dynamic_filter_pushdown_config/issue_20213_t1.parquet' STORED AS PARQUET;
----
1000

query I
COPY issue_20213_t2 TO 'test_files/scratch/dynamic_filter_pushdown_config/issue_20213_t2.parquet' STORED AS PARQUET;
----
100

# Reset row group size
statement ok
SET datafusion.execution.parquet.max_row_group_size = 1000000;

statement ok
CREATE EXTERNAL TABLE t1_20213(k INT, v INT)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/issue_20213_t1.parquet';

statement ok
CREATE EXTERNAL TABLE t2_20213(k INT, v INT)
STORED AS PARQUET
LOCATION 'test_files/scratch/dynamic_filter_pushdown_config/issue_20213_t2.parquet';

# The query from issue #20213: subquery joins t1 and t2 on v, then outer
# join uses t2's k column. The dynamic filter on k from the outer join
# must only apply to t2 (k range 101-200), NOT to t1 (k range 1-1000).
query I
SELECT count(*) FROM (
    SELECT t2_20213.k as k, t1_20213.k as k2
    FROM t1_20213
    JOIN t2_20213 ON t1_20213.v = t2_20213.v
) a
JOIN t2_20213 b ON a.k = b.k
WHERE b.v < 10;
----
9

# Also verify with SELECT * to catch row-level correctness
query IIII rowsort
SELECT * FROM (
    SELECT t2_20213.k as k, t1_20213.k as k2
    FROM t1_20213
    JOIN t2_20213 ON t1_20213.v = t2_20213.v
) a
JOIN t2_20213 b ON a.k = b.k
WHERE b.v < 10;
----
101 1 101 1
102 2 102 2
103 3 103 3
104 4 104 4
105 5 105 5
106 6 106 6
107 7 107 7
108 8 108 8
109 9 109 9

statement ok
DROP TABLE issue_20213_t1;

statement ok
DROP TABLE issue_20213_t2;

statement ok
DROP TABLE t1_20213;

statement ok
DROP TABLE t2_20213;

# Cleanup

statement ok
DROP TABLE test_data;

statement ok
DROP TABLE join_left;

statement ok
DROP TABLE join_right;

statement ok
DROP TABLE test_parquet;

statement ok
DROP TABLE left_parquet;

statement ok
DROP TABLE right_parquet;

statement ok
DROP TABLE agg_source;

statement ok
DROP TABLE agg_parquet;

# Reset configs to defaults
statement ok
SET datafusion.optimizer.enable_topk_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_join_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_aggregate_dynamic_filter_pushdown = true;

statement ok
SET datafusion.optimizer.enable_dynamic_filter_pushdown = true;
