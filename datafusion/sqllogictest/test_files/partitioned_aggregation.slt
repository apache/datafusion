# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# This test file verifies the optimization for parallel aggregation on Hive-partitioned tables
# When grouping by partition columns, the plan should use SinglePartitioned (combining Partial+Final per partition)

statement ok
SET datafusion.execution.target_partitions = 4;

statement ok
CREATE TABLE staging (
    part_col INT,
    val INT
) AS VALUES
    (1, 10), (1, 11), (1, 12),
    (2, 20), (2, 21),
    (3, 30),
    (4, 40);

# Use a new location to avoid dirty state from previous runs
statement ok
CREATE EXTERNAL TABLE partitioned_table_optim (
    part_col INT,
    val INT
)
STORED AS PARQUET
LOCATION 'test_partitioned_table_optim/'
PARTITIONED BY (part_col);

statement ok
INSERT INTO partitioned_table_optim SELECT part_col, val FROM staging;

# 1. Verify plan when grouping by partition column
# Should see AggregateExec: mode=SinglePartitioned (Optimization applied!)
# Should NOT see CoalescePartitionsExec or RepartitionExec before the aggregate
query TT
EXPLAIN SELECT part_col, count(*) FROM partitioned_table_optim GROUP BY part_col ORDER BY part_col
----
logical_plan
01)Sort: partitioned_table_optim.part_col ASC NULLS LAST
02)--Projection: partitioned_table_optim.part_col, count(Int64(1)) AS count(*)
03)----Aggregate: groupBy=[[partitioned_table_optim.part_col]], aggr=[[count(Int64(1))]]
04)------TableScan: partitioned_table_optim projection=[part_col]
physical_plan
01)SortPreservingMergeExec: [part_col@0 ASC NULLS LAST]
02)--SortExec: expr=[part_col@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[part_col@0 as part_col, count(Int64(1))@1 as count(*)]
04)------AggregateExec: mode=SinglePartitioned, gby=[part_col@0 as part_col], aggr=[count(Int64(1))]
05)--------DataSourceExec: file_groups={.* groups: \[\[.*\]\]}, projection=[part_col], file_type=parquet

# Verify results
query II
SELECT part_col, count(*) FROM partitioned_table_optim GROUP BY part_col ORDER BY part_col
----
1 3
2 2
3 1
4 1

# 2. Verify plan when grouping by partition column + other column
# Should still use SinglePartitioned because partition key is a subset
query TT
EXPLAIN SELECT part_col, val, count(*) FROM partitioned_table_optim GROUP BY part_col, val ORDER BY part_col, val
----
logical_plan
01)Sort: partitioned_table_optim.part_col ASC NULLS LAST, partitioned_table_optim.val ASC NULLS LAST
02)--Projection: partitioned_table_optim.part_col, partitioned_table_optim.val, count(Int64(1)) AS count(*)
03)----Aggregate: groupBy=[[partitioned_table_optim.part_col, partitioned_table_optim.val]], aggr=[[count(Int64(1))]]
04)------TableScan: partitioned_table_optim projection=[val, part_col]
physical_plan
01)SortPreservingMergeExec: [part_col@0 ASC NULLS LAST, val@1 ASC NULLS LAST]
02)--SortExec: expr=[part_col@0 ASC NULLS LAST, val@1 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[part_col@0 as part_col, val@1 as val, count(Int64(1))@2 as count(*)]
04)------AggregateExec: mode=SinglePartitioned, gby=[part_col@1 as part_col, val@0 as val], aggr=[count(Int64(1))]
05)--------DataSourceExec: file_groups={.*}, projection=[val, part_col], file_type=parquet

# 3. Verify fallback when grouping by non-partition column
# Should use FinalPartitioned and Repartition (not SinglePartitioned)
query TT
EXPLAIN SELECT val, count(*) FROM partitioned_table_optim GROUP BY val ORDER BY val
----
logical_plan
01)Sort: partitioned_table_optim.val ASC NULLS LAST
02)--Projection: partitioned_table_optim.val, count(Int64(1)) AS count(*)
03)----Aggregate: groupBy=[[partitioned_table_optim.val]], aggr=[[count(Int64(1))]]
04)------TableScan: partitioned_table_optim projection=[val]
physical_plan
01)SortPreservingMergeExec: [val@0 ASC NULLS LAST]
02)--SortExec: expr=[val@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[val@0 as val, count(Int64(1))@1 as count(*)]
04)------AggregateExec: mode=FinalPartitioned, gby=[val@0 as val], aggr=[count(Int64(1))]
05)--------CoalesceBatchesExec: target_batch_size=8192
06)----------RepartitionExec: partitioning=Hash([val@0], 4), input_partitions=.*
07)------------AggregateExec: mode=Partial, gby=[val@0 as val], aggr=[count(Int64(1))]
08)--------------DataSourceExec: file_groups={.*}, projection=[val], file_type=parquet

# 4. Verify fallback when optimization is disabled
# We must create a NEW table after setting the config, because ListingOptions are baked in at creation
statement ok
SET datafusion.execution.listing_table_preserve_partition_values = false;

statement ok
CREATE EXTERNAL TABLE partitioned_table_disabled (
    part_col INT,
    val INT
)
STORED AS PARQUET
LOCATION 'test_partitioned_table_optim/'
PARTITIONED BY (part_col);

query TT
EXPLAIN SELECT part_col, count(*) FROM partitioned_table_disabled GROUP BY part_col ORDER BY part_col
----
logical_plan
01)Sort: partitioned_table_disabled.part_col ASC NULLS LAST
02)--Projection: partitioned_table_disabled.part_col, count(Int64(1)) AS count(*)
03)----Aggregate: groupBy=[[partitioned_table_disabled.part_col]], aggr=[[count(Int64(1))]]
04)------TableScan: partitioned_table_disabled projection=[part_col]
physical_plan
01)SortPreservingMergeExec: [part_col@0 ASC NULLS LAST]
02)--SortExec: expr=[part_col@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[part_col@0 as part_col, count(Int64(1))@1 as count(*)]
04)------AggregateExec: mode=FinalPartitioned, gby=[part_col@0 as part_col], aggr=[count(Int64(1))]
05)--------CoalesceBatchesExec: target_batch_size=8192
06)----------RepartitionExec: partitioning=Hash([part_col@0], 4), input_partitions=4
07)------------AggregateExec: mode=Partial, gby=[part_col@0 as part_col], aggr=[count(Int64(1))]
08)--------------DataSourceExec: file_groups={.*}, projection=[part_col], file_type=parquet

# Cleanup
statement ok
DROP TABLE partitioned_table_optim;

statement ok
DROP TABLE partitioned_table_disabled;

statement ok
DROP TABLE staging;

