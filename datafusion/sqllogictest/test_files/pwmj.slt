# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


statement ok 
set datafusion.execution.target_partitions = 1;

statement ok
CREATE TABLE join_t1 (t1_id INT);

statement ok
CREATE TABLE join_t2 (t2_id INT, t2_name TEXT, t2_int INT);

statement ok
INSERT INTO join_t1 VALUES (11), (22), (33), (44);

statement ok
INSERT INTO join_t2 VALUES
  (11, 'z', 3),
  (22, 'y', 1),
  (44, 'x', 3),
  (55, 'w', 3);

# --- sanity: ITI matches your sample -------------------------------------------------
query ITI
SELECT t2_id, t2_name, t2_int
FROM join_t2
ORDER BY t2_id;
----
11 z 3
22 y 1
44 x 3
55 w 3

# =====================================================================================
# PWMJ candidates: exactly one join range predicate; any extra filters are per-side.
# =====================================================================================

# 1)  GT with pushdowns (your exact example)
query II
SELECT t1.t1_id, t2.t2_id
FROM join_t1 t1
JOIN join_t2 t2
  ON t1.t1_id > t2.t2_id          -- single join predicate (range)
WHERE t1.t1_id > 10               -- left pushdown
  AND t2.t2_int > 1               -- right pushdown
ORDER BY 1;
----
22 11
33 11
44 11

# 2)  GTE; right pushed to equality (t2_int = 3)
query II
SELECT t1.t1_id, t2.t2_id
FROM join_t1 t1
JOIN join_t2 t2
  ON t1.t1_id >= t2.t2_id
WHERE t1.t1_id >= 22
  AND t2.t2_int = 3
ORDER BY 1,2;
----
22 11
33 11
44 11
44 44

query II
SELECT t1.t1_id, t2.t2_id
FROM join_t1 t1
JOIN join_t2 t2
  ON t1.t1_id < t2.t2_id
WHERE t2.t2_int >= 3
ORDER BY 1,2;
----
11 55
11 44
22 55
22 44
33 55
33 44
44 55

query TT 
EXPLAIN
SELECT t1.t1_id, t2.t2_id
FROM join_t1 t1
JOIN join_t2 t2
  ON t1.t1_id < t2.t2_id
WHERE t2.t2_int >= 3
ORDER BY 1,2;
----
logical_plan
01)Sort: t1.t1_id ASC NULLS LAST, t2.t2_id ASC NULLS LAST
02)--Inner Join:  Filter: t1.t1_id < t2.t2_id
03)----SubqueryAlias: t1
04)------TableScan: join_t1 projection=[t1_id]
05)----SubqueryAlias: t2
06)------Projection: join_t2.t2_id
07)--------Filter: join_t2.t2_int >= Int32(3)
08)----------TableScan: join_t2 projection=[t2_id, t2_int]
physical_plan
01)SortExec: expr=[t1_id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--PiecewiseMergeJoin: operator=Lt, join_type=Inner, on=(t1_id < t2_id)
03)----SortExec: expr=[t1_id@0 DESC NULLS LAST], preserve_partitioning=[false]
04)------DataSourceExec: partitions=1, partition_sizes=[1]
05)----CoalesceBatchesExec: target_batch_size=8192
06)------FilterExec: t2_int@1 >= 3, projection=[t2_id@0]
07)--------DataSourceExec: partitions=1, partition_sizes=[1]


query II
SELECT t1.t1_id, t2.t2_id
FROM join_t1 t1
JOIN join_t2 t2
  ON t1.t1_id <= t2.t2_id
WHERE t1.t1_id IN (11, 44)
  AND t2.t2_name <> 'y'
ORDER BY 1,2;
----
11 55
11 44
11 11
44 55
44 44


