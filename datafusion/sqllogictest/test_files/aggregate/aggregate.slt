# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#######
# Setup test data table
#######
include ./init.slt.part

# FIX: custom absolute values
# csv_query_avg_multi_batch

# csv_query_avg
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT avg(c12) FROM aggregate_test_100

# csv_query_bit_and
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_and(c5), bit_and(c6), bit_and(c7), bit_and(c8), bit_and(c9) FROM aggregate_test_100

# csv_query_bit_and_distinct
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_and(distinct c5), bit_and(distinct c6), bit_and(distinct c7), bit_and(distinct c8), bit_and(distinct c9) FROM aggregate_test_100

# csv_query_bit_or
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_or(c5), bit_or(c6), bit_or(c7), bit_or(c8), bit_or(c9) FROM aggregate_test_100

# csv_query_bit_or_distinct
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_or(distinct c5), bit_or(distinct c6), bit_or(distinct c7), bit_or(distinct c8), bit_or(distinct c9) FROM aggregate_test_100

# csv_query_bit_xor
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_xor(c5), bit_xor(c6), bit_xor(c7), bit_xor(c8), bit_xor(c9) FROM aggregate_test_100

# csv_query_bit_xor_distinct (should be different than above)
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_xor(distinct c5), bit_xor(distinct c6), bit_xor(distinct c7), bit_xor(distinct c8), bit_xor(distinct c9) FROM aggregate_test_100

# csv_query_bit_xor_distinct_expr
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT bit_xor(distinct c5 % 2) FROM aggregate_test_100

# csv_query_covariance_1
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT covar_pop(c2, c12) FROM aggregate_test_100

# csv_query_covariance_2
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT covar(c2, c12) FROM aggregate_test_100

# single_row_query_covar_1
query R
select covar_samp(sq.column1, sq.column2) from (values (1.1, 2.2)) as sq
----
NULL

# single_row_query_covar_2
query R
select covar_pop(sq.column1, sq.column2) from (values (1.1, 2.2)) as sq
----
0

# all_nulls_query_covar
query RR
with data as (
  select null::int as f, null::int as b
  union all
  select null::int as f, null::int as b
)
select covar_samp(f, b), covar_pop(f, b)
from data
----
NULL NULL

# covar_query_with_nulls
query RR
with data as (
  select 1 as f,       4 as b
  union all
  select null as f,   99 as b
  union all
  select 2 as f,       5 as b
  union all
  select 98 as f,   null as b
  union all
  select 3 as f,       6 as b
  union all
  select null as f, null as b
)
select covar_samp(f, b), covar_pop(f, b)
from data
----
1 0.666666666667

# csv_query_correlation
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT corr(c2, c12) FROM aggregate_test_100

# single_row_query_correlation
query R
select corr(sq.column1, sq.column2) from (values (1.1, 2.2)) as sq
----
0

# all_nulls_query_correlation
query R
with data as (
  select null::int as f, null::int as b
  union all
  select null::int as f, null::int as b
)
select corr(f, b)
from data
----
NULL

# correlation_query_with_nulls
query R
with data as (
  select 1 as f,       4 as b
  union all
  select null as f,   99 as b
  union all
  select 2 as f,       5 as b
  union all
  select 98 as f,   null as b
  union all
  select 3 as f,       6 as b
  union all
  select null as f, null as b
)
select corr(f, b)
from data
----
1

# csv_query_variance_1
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_pop(c2) FROM aggregate_test_100

# csv_query_variance_2
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_pop(c6) FROM aggregate_test_100

# csv_query_variance_3
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_pop(c12) FROM aggregate_test_100

# csv_query_variance_4
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var(c2) FROM aggregate_test_100

# csv_query_distinct_variance
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var(distinct c2) FROM aggregate_test_100

statement error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var(c2), var(distinct c2) FROM aggregate_test_100

# csv_query_distinct_variance_population
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_pop(distinct c2) FROM aggregate_test_100

statement error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_pop(c2), var_pop(distinct c2) FROM aggregate_test_100

# csv_query_variance_5
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT var_samp(c2) FROM aggregate_test_100

# csv_query_stddev_1
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT stddev_pop(c2) FROM aggregate_test_100

# csv_query_stddev_2
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT stddev_pop(c6) FROM aggregate_test_100

# csv_query_stddev_3
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT stddev_pop(c12) FROM aggregate_test_100

# csv_query_stddev_4
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT stddev(c12) FROM aggregate_test_100

# csv_query_stddev_5
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT stddev_samp(c12) FROM aggregate_test_100

# csv_query_stddev_6
query R
select stddev(sq.column1) from (values (1.1), (2.0), (3.0)) as sq
----
0.950438495292

# csv_query_stddev_7
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, stddev_samp(c12) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# csv_query_stddev_8
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, stddev_pop(c12) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# csv_query_stddev_9
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, var_pop(c12) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# csv_query_stddev_10
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, var_samp(c12) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# csv_query_stddev_11
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, var_samp(c12) FROM aggregate_test_100 WHERE c12 > 0.90 GROUP BY c2 ORDER BY c2

# Use PostgresSQL dialect
statement ok
set datafusion.sql_parser.dialect = 'Postgres';

# csv_query_stddev_12
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, var_samp(c12) FILTER (WHERE c12 > 0.95) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# Restore the default dialect
statement ok
set datafusion.sql_parser.dialect = 'Generic';

# csv_query_stddev_13
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c2, var_samp(CASE WHEN c12 > 0.90 THEN c12 ELSE null END) FROM aggregate_test_100 GROUP BY c2 ORDER BY c2

# csv_query_external_table_count
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT COUNT(c12) FROM aggregate_test_100

# csv_query_external_table_sum
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT SUM(CAST(c7 AS BIGINT)), SUM(CAST(c8 AS BIGINT)) FROM aggregate_test_100

# csv_query_count
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT count(c12) FROM aggregate_test_100

# csv_query_count_distinct
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT count(distinct c2) FROM aggregate_test_100

# csv_query_count_distinct_expr
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT count(distinct c2 % 2) FROM aggregate_test_100

# csv_query_count_star
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT COUNT(*) FROM aggregate_test_100

query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT COUNT(aggregate_test_100.*) FROM aggregate_test_100

query error Error during planning: Invalid qualifier foo
SELECT COUNT(foo.*) FROM aggregate_test_100

# csv_query_count_literal
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT COUNT(2) FROM aggregate_test_100

# csv_query_approx_count
# FIX: https://github.com/apache/datafusion/issues/3353
# query II
# SELECT approx_distinct(c9) AS count_c9, approx_distinct(cast(c9 as varchar)) count_c9_str FROM aggregate_test_100
# ----
# 100 99

# csv_query_approx_count_dupe_expr_aliased
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT approx_distinct(c9) AS a, approx_distinct(c9) AS b FROM aggregate_test_100

# csv_query_cube_avg
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, AVG(c3) FROM aggregate_test_100 GROUP BY CUBE (c1, c2) ORDER BY c1, c2

# csv_query_rollup_avg
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, c3, AVG(c4) FROM aggregate_test_100 WHERE c1 IN ('a', 'b', NULL) GROUP BY ROLLUP (c1, c2, c3) ORDER BY c1, c2, c3

# csv_query_groupingsets_avg
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, c3, AVG(c4)
FROM aggregate_test_100
WHERE c1 IN ('a', 'b', NULL)
GROUP BY GROUPING SETS ((c1), (c1,c2), (c1,c2,c3))
ORDER BY c1, c2, c3

# csv_query_singlecol_with_rollup_avg
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, c3, AVG(c4)
FROM aggregate_test_100
WHERE c1 IN ('a', 'b', NULL)
GROUP BY c1, ROLLUP (c2, c3)
ORDER BY c1, c2, c3

# csv_query_sum_crossjoin
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT a.c1, b.c1, SUM(a.c2) FROM aggregate_test_100 as a CROSS JOIN aggregate_test_100 as b GROUP BY a.c1, b.c1 ORDER BY a.c1, b.c1

# csv_query_cube_sum_crossjoin
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT a.c1, b.c1, SUM(a.c2) FROM aggregate_test_100 as a CROSS JOIN aggregate_test_100 as b GROUP BY CUBE (a.c1, b.c1) ORDER BY a.c1, b.c1

# csv_query_cube_distinct_count
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, COUNT(DISTINCT c3) FROM aggregate_test_100 GROUP BY CUBE (c1,c2) ORDER BY c1,c2

# csv_query_rollup_distinct_count
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT c1, c2, COUNT(DISTINCT c3) FROM aggregate_test_100 GROUP BY ROLLUP (c1,c2) ORDER BY c1,c2

# csv_query_rollup_sum_crossjoin
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT a.c1, b.c1, SUM(a.c2) FROM aggregate_test_100 as a CROSS JOIN aggregate_test_100 as b GROUP BY ROLLUP (a.c1, b.c1) ORDER BY a.c1, b.c1

# query_count_without_from
query I
SELECT count(1 + 1)
----
1


# aggregate
query II
SELECT SUM(c1), SUM(c2) FROM test
----
7 6

# aggregate_empty

query II
SELECT SUM(c1), SUM(c2) FROM test where c1 > 100000
----
NULL NULL

# aggregate_avg
query RR
SELECT AVG(c1), AVG(c2) FROM test
----
1.75 1.5

# aggregate_max
query II
SELECT MAX(c1), MAX(c2) FROM test
----
3 2

# aggregate_min
query II
SELECT MIN(c1), MIN(c2) FROM test
----
0 1

query error min/max was called with 2 arguments. It requires only 1.
SELECT MIN(c1, c2) FROM test

query error min/max was called with 2 arguments. It requires only 1.
SELECT MAX(c1, c2) FROM test

# aggregate_grouped
query II
SELECT c1, SUM(c2) FROM test GROUP BY c1 order by c1
----
0 NULL
1 1
3 4
NULL 1

# aggregate_grouped_avg
query IR
SELECT c1, AVG(c2) FROM test GROUP BY c1 order by c1
----
0 NULL
1 1
3 2
NULL 1

# aggregate_grouped_empty
query IR
SELECT c1, AVG(c2) FROM test WHERE c1 = 123 GROUP BY c1
----

# aggregate_grouped_max
query II
SELECT c1, MAX(c2) FROM test GROUP BY c1 order by c1
----
0 NULL
1 1
3 2
NULL 1

# aggregate_grouped_min
query II
SELECT c1, MIN(c2) FROM test GROUP BY c1 order by c1
----
0 NULL
1 1
3 2
NULL 1

# aggregate_min_max_w_custom_window_frames
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT
MIN(c12) OVER (ORDER BY C12 RANGE BETWEEN 0.3 PRECEDING AND 0.2 FOLLOWING) as min1,
MAX(c12) OVER (ORDER BY C11 RANGE BETWEEN 0.1 PRECEDING AND 0.2 FOLLOWING) as max1
FROM aggregate_test_100
ORDER BY C9
LIMIT 5

# aggregate_min_max_with_custom_window_frames_unbounded_start
query error DataFusion error: Object Store error: Object at location /home/logan/dev/datafusion/testing/data/csv/aggregate_test_100\.csv not found: No such file or directory \(os error 2\)
SELECT
MIN(c12) OVER (ORDER BY C12 RANGE BETWEEN UNBOUNDED PRECEDING AND 0.2 FOLLOWING) as min1,
MAX(c12) OVER (ORDER BY C11 RANGE BETWEEN UNBOUNDED PRECEDING AND 0.2 FOLLOWING) as max1
FROM aggregate_test_100
ORDER BY C9
LIMIT 5

# aggregate_avg_add
query RRRR
SELECT AVG(c1), AVG(c1) + 1, AVG(c1) + 2, 1 + AVG(c1) FROM test
----
1.75 2.75 3.75 2.75

# case_sensitive_identifiers_aggregates
query I
SELECT max(c1) FROM test;
----
3



# count_basic
statement ok
create table t (c int) as values (1), (2), (null), (3), (null), (4), (5);

query IT
select count(c), arrow_typeof(count(c)) from t;
----
5 Int64

statement ok
drop table t;

# test count with all nulls
statement ok
create table t (c int) as values (null), (null), (null), (null), (null);

query IT
select count(c), arrow_typeof(count(c)) from t;
----
0 Int64

statement ok
drop table t;

# test with empty
statement ok
create table t (c int);

query IT
select count(c), arrow_typeof(count(c)) from t;
----
0 Int64

statement ok
drop table t;

# test count with string
statement ok
create table t (c string) as values ('a'), ('b'), (null), ('c'), (null), ('d'), ('e');

query IT
select count(c), arrow_typeof(count(c)) from t;
----
5 Int64

statement ok
drop table t;

# test count with largeutf8
statement ok
create table t (c string) as values 
  (arrow_cast('a', 'LargeUtf8')),
  (arrow_cast('b', 'LargeUtf8')),
  (arrow_cast(null, 'LargeUtf8')),
  (arrow_cast('c', 'LargeUtf8'))
;

query T
select arrow_typeof(c) from t;
----
Utf8
Utf8
Utf8
Utf8

query IT
select count(c), arrow_typeof(count(c)) from t;
----
3 Int64

statement ok
drop table t;

# test count with multiple columns
statement ok
create table t (c1 int, c2 int) as values (1, 1), (2, null), (null, 2), (null, null), (3, 3), (null, 4);

query IT
select count(c1, c2), arrow_typeof(count(c1, c2)) from t;
----
2 Int64

statement ok
drop table t;


query II
SELECT COUNT(c1), COUNT(c2) FROM test
----
4 4


statement ok
CREATE EXTERNAL TABLE partitioned_test (c1 int, c2 bigint, c3 boolean)
STORED AS CSV LOCATION '../core/tests/data/partitioned_csv'
OPTIONS('format.has_header' 'false');

# count partitioned
query II
SELECT COUNT(c1), COUNT(c2) FROM partitioned_test
----
44 44

# count partitioned with multiple columns
query I
SELECT COUNT(c1,c2) FROM partitioned_test
----
44

statement ok
DROP TABLE partitioned_test;


# count aggregated
query II
SELECT c1, count(c2) FROM test WHERE c1 IS NOT NULL group by c1 order by c1
----
0 0
1 1
3 2

statement ok
create table table_agg_cube (c1 int, c2 int, c3 int) as values (1, 1, 1), (1, 2, 2), (1, 3, 3), (2, 1, 1), (2, 2, 2), (2, 3, 3), (3, 1, 1), (3, 2, 2), (3, 3, 3);

# count aggregated cube
query III
SELECT c1, c2, count(c3) FROM table_agg_cube GROUP BY CUBE (c1, c2) ORDER BY c1, c2
----
1 1 1
1 2 1
1 3 1
1 NULL 3
2 1 1
2 2 1
2 3 1
2 NULL 3
3 1 1
3 2 1
3 3 1
3 NULL 3
NULL 1 3
NULL 2 3
NULL 3 3
NULL NULL 9

statement ok
drop table table_agg_cube;

# count_multi_expr
query I
SELECT count(c1, c2) FROM test
----
3

# count(distinct) with multiple arguments
query error DataFusion error: This feature is not implemented: COUNT DISTINCT with multiple arguments
SELECT count(distinct c1, c2) FROM test

# count_null
query III
SELECT count(null), count(null, null), count(distinct null) FROM test
----
0 0 0

# count_multi_expr_group_by
query I
SELECT count(c1, c2) FROM test group by c1 order by c1
----
0
1
2
0

# count_null_group_by
query III
SELECT count(null), count(null, null), count(distinct null) FROM test group by c1 order by c1
----
0 0 0
0 0 0
0 0 0
0 0 0

# aggreggte_with_alias
query II
select c1, sum(c2) as `Total Salary` from test group by c1 order by c1
----
0 NULL
1 1
3 4
NULL 1

# simple_avg

query R
select avg(c1) from test
----
1.75

# avg_decimal
statement ok
create table t (c1 decimal(10, 0)) as values (1), (2), (3), (4), (5), (6);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3.5 Decimal128(14, 4)

statement ok
drop table t;

# avg_decimal_with_nulls
statement ok
create table t (c1 decimal(10, 0)) as values (1), (NULL), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3.25 Decimal128(14, 4)

statement ok
drop table t;

# avg_decimal_all_nulls
statement ok
create table t (c1 decimal(10, 0)) as values (NULL), (NULL), (NULL), (NULL), (NULL), (NULL);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
NULL Decimal128(14, 4)

statement ok
drop table t;

# avg_i32
statement ok
create table t (c1 int) as values (1), (2), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3 Float64

statement ok
drop table t;

# avg_i32_with_nulls
statement ok
create table t (c1 int) as values (1), (NULL), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3.25 Float64

statement ok
drop table t;

# avg_i32_all_nulls
statement ok
create table t (c1 int) as values (NULL), (NULL);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
NULL Float64

statement ok
drop table t;

# avg_u32
statement ok
create table t (c1 int unsigned) as values (1), (2), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3 Float64

statement ok
drop table t;

# avg_f32
statement ok
create table t (c1 float) as values (1), (2), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3 Float64

statement ok
drop table t;

# avg_f64
statement ok
create table t (c1 double) as values (1), (2), (3), (4), (5);

query RT
select avg(c1), arrow_typeof(avg(c1)) from t;
----
3 Float64

statement ok
drop table t;

# covariance_f64_1
statement ok
create table t (c1 double, c2 double) as values (1, 4), (2, 5), (3, 6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.666666666667 Float64

statement ok
drop table t;

# covariance_f64_2
statement ok
create table t (c1 double, c2 double) as values (1, 4), (2, 5), (3, 6);

query RT
select covar_samp(c1, c2), arrow_typeof(covar_samp(c1, c2)) from t;
----
1 Float64

statement ok
drop table t;

# covariance_f64_4
statement ok
create table t (c1 double, c2 double) as values (1.1, 4.1), (2.0, 5.0), (3.0, 6.0);

query RT
select covar_samp(c1, c2), arrow_typeof(covar_samp(c1, c2)) from t;
----
0.903333333333 Float64

statement ok
drop table t;

# covariance_f64_5
statement ok
create table t (c1 double, c2 double) as values (1.1, 4.1), (2.0, 5.0), (3.0, 6.0);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.602222222222 Float64

statement ok
drop table t;

# covariance_f64_6
statement ok
create table t (c1 double, c2 double) as values (1.0, 4.0), (2.0, 5.0), (3.0, 6.0), (1.1, 4.4), (2.2, 5.5), (3.3, 6.6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.761666666667 Float64

statement ok
drop table t;

# covariance_i32
statement ok
create table t (c1 int, c2 int) as values (1, 4), (2, 5), (3, 6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.666666666667 Float64

statement ok
drop table t;

# covariance_u32
statement ok
create table t (c1 int unsigned, c2 int unsigned) as values (1, 4), (2, 5), (3, 6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.666666666667 Float64

statement ok
drop table t;

# covariance_f32
statement ok
create table t (c1 float, c2 float) as values (1, 4), (2, 5), (3, 6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.666666666667 Float64

statement ok
drop table t;

# covariance_i32_with_nulls_1
statement ok
create table t (c1 int, c2 int) as values (1, 4), (null, null), (3, 6);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
1 Float64

statement ok
drop table t;

# covariance_i32_with_nulls_2
statement ok
create table t (c1 int, c2 int) as values (1, 4), (null, 9), (2, 5), (null, 8), (3, 6), (null, null);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0.666666666667 Float64

statement ok
drop table t;

# covariance_i32_with_nulls_3
statement ok
create table t (c1 int, c2 int) as values (1, 4), (null, 9), (2, 5), (null, 8), (3, 6), (null, null);

query RT
select covar_samp(c1, c2), arrow_typeof(covar_samp(c1, c2)) from t;
----
1 Float64

statement ok
drop table t;

# covariance_i32_all_nulls
statement ok
create table t (c1 int, c2 int) as values (null, null), (null, null);

query RT
select covar_samp(c1, c2), arrow_typeof(covar_samp(c1, c2)) from t;
----
NULL Float64

statement ok
drop table t;

# covariance_pop_i32_all_nulls
statement ok
create table t (c1 int, c2 int) as values (null, null), (null, null);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
NULL Float64

statement ok
drop table t;

# covariance_1_input
statement ok
create table t (c1 double, c2 double) as values (1, 2);

query RT
select covar_samp(c1, c2), arrow_typeof(covar_samp(c1, c2)) from t;
----
NULL Float64

statement ok
drop table t;

# covariance_pop_1_input
statement ok
create table t (c1 double, c2 double) as values (1, 2);

query RT
select covar_pop(c1, c2), arrow_typeof(covar_pop(c1, c2)) from t;
----
0 Float64

statement ok
drop table t;

# variance_f64_1
statement ok
create table t (c double) as values (1), (2), (3), (4), (5);

query RT
select var(c), arrow_typeof(var(c)) from t;
----
2.5 Float64

statement ok
drop table t;

# aggregate stddev f64_1
statement ok
create table t (c1 double) as values (1), (2);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
0.5 Float64

statement ok
drop table t;

# aggregate stddev f64_2
statement ok
create table t (c1 double) as values (1.1), (2), (3);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
0.776029781788 Float64

statement ok
drop table t;

# aggregate stddev f64_3
statement ok
create table t (c1 double) as values (1), (2), (3), (4), (5);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
1.414213562373 Float64

statement ok
drop table t;

# aggregate stddev f64_4
statement ok
create table t (c1 double) as values (1.1), (2), (3);

query RT
select stddev(c1), arrow_typeof(stddev(c1)) from t;
----
0.950438495292 Float64

statement ok
drop table t;

# aggregate stddev i32
statement ok
create table t (c1 int) as values (1), (2), (3), (4), (5);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
1.414213562373 Float64

statement ok
drop table t;

# aggregate stddev u32
statement ok
create table t (c1 int unsigned) as values (1), (2), (3), (4), (5);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
1.414213562373 Float64

statement ok
drop table t;

# aggregate stddev f32
statement ok
create table t (c1 float) as values (1), (2), (3), (4), (5);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
1.414213562373 Float64

statement ok
drop table t;

# aggregate stddev single_input
statement ok
create table t (c1 double) as values (1);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
0 Float64

statement ok
drop table t;

# aggregate stddev with_nulls
statement ok
create table t (c1 int) as values (1), (null), (3), (4), (5);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
1.479019945775 Float64

statement ok
drop table t;

# aggregate stddev all_nulls
statement ok
create table t (c1 int) as values (null), (null);

query RT
select stddev_pop(c1), arrow_typeof(stddev_pop(c1)) from t;
----
NULL Float64

statement ok
drop table t;

# aggregate variance f64_1
statement ok
create table t (c1 double) as values (1), (2);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
0.25 Float64

statement ok
drop table t;

# aggregate variance f64_2
statement ok
create table t (c1 double) as values (1), (2), (3), (4), (5);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
2 Float64

statement ok
drop table t;

# aggregate variance f64_3
statement ok
create table t (c1 double) as values (1), (2), (3), (4), (5);

query RT
select var(c1), arrow_typeof(var(c1)) from t;
----
2.5 Float64

statement ok
drop table t;

# variance_f64_2
statement ok
create table t (c double) as values (1.1), (2), (3);

query RT
select var(c), arrow_typeof(var(c)) from t;
----
0.903333333333 Float64

statement ok
drop table t;

# aggregate variance f64_4
statement ok
create table t (c1 double) as values (1.1), (2), (3);

query RT
select var(c1), arrow_typeof(var(c1)) from t;
----
0.903333333333 Float64

statement ok
drop table t;

# variance_1_input
statement ok
create table t (a double not null) as values (1);

query RT
select var(a), arrow_typeof(var(a)) from t;
----
NULL Float64

statement ok
drop table t;

# variance_i32_all_nulls
statement ok
create table t (a int) as values (null), (null);

query RT
select var(a), arrow_typeof(var(a)) from t;
----
NULL Float64

statement ok
drop table t;

# aggregate variance i32
statement ok
create table t (c1 int) as values (1), (2), (3), (4), (5);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
2 Float64

statement ok
drop table t;

# aggregate variance u32
statement ok
create table t (c1 int unsigned) as values (1), (2), (3), (4), (5);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
2 Float64

statement ok
drop table t;

# aggregate variance f32
statement ok
create table t (c1 float) as values (1), (2), (3), (4), (5);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
2 Float64

statement ok
drop table t;

# aggregate single input
statement ok
create table t (c1 double) as values (1);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
0 Float64

statement ok
drop table t;

# aggregate i32 with nulls
statement ok
create table t (c1 int) as values (1), (null), (3), (4), (5);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
2.1875 Float64

statement ok
drop table t;

# aggregate i32 all nulls
statement ok
create table t (c1 int) as values (null), (null);

query RT
select var_pop(c1), arrow_typeof(var_pop(c1)) from t;
----
NULL Float64

statement ok
drop table t;

# simple_mean
query R
select mean(c1) from test
----
1.75

# aggregate sum distinct, coerced result from i32 to i64
statement ok
create table t (c int) as values (1), (2), (1), (3), (null), (null), (-3), (-3);

query IT
select sum(distinct c), arrow_typeof(sum(distinct c)) from t;
----
3 Int64

statement ok
drop table t;

# aggregate sum distinct, coerced result from u32 to u64
statement ok
create table t (c int unsigned) as values (1), (2), (1), (3), (null), (null), (3);

query IT
select sum(distinct c), arrow_typeof(sum(distinct c)) from t;
----
6 UInt64

statement ok
drop table t;

# aggregate sum distinct, coerced result from f32 to f64
statement ok
create table t (c float) as values (1.0), (2.2), (1.0), (3.3), (null), (null), (3.3), (-2.0);

query RT
select sum(distinct c), arrow_typeof(sum(distinct c)) from t;
----
4.5 Float64

statement ok
drop table t;

# aggregate sum distinct with decimal
statement ok
create table t (c decimal(35, 0)) as values (1), (2), (1), (3), (null), (null), (3), (-2);

query RT
select sum(distinct c), arrow_typeof(sum(distinct c)) from t;
----
4 Decimal128(38, 0)

statement ok
drop table t;

# query_sum_distinct - 2 different aggregate functions: avg and sum(distinct)
query RI
SELECT AVG(c1), SUM(DISTINCT c2) FROM test
----
1.75 3

# query_sum_distinct - 2 sum(distinct) functions
query II
SELECT SUM(DISTINCT c1), SUM(DISTINCT c2) FROM test
----
4 3

# # query_count_distinct
query I
SELECT COUNT(DISTINCT c1) FROM test
----
3

# TODO: count_distinct_integers_aggregated_single_partition

# TODO: count_distinct_integers_aggregated_multiple_partitions

# TODO: aggregate_with_alias

# variance_single_value
query RRRR
select var(sq.column1), var_pop(sq.column1), stddev(sq.column1), stddev_pop(sq.column1) from (values (1.0)) as sq;
----
NULL 0 NULL 0

# variance_two_values
query RRRR
select var(sq.column1), var_pop(sq.column1), stddev(sq.column1), stddev_pop(sq.column1) from (values (1.0), (3.0)) as sq;
----
2 1 1.414213562373 1



# aggregates on empty tables
statement ok
CREATE TABLE empty (column1 bigint, column2 int);

# no group by column
query IIRIIIII
SELECT
  count(column1), -- counts should be zero, even for nulls
  sum(column1),   -- other aggregates should be null
  avg(column1),
  min(column1),
  max(column1),
  bit_and(column1),
  bit_or(column1),
  bit_xor(column1)
FROM empty
----
0 NULL NULL NULL NULL NULL NULL NULL

# Same query but with grouping (no groups, so no output)
query IIRIIIIII
SELECT
  count(column1),
  sum(column1),
  avg(column1),
  min(column1),
  max(column1),
  bit_and(column1),
  bit_or(column1),
  bit_xor(column1),
  column2
FROM empty
GROUP BY column2
ORDER BY column2;
----


statement ok
drop table empty

# aggregates on all nulls
statement ok
CREATE TABLE the_nulls
AS VALUES
  (null::bigint, 1),
  (null::bigint, 1),
  (null::bigint, 2);

query II
select * from the_nulls
----
NULL 1
NULL 1
NULL 2

# no group by column
query IIRIIIII
SELECT
  count(column1), -- counts should be zero, even for nulls
  sum(column1),   -- other aggregates should be null
  avg(column1),
  min(column1),
  max(column1),
  bit_and(column1),
  bit_or(column1),
  bit_xor(column1)
FROM the_nulls
----
0 NULL NULL NULL NULL NULL NULL NULL

# Same query but with grouping
query IIRIIIIII
SELECT
  count(column1), -- counts should be zero, even for nulls
  sum(column1),   -- other aggregates should be null
  avg(column1),
  min(column1),
  max(column1),
  bit_and(column1),
  bit_or(column1),
  bit_xor(column1),
  column2
FROM the_nulls
GROUP BY column2
ORDER BY column2;
----
0 NULL NULL NULL NULL NULL NULL NULL 1
0 NULL NULL NULL NULL NULL NULL NULL 2


statement ok
drop table the_nulls;


statement ok
create table bool_aggregate_functions (
  c1 boolean not null,
  c2 boolean not null,
  c3 boolean not null,
  c4 boolean not null,
  c5 boolean,
  c6 boolean,
  c7 boolean,
  c8 boolean
)
as values
  (true, true, false, false, true, true, null, null),
  (true, false, true, false, false, null, false, null),
  (true, true, false, false, null, true, false, null);

# query_bool_and
query BBBBBBBB
SELECT bool_and(c1), bool_and(c2), bool_and(c3), bool_and(c4), bool_and(c5), bool_and(c6), bool_and(c7), bool_and(c8) FROM bool_aggregate_functions
----
true false false false false true false NULL

# query_bool_and_distinct
query BBBBBBBB
SELECT bool_and(distinct c1), bool_and(distinct c2), bool_and(distinct c3), bool_and(distinct c4), bool_and(distinct c5), bool_and(distinct c6), bool_and(distinct c7), bool_and(distinct c8) FROM bool_aggregate_functions
----
true false false false false true false NULL

# query_bool_or
query BBBBBBBB
SELECT bool_or(c1), bool_or(c2), bool_or(c3), bool_or(c4), bool_or(c5), bool_or(c6), bool_or(c7), bool_or(c8) FROM bool_aggregate_functions
----
true true true false true true false NULL

# query_bool_or_distinct
query BBBBBBBB
SELECT bool_or(distinct c1), bool_or(distinct c2), bool_or(distinct c3), bool_or(distinct c4), bool_or(distinct c5), bool_or(distinct c6), bool_or(distinct c7), bool_or(distinct c8) FROM bool_aggregate_functions
----
true true true false true true false NULL

# Test issue: https://github.com/apache/datafusion/issues/11846
statement ok
create table t1(v1 int, v2 boolean);

statement ok
insert into t1 values (1, true), (1, true);

statement ok
insert into t1 values (3, null), (3, true);

statement ok
insert into t1 values (2, false), (2, true);

statement ok
insert into t1 values (6, false), (6, false);

statement ok
insert into t1 values (4, null), (4, null);

statement ok
insert into t1 values (5, false), (5, null);

query IB
select v1, bool_and(v2) from t1 group by v1 order by v1;
----
1 true
2 false
3 true
4 NULL
5 false
6 false

query IB
select v1, bool_or(v2) from t1 group by v1 order by v1;
----
1 true
2 true
3 true
4 NULL
5 false
6 false

statement ok
drop table t1;


# aggregates on strings
statement ok
create table t_source
as values
 ('Foo', 1),
 ('Bar', 2),
 (null,  2),
 ('Baz', 1);

statement ok
create table t as
select
  arrow_cast(column1, 'Utf8') as utf8,
  arrow_cast(column1, 'LargeUtf8') as largeutf8,
  column2 as tag
from t_source;

# No groupy
query TTITTI
SELECT
  min(utf8),
  max(utf8),
  count(utf8),
  min(largeutf8),
  max(largeutf8),
  count(largeutf8)
FROM t
----
Bar Foo 3 Bar Foo 3


# with groupby
query TTITTI
SELECT
  min(utf8),
  max(utf8),
  count(utf8),
  min(largeutf8),
  max(largeutf8),
  count(largeutf8)
FROM t
GROUP BY tag
ORDER BY tag
----
Baz Foo 2 Baz Foo 2
Bar Bar 1 Bar Bar 1


statement ok
drop table t_source;

statement ok
drop table t;


# aggregates on binary
statement ok
create table t_source
as values
 ('Foo', 1),
 ('Bar', 2),
 (null,  2),
 ('Baz', 1);

statement ok
create table t as
select
  arrow_cast(column1, 'Binary') as binary,
  arrow_cast(column1, 'LargeBinary') as largebinary,
  column2 as tag
from t_source;

# No groupy
query ??I??I
SELECT
  min(binary),
  max(binary),
  count(binary),
  min(largebinary),
  max(largebinary),
  count(largebinary)
FROM t
----
426172 466f6f 3 426172 466f6f 3

# with groupby
query ??I??I
SELECT
  min(binary),
  max(binary),
  count(binary),
  min(largebinary),
  max(largebinary),
  count(largebinary)
FROM t
GROUP BY tag
ORDER BY tag
----
42617a 466f6f 2 42617a 466f6f 2
426172 426172 1 426172 426172 1



statement ok
drop table t_source;

statement ok
drop table t;


query I
select median(a) from (select 1 as a where 1=0);
----
NULL

query I
select approx_median(a) from (select 1 as a where 1=0);
----
NULL

# aggregate_decimal_sum
query RT
select sum(c1), arrow_typeof(sum(c1)) from d_table;
----
100 Decimal128(20, 3)

# aggregate sum with decimal
statement ok
create table t (c decimal(35, 3)) as values (10), (null), (20);

query RT
select sum(c), arrow_typeof(sum(c)) from t;
----
30 Decimal128(38, 3)

statement ok
drop table t;

# aggregate sum with i32, sum coerced result to i64
statement ok
create table t (c int) as values (1), (-1), (10), (null), (-11);

query IT
select sum(c), arrow_typeof(sum(c)) from t;
----
-1 Int64

statement ok
drop table t;

# aggregate sum with all nulls
statement ok
create table t (c1 decimal(10, 0), c2 int) as values (null, null), (null, null), (null, null);

query RTIT
select 
  sum(c1), arrow_typeof(sum(c1)),
  sum(c2), arrow_typeof(sum(c2))
from t;
----
NULL Decimal128(20, 0) NULL Int64

statement ok
drop table t;

# aggregate sum with u32, sum coerced result to u64
statement ok
create table t (c int unsigned) as values (1), (0), (10), (null), (4);

query IT
select sum(c), arrow_typeof(sum(c)) from t;
----
15 UInt64

statement ok
drop table t;

# aggregate sum with f32, sum coerced result to f64
statement ok
create table t (c float) as values (1.2), (0.2), (-1.2), (null), (-1.0);

query RT
select sum(c), arrow_typeof(sum(c)) from t;
----
-0.79999999702 Float64

statement ok
drop table t;

# aggregate sum with f64
statement ok
create table t (c double) as values (1.2), (0.2), (-1.2), (null), (-1.0);

query RT
select sum(c), arrow_typeof(sum(c)) from t;
----
-0.8 Float64

statement ok
drop table t;

query TRT
select c2, sum(c1), arrow_typeof(sum(c1)) from d_table GROUP BY c2 ORDER BY c2;
----
A 1100.045 Decimal128(20, 3)
B -1000.045 Decimal128(20, 3)


# aggregate_decimal_avg
query RT
select avg(c1), arrow_typeof(avg(c1)) from d_table
----
5 Decimal128(14, 7)

query TRT
select c2, avg(c1), arrow_typeof(avg(c1)) from d_table GROUP BY c2 ORDER BY c2
----
A 110.0045 Decimal128(14, 7)
B -100.0045 Decimal128(14, 7)

# aggregate_decimal_count_distinct
query I
select count(DISTINCT cast(c1 AS DECIMAL(10, 2))) from d_table
----
4

query TI
select c2, count(DISTINCT cast(c1 AS DECIMAL(10, 2))) from d_table GROUP BY c2 ORDER BY c2
----
A 2
B 2

# Use PostgresSQL dialect
statement ok
set datafusion.sql_parser.dialect = 'Postgres';

# Creating the table
statement ok
CREATE TABLE test_table (c1 INT, c2 INT, c3 INT)

# Inserting data
statement ok
INSERT INTO test_table VALUES
  (1, 10, 50),
  (1, 20, 60),
  (2, 10, 70),
  (2, 20, 80),
  (3, 10, NULL)

# query_group_by_with_filter
query III rowsort
SELECT
  c1,
  SUM(c2) FILTER (WHERE c2 >= 20),
  SUM(c2) FILTER (WHERE c2 < 1) -- no rows pass filter, so the output should be NULL
FROM test_table GROUP BY c1
----
1 20 NULL
2 20 NULL
3 NULL NULL

# query_group_by_avg_with_filter
query IRR rowsort
SELECT
  c1,
  AVG(c2) FILTER (WHERE c2 >= 20),
  AVG(c2) FILTER (WHERE c2 < 1)  -- no rows pass filter, so output should be null
FROM test_table GROUP BY c1
----
1 20 NULL
2 20 NULL
3 NULL NULL

# query_group_by_with_multiple_filters
query IIR rowsort
SELECT
  c1,
  SUM(c2) FILTER (WHERE c2 >= 20) AS sum_c2,
  AVG(c3) FILTER (WHERE c3 <= 70) AS avg_c3
FROM test_table GROUP BY c1
----
1 20 55
2 20 70
3 NULL NULL

# query_group_by_distinct_with_filter
query II rowsort
SELECT
  c1,
  COUNT(DISTINCT c2) FILTER (WHERE c2 >= 20) AS distinct_c2_count
FROM test_table GROUP BY c1
----
1 1
2 1
3 0

# query_without_group_by_with_filter
query I rowsort
SELECT
  SUM(c2) FILTER (WHERE c2 >= 20) AS sum_c2
FROM test_table
----
40

# count_without_group_by_with_filter
query I rowsort
SELECT
  COUNT(c2) FILTER (WHERE c2 >= 20) AS count_c2
FROM test_table
----
2

# query_with_and_without_filter
query III rowsort
SELECT
  c1,
  SUM(c2) FILTER (WHERE c2 >= 20) as result,
  SUM(c2) as result_no_filter
FROM test_table GROUP BY c1;
----
1 20 30
2 20 30
3 NULL 10

# query_filter_on_different_column_than_aggregate
query I rowsort
select
  sum(c1) FILTER (WHERE c2 < 30)
FROM test_table;
----
9

# query_test_empty_filter
query I rowsort
SELECT
  SUM(c2) FILTER (WHERE c2 >= 20000000) AS sum_c2
FROM test_table;
----
NULL

# Creating the decimal table
statement ok
CREATE TABLE test_decimal_table (c1 INT, c2 DECIMAL(5, 2), c3 DECIMAL(5, 1), c4 DECIMAL(5, 1))

# Inserting data
statement ok
INSERT INTO test_decimal_table VALUES (1, 10.10, 100.1, NULL), (1, 20.20, 200.2, NULL), (2, 10.10, 700.1, NULL), (2, 20.20, 700.1, NULL), (3, 10.1, 100.1, NULL), (3, 10.1, NULL, NULL)

# aggregate_decimal_with_group_by
query IIRRRRIIRR rowsort
select c1, count(c2), avg(c2), sum(c2), min(c2), max(c2), count(c3), count(c4), sum(c4), avg(c4) from test_decimal_table group by c1
----
1 2 15.15 30.3 10.1 20.2 2 0 NULL NULL
2 2 15.15 30.3 10.1 20.2 2 0 NULL NULL
3 2 10.1 20.2 10.1 10.1 1 0 NULL NULL

# aggregate_decimal_with_group_by_decimal
query RIRRRRIR rowsort
select c3, count(c2), avg(c2), sum(c2), min(c2), max(c2), count(c4), sum(c4) from test_decimal_table group by c3
----
100.1 2 10.1 20.2 10.1 10.1 0 NULL
200.2 1 20.2 20.2 20.2 20.2 0 NULL
700.1 2 15.15 30.3 10.1 20.2 0 NULL
NULL 1 10.1 10.1 10.1 10.1 0 NULL

# Restore the default dialect
statement ok
set datafusion.sql_parser.dialect = 'Generic';

## Multiple distinct aggregates and dictionaries
statement ok
create table dict_test as values (1, arrow_cast('foo', 'Dictionary(Int32, Utf8)')), (2, arrow_cast('bar', 'Dictionary(Int32, Utf8)'));

query IT
select * from dict_test;
----
1 foo
2 bar

query II
select count(distinct column1), count(distinct column2) from dict_test group by column1;
----
1 1
1 1

statement ok
drop table dict_test;


# Prepare the table with dictionary values for testing
statement ok
CREATE TABLE value(x bigint) AS VALUES (1), (2), (3), (1), (3), (4), (5), (2);

statement ok
CREATE TABLE value_dict AS SELECT arrow_cast(x, 'Dictionary(Int64, Int32)') AS x_dict FROM value;

query ?
select x_dict from value_dict;
----
1
2
3
1
3
4
5
2

query I
select sum(x_dict) from value_dict;
----
21

query R
select avg(x_dict) from value_dict;
----
2.625

# distinct_average
query R
select avg(distinct x_dict) from value_dict;
----
3

query error
select avg(x_dict), avg(distinct x_dict) from value_dict;

query I
select min(x_dict) from value_dict;
----
1

query I
select max(x_dict) from value_dict;
----
5

query I
select sum(x_dict) from value_dict where x_dict > 3;
----
9

query R
select avg(x_dict) from value_dict where x_dict > 3;
----
4.5

query I
select min(x_dict) from value_dict where x_dict > 3;
----
4

query I
select max(x_dict) from value_dict where x_dict > 3;
----
5

query I
select sum(x_dict) from value_dict group by x_dict % 2 order by sum(x_dict);
----
8
13

query R
select avg(x_dict) from value_dict group by x_dict % 2 order by avg(x_dict);
----
2.6
2.666666666667

query I
select min(x_dict) from value_dict group by x_dict % 2 order by min(x_dict);
----
1
2

query I
select max(x_dict) from value_dict group by x_dict % 2 order by max(x_dict);
----
4
5

query T
select arrow_typeof(x_dict) from value_dict group by x_dict;
----
Dictionary(Int64, Int32)
Dictionary(Int64, Int32)
Dictionary(Int64, Int32)
Dictionary(Int64, Int32)
Dictionary(Int64, Int32)

statement ok
drop table value

statement ok
drop table value_dict


# bool aggregation
statement ok
CREATE TABLE value_bool(x boolean, g int) AS VALUES (NULL, 0), (false, 0), (true, 0), (false, 1), (true, 2), (NULL, 3);

query B
select min(x) from value_bool;
----
false

query B
select max(x) from value_bool;
----
true

query B
select min(x) from value_bool group by g order by g;
----
false
false
true
NULL

query B
select max(x) from value_bool group by g order by g;
----
true
false
true
NULL


##regr


query error DataFusion error: Error during planning: table 'datafusion\.public\.float_table' not found
select min(col_f32), max(col_f32), avg(col_f32), sum(col_f32), count(col_f32) from float_table;

query error DataFusion error: Error during planning: table 'datafusion\.public\.float_table' not found
select min(col_f32_nan), max(col_f32_nan), avg(col_f32_nan), sum(col_f32_nan), count(col_f32_nan) from float_table;

query error DataFusion error: Error during planning: table 'datafusion\.public\.float_table' not found
select min(col_f64), max(col_f64), avg(col_f64), sum(col_f64), count(col_f64) from float_table;

query error DataFusion error: Error during planning: table 'datafusion\.public\.float_table' not found
select min(col_f64_nan), max(col_f64_nan), avg(col_f64_nan), sum(col_f64_nan), count(col_f64_nan) from float_table;

statement error DataFusion error: Execution error: Table 'float_table' doesn't exist\.
drop table float_table


# Queries with nested count(*)

query I
select count(*) from (select count(*) from (select 1));
----
1

query I
select count(*) from (select count(*) a, count(*) b from (select 1));
----
1


# rule `aggregate_statistics` should not optimize MIN/MAX to wrong values on empty relation

statement ok
CREATE TABLE empty(col0 INTEGER);

query I
SELECT MIN(col0) FROM empty WHERE col0=1;
----
NULL

query I
SELECT MAX(col0) FROM empty WHERE col0=1;
----
NULL

query TT
EXPLAIN SELECT MIN(col0) FROM empty;
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[min(empty.col0)]]
02)--TableScan: empty projection=[col0]
physical_plan
01)ProjectionExec: expr=[NULL as min(empty.col0)]
02)--PlaceholderRowExec

query TT
EXPLAIN SELECT MAX(col0) FROM empty;
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[max(empty.col0)]]
02)--TableScan: empty projection=[col0]
physical_plan
01)ProjectionExec: expr=[NULL as max(empty.col0)]
02)--PlaceholderRowExec

statement ok
DROP TABLE empty;

# verify count aggregate function should not be nullable
statement ok
create table empty;

query I
select distinct count() from empty;
----
0

statement ok
DROP TABLE empty;

statement ok
CREATE TABLE t(col0 INTEGER) as VALUES(2);

query I
SELECT MIN(col0) FROM t WHERE col0=1;
----
NULL

query I
SELECT MAX(col0) FROM t WHERE col0=1;
----
NULL

statement ok
DROP TABLE t;


# Test for the case when the column name is ambiguous
statement ok
CREATE TABLE t(a BIGINT) AS VALUES(1), (2), (3);

# The column name referenced by GROUP-BY is ambiguous, prefer the column in base plan
query I
SELECT 0 as "t.a" FROM t GROUP BY t.a;
----
0
0
0

# The column name referenced by HAVING is ambiguous, prefer the column in the base plan
query I
SELECT 0 AS "t.a" FROM t HAVING MAX(t.a) = 0;
----

# Test issue: https://github.com/apache/datafusion/issues/9161
query I rowsort
SELECT CAST(a AS INT) FROM t GROUP BY t.a;
----
1
2
3

statement ok
DROP TABLE t;

# Test for ignore null in FIRST_VALUE
statement ok
CREATE TABLE t AS VALUES (null::bigint), (3), (4);

query I
SELECT FIRST_VALUE(column1) FROM t;
----
NULL

query I
SELECT FIRST_VALUE(column1) RESPECT NULLS FROM t;
----
NULL

query I
SELECT FIRST_VALUE(column1) IGNORE NULLS FROM t;
----
3

statement ok
DROP TABLE t;

# Test for ignore null with ORDER BY in FIRST_VALUE
statement ok
CREATE TABLE t AS VALUES  (3, 4), (4, 3), (null::bigint, 1), (null::bigint, 1);

query I
SELECT column1 FROM t ORDER BY column2;
----
NULL
NULL
4
3

query I
SELECT FIRST_VALUE(column1 ORDER BY column2) FROM t;
----
NULL

query I
SELECT FIRST_VALUE(column1 ORDER BY column2) RESPECT NULLS FROM t;
----
NULL

query I
SELECT FIRST_VALUE(column1 ORDER BY column2) IGNORE NULLS FROM t;
----
4

statement ok
DROP TABLE t;

# Test for ignore null in LAST_VALUE
statement ok
CREATE TABLE t AS VALUES (3), (4), (null::bigint);

query I
SELECT LAST_VALUE(column1) FROM t;
----
NULL

query I
SELECT LAST_VALUE(column1) RESPECT NULLS FROM t;
----
NULL

query I
SELECT LAST_VALUE(column1) IGNORE NULLS FROM t;
----
4

statement ok
DROP TABLE t;

# Test for ignore null with ORDER BY in LAST_VALUE
statement ok
CREATE TABLE t AS VALUES  (3, 3), (4, 4), (null::bigint, 1), (null::bigint, 2);

query I
SELECT column1 FROM t ORDER BY column2 DESC;
----
4
3
NULL
NULL

query I
SELECT LAST_VALUE(column1 ORDER BY column2 DESC) FROM t;
----
NULL

query I
SELECT LAST_VALUE(column1 ORDER BY column2 DESC) RESPECT NULLS FROM t;
----
NULL

query I
SELECT LAST_VALUE(column1 ORDER BY column2 DESC) IGNORE NULLS FROM t;
----
3

statement ok
DROP TABLE t;

# Test for CASE with NULL in aggregate function
statement ok
CREATE TABLE example(data double precision);

statement ok
INSERT INTO example VALUES (1), (2), (NULL), (4);

query RR
SELECT
    sum(CASE WHEN data is NULL THEN NULL ELSE data+1 END) as then_null,
    sum(CASE WHEN data is NULL THEN data+1 ELSE NULL END) as else_null
FROM example;
----
10 NULL

query R
SELECT
   CASE data WHEN 1 THEN NULL WHEN 2 THEN 3.3 ELSE NULL END as case_null
FROM example;
----
NULL
3.3
NULL
NULL

statement ok
drop table example;

# Test Convert FirstLast optimizer rule
statement ok
CREATE EXTERNAL TABLE convert_first_last_table (
c1 INT NOT NULL,
c2 INT NOT NULL,
c3 INT NOT NULL
)
STORED AS CSV
WITH ORDER (c1 ASC)
WITH ORDER (c2 DESC)
WITH ORDER (c3 ASC)
LOCATION '../core/tests/data/convert_first_last.csv'
OPTIONS ('format.has_header' 'true');

# test first to last, the result does not show difference, we need to check the conversion by `explain`
query TT
explain select first_value(c1 order by c3 desc) from convert_first_last_table;
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[first_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c3 DESC NULLS FIRST]]]
02)--TableScan: convert_first_last_table projection=[c1, c3]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[first_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c3 DESC NULLS FIRST]]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[last_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c3 ASC NULLS LAST]]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/convert_first_last.csv]]}, projection=[c1, c3], output_orderings=[[c1@0 ASC NULLS LAST], [c3@1 ASC NULLS LAST]], has_header=true

# test last to first
query TT
explain select last_value(c1 order by c2 asc) from convert_first_last_table;
----
logical_plan
01)Aggregate: groupBy=[[]], aggr=[[last_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c2 ASC NULLS LAST]]]
02)--TableScan: convert_first_last_table projection=[c1, c2]
physical_plan
01)AggregateExec: mode=Final, gby=[], aggr=[last_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c2 ASC NULLS LAST]]
02)--CoalescePartitionsExec
03)----AggregateExec: mode=Partial, gby=[], aggr=[first_value(convert_first_last_table.c1) ORDER BY [convert_first_last_table.c2 DESC NULLS FIRST]]
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/convert_first_last.csv]]}, projection=[c1, c2], output_orderings=[[c1@0 ASC NULLS LAST], [c2@1 DESC]], has_header=true

# test building plan with aggreagte sum

statement ok
create table employee_csv(id int, first_name string, last_name varchar, state varchar, salary bigint) as values (1, 'jenson', 'huang', 'unemployed', 10);

query TI
select state, sum(salary) total_salary from employee_csv group by state;
----
unemployed 10

statement ok
set datafusion.explain.logical_plan_only = true;

query TT
explain select state, sum(salary) as total_salary from employee_csv group by state;
----
logical_plan
01)Projection: employee_csv.state, sum(employee_csv.salary) AS total_salary
02)--Aggregate: groupBy=[[employee_csv.state]], aggr=[[sum(employee_csv.salary)]]
03)----TableScan: employee_csv projection=[state, salary]

# fail if there is duplicate name
query error DataFusion error: Schema error: Schema contains qualified field name employee_csv\.state and unqualified field name state which would be ambiguous
select state, sum(salary) as state from employee_csv group by state;

statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
drop table employee_csv;

# test null literal handling in supported aggregate functions
query I??III?T
select count(null), min(null), max(null), bit_and(NULL), bit_or(NULL), bit_xor(NULL), nth_value(NULL, 1), string_agg(NULL, ',');
----
0 NULL NULL NULL NULL NULL NULL NULL

statement ok
create table having_test(v1 int, v2 int)

statement ok
create table join_table(v1 int, v2 int)

statement ok
insert into having_test values (1, 2), (2, 3), (3, 4)

statement ok
insert into join_table values (1, 2), (2, 3), (3, 4)


query II
select * from having_test group by v1, v2 having max(v1) = 3
----
3 4

query TT
EXPLAIN select * from having_test group by v1, v2 having max(v1) = 3
----
logical_plan
01)Projection: having_test.v1, having_test.v2
02)--Filter: max(having_test.v1) = Int32(3)
03)----Aggregate: groupBy=[[having_test.v1, having_test.v2]], aggr=[[max(having_test.v1)]]
04)------TableScan: having_test projection=[v1, v2]
physical_plan
01)CoalesceBatchesExec: target_batch_size=8192
02)--FilterExec: max(having_test.v1)@2 = 3, projection=[v1@0, v2@1]
03)----AggregateExec: mode=FinalPartitioned, gby=[v1@0 as v1, v2@1 as v2], aggr=[max(having_test.v1)]
04)------CoalesceBatchesExec: target_batch_size=8192
05)--------RepartitionExec: partitioning=Hash([v1@0, v2@1], 4), input_partitions=4
06)----------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
07)------------AggregateExec: mode=Partial, gby=[v1@0 as v1, v2@1 as v2], aggr=[max(having_test.v1)]
08)--------------MemoryExec: partitions=1, partition_sizes=[1]


query error
select * from having_test having max(v1) = 3

query I
select max(v1) from having_test having max(v1) = 3
----
3

query I
select max(v1), * exclude (v1, v2) from having_test having max(v1) = 3
----
3

# because v1, v2 is not in the group by clause, the sql is invalid
query III
select max(v1), * replace ('v1' as v3) from having_test group by v1, v2 having max(v1) = 3
----
3 3 4

query III
select max(v1), t.* from having_test t group by v1, v2 having max(v1) = 3
----
3 3 4

# j.* should also be included in the group-by clause
query error
select max(t.v1), j.* from having_test t join join_table j on t.v1 = j.v1 group by t.v1, t.v2 having max(t.v1) = 3

query III
select max(t.v1), j.* from having_test t join join_table j on t.v1 = j.v1 group by j.v1, j.v2 having max(t.v1) = 3
----
3 3 4

# If the select items only contain scalar expressions, the having clause is valid.
query P
select now() from having_test having max(v1) = 4
----

# If the select items only contain scalar expressions, the having clause is valid.
query I
select 0 from having_test having max(v1) = 4
----

# v2 should also be included in group-by clause
query error
select * from having_test group by v1 having max(v1) = 3

statement ok
drop table having_test

statement ok
drop table join_table

# test min/max Float16 without group expression
query RRTT
WITH data AS (
  SELECT arrow_cast(1, 'Float16') AS f
  UNION ALL
  SELECT arrow_cast(6, 'Float16') AS f
)
SELECT MIN(f), MAX(f), arrow_typeof(MIN(f)), arrow_typeof(MAX(f)) FROM data;
----
1 6 Float16 Float16

# test min/max Float16 with group expression
query IRRTT
WITH data AS (
  SELECT 1 as k, arrow_cast(1.8125, 'Float16') AS f
  UNION ALL
  SELECT 1 as k, arrow_cast(6.8007813, 'Float16') AS f
  UNION ALL
  SELECT 2 AS k, arrow_cast(8.5, 'Float16') AS f
)
SELECT k, MIN(f), MAX(f), arrow_typeof(MIN(f)), arrow_typeof(MAX(f))
FROM data
GROUP BY k
ORDER BY k;
----
1 1.8125 6.8007813 Float16 Float16
2 8.5 8.5 Float16 Float16

statement ok
CREATE TABLE t1(v1 int);

# issue: https://github.com/apache/datafusion/issues/12814
statement error DataFusion error: Error during planning: Aggregate functions are not allowed in the WHERE clause. Consider using HAVING instead
SELECT v1 FROM t1 WHERE ((count(v1) % 1) << 1) > 0;

statement ok
DROP TABLE t1;

# Test last function with merge batch
query II
with A as (
    select 1 as id, 10 as foo
    UNION ALL
    select 1, 10
    UNION ALL
    select 1, 10
    UNION ALL
    select 1, 10
    UNION ALL
    select 1, 10
    ---- The order is non-deterministic, keep the value the same
) select last_value(a.foo), sum(distinct 1) from A a group by a.id;
----
10 1

# It has only AggregateExec with FinalPartitioned mode, so `merge_batch` is used
# If the plan is changed, whether the `merge_batch` is used should be verified to ensure the test coverage
query TT
explain with A as (
    select 1 as id, 2 as foo
    UNION ALL
    select 1, 4
    UNION ALL
    select 1, 5
    UNION ALL
    select 1, 3
    UNION ALL
    select 1, 2
) select last_value(a.foo order by a.foo), sum(distinct 1) from A a group by a.id;
----
logical_plan
01)Projection: last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST], sum(DISTINCT Int64(1))
02)--Aggregate: groupBy=[[a.id]], aggr=[[last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST], sum(DISTINCT Int64(1))]]
03)----SubqueryAlias: a
04)------SubqueryAlias: a
05)--------Union
06)----------Projection: Int64(1) AS id, Int64(2) AS foo
07)------------EmptyRelation
08)----------Projection: Int64(1) AS id, Int64(4) AS foo
09)------------EmptyRelation
10)----------Projection: Int64(1) AS id, Int64(5) AS foo
11)------------EmptyRelation
12)----------Projection: Int64(1) AS id, Int64(3) AS foo
13)------------EmptyRelation
14)----------Projection: Int64(1) AS id, Int64(2) AS foo
15)------------EmptyRelation
physical_plan
01)ProjectionExec: expr=[last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST]@1 as last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST], sum(DISTINCT Int64(1))@2 as sum(DISTINCT Int64(1))]
02)--AggregateExec: mode=FinalPartitioned, gby=[id@0 as id], aggr=[last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST], sum(DISTINCT Int64(1))], ordering_mode=Sorted
03)----CoalesceBatchesExec: target_batch_size=8192
04)------RepartitionExec: partitioning=Hash([id@0], 4), input_partitions=5
05)--------AggregateExec: mode=Partial, gby=[id@0 as id], aggr=[last_value(a.foo) ORDER BY [a.foo ASC NULLS LAST], sum(DISTINCT Int64(1))], ordering_mode=Sorted
06)----------UnionExec
07)------------ProjectionExec: expr=[1 as id, 2 as foo]
08)--------------PlaceholderRowExec
09)------------ProjectionExec: expr=[1 as id, 4 as foo]
10)--------------PlaceholderRowExec
11)------------ProjectionExec: expr=[1 as id, 5 as foo]
12)--------------PlaceholderRowExec
13)------------ProjectionExec: expr=[1 as id, 3 as foo]
14)--------------PlaceholderRowExec
15)------------ProjectionExec: expr=[1 as id, 2 as foo]
16)--------------PlaceholderRowExec
