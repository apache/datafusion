# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
## Reverse Parquet Scan Tests - Test reverse scan optimization
##########

# Setup: Create a table with sorted data
statement ok
CREATE TABLE test_reverse_scan(id INT, value INT, name VARCHAR) AS
VALUES
    (1, 100, 'a'),
    (2, 200, 'b'),
    (3, 300, 'c'),
    (4, 400, 'd'),
    (5, 500, 'e'),
    (6, 600, 'f'),
    (7, 700, 'g'),
    (8, 800, 'h'),
    (9, 900, 'i'),
    (10, 1000, 'j');

# Copy to parquet (data is already sorted by id ASC)
query I
COPY (SELECT * FROM test_reverse_scan ORDER BY id ASC)
TO 'test_files/scratch/reverse_parquet_scan/sorted_data.parquet'
STORED AS PARQUET;
----
10

# Create external table WITH ORDER clause to tell DataFusion the data is sorted
statement ok
CREATE EXTERNAL TABLE parquet_reverse_test (
    id INT NOT NULL,
    value INT NOT NULL,
    name TEXT NOT NULL
)
STORED AS PARQUET
WITH ORDER (id ASC NULLS LAST)
LOCATION 'test_files/scratch/reverse_parquet_scan/sorted_data.parquet';

# Test EXPLAIN for DESC order - should show reverse optimization applied
query TT
EXPLAIN SELECT * FROM parquet_reverse_test ORDER BY id DESC;
----
logical_plan
01)Sort: parquet_reverse_test.id DESC NULLS FIRST
02)--TableScan: parquet_reverse_test projection=[id, value, name]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id, value, name], output_ordering=[id@0 DESC], file_type=parquet

# Test 1: Basic reverse scan - data should come out in reverse order
query IIT
SELECT * FROM parquet_reverse_test ORDER BY id DESC;
----
10 1000 j
9 900 i
8 800 h
7 700 g
6 600 f
5 500 e
4 400 d
3 300 c
2 200 b
1 100 a

# Test 2: Forward scan still works (should use original ordering)
query TT
EXPLAIN SELECT * FROM parquet_reverse_test ORDER BY id ASC;
----
logical_plan
01)Sort: parquet_reverse_test.id ASC NULLS LAST
02)--TableScan: parquet_reverse_test projection=[id, value, name]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id, value, name], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet

query IIT
SELECT * FROM parquet_reverse_test ORDER BY id ASC;
----
1 100 a
2 200 b
3 300 c
4 400 d
5 500 e
6 600 f
7 700 g
8 800 h
9 900 i
10 1000 j

# Test 3: Reverse scan with LIMIT
query IIT
SELECT * FROM parquet_reverse_test ORDER BY id DESC LIMIT 3;
----
10 1000 j
9 900 i
8 800 h

# Test 4: Reverse scan with WHERE clause
query IIT
SELECT * FROM parquet_reverse_test WHERE id > 5 ORDER BY id DESC;
----
10 1000 j
9 900 i
8 800 h
7 700 g
6 600 f

# Test 5: Multiple column sort with DESC
query IIT
SELECT * FROM parquet_reverse_test ORDER BY id DESC, value DESC LIMIT 5;
----
10 1000 j
9 900 i
8 800 h
7 700 g
6 600 f

# Test 6: Test with aggregation
query II
SELECT id, SUM(value) as total
FROM parquet_reverse_test
WHERE id <= 5
GROUP BY id
ORDER BY id DESC;
----
5 500
4 400
3 300
2 200
1 100

# Test 7: BETWEEN with DESC
query IIT
SELECT * FROM parquet_reverse_test WHERE id BETWEEN 3 AND 7 ORDER BY id DESC;
----
7 700 g
6 600 f
5 500 e
4 400 d
3 300 c

# Test 8: Verify first/last swap
query I
SELECT id FROM parquet_reverse_test ORDER BY id ASC LIMIT 1;
----
1

query I
SELECT id FROM parquet_reverse_test ORDER BY id DESC LIMIT 1;
----
10

query TT
EXPLAIN SELECT id FROM parquet_reverse_test ORDER BY id DESC LIMIT 1;
----
logical_plan
01)Sort: parquet_reverse_test.id DESC NULLS FIRST, fetch=1
02)--TableScan: parquet_reverse_test projection=[id]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], limit=1, output_ordering=[id@0 DESC], file_type=parquet

query TT
EXPLAIN verbose SELECT id FROM parquet_reverse_test ORDER BY id DESC LIMIT 1;
----
initial_logical_plan
01)Limit: skip=0, fetch=1
02)--Sort: parquet_reverse_test.id DESC NULLS FIRST
03)----Projection: parquet_reverse_test.id
04)------TableScan: parquet_reverse_test
logical_plan after resolve_grouping_function SAME TEXT AS ABOVE
logical_plan after type_coercion SAME TEXT AS ABOVE
analyzed_logical_plan SAME TEXT AS ABOVE
logical_plan after optimize_unions SAME TEXT AS ABOVE
logical_plan after simplify_expressions SAME TEXT AS ABOVE
logical_plan after replace_distinct_aggregate SAME TEXT AS ABOVE
logical_plan after eliminate_join SAME TEXT AS ABOVE
logical_plan after decorrelate_predicate_subquery SAME TEXT AS ABOVE
logical_plan after scalar_subquery_to_join SAME TEXT AS ABOVE
logical_plan after decorrelate_lateral_join SAME TEXT AS ABOVE
logical_plan after extract_equijoin_predicate SAME TEXT AS ABOVE
logical_plan after eliminate_duplicated_expr SAME TEXT AS ABOVE
logical_plan after eliminate_filter SAME TEXT AS ABOVE
logical_plan after eliminate_cross_join SAME TEXT AS ABOVE
logical_plan after eliminate_limit SAME TEXT AS ABOVE
logical_plan after propagate_empty_relation SAME TEXT AS ABOVE
logical_plan after filter_null_join_keys SAME TEXT AS ABOVE
logical_plan after eliminate_outer_join SAME TEXT AS ABOVE
logical_plan after push_down_limit
01)Limit: skip=0, fetch=1
02)--Sort: parquet_reverse_test.id DESC NULLS FIRST, fetch=1
03)----Projection: parquet_reverse_test.id
04)------TableScan: parquet_reverse_test
logical_plan after push_down_filter SAME TEXT AS ABOVE
logical_plan after single_distinct_aggregation_to_group_by SAME TEXT AS ABOVE
logical_plan after eliminate_group_by_constant SAME TEXT AS ABOVE
logical_plan after common_sub_expression_eliminate SAME TEXT AS ABOVE
logical_plan after optimize_projections
01)Limit: skip=0, fetch=1
02)--Sort: parquet_reverse_test.id DESC NULLS FIRST, fetch=1
03)----TableScan: parquet_reverse_test projection=[id]
logical_plan after optimize_unions SAME TEXT AS ABOVE
logical_plan after simplify_expressions SAME TEXT AS ABOVE
logical_plan after replace_distinct_aggregate SAME TEXT AS ABOVE
logical_plan after eliminate_join SAME TEXT AS ABOVE
logical_plan after decorrelate_predicate_subquery SAME TEXT AS ABOVE
logical_plan after scalar_subquery_to_join SAME TEXT AS ABOVE
logical_plan after decorrelate_lateral_join SAME TEXT AS ABOVE
logical_plan after extract_equijoin_predicate SAME TEXT AS ABOVE
logical_plan after eliminate_duplicated_expr SAME TEXT AS ABOVE
logical_plan after eliminate_filter SAME TEXT AS ABOVE
logical_plan after eliminate_cross_join SAME TEXT AS ABOVE
logical_plan after eliminate_limit SAME TEXT AS ABOVE
logical_plan after propagate_empty_relation SAME TEXT AS ABOVE
logical_plan after filter_null_join_keys SAME TEXT AS ABOVE
logical_plan after eliminate_outer_join SAME TEXT AS ABOVE
logical_plan after push_down_limit
01)Sort: parquet_reverse_test.id DESC NULLS FIRST, fetch=1
02)--TableScan: parquet_reverse_test projection=[id]
logical_plan after push_down_filter SAME TEXT AS ABOVE
logical_plan after single_distinct_aggregation_to_group_by SAME TEXT AS ABOVE
logical_plan after eliminate_group_by_constant SAME TEXT AS ABOVE
logical_plan after common_sub_expression_eliminate SAME TEXT AS ABOVE
logical_plan after optimize_projections SAME TEXT AS ABOVE
logical_plan after optimize_unions SAME TEXT AS ABOVE
logical_plan after simplify_expressions SAME TEXT AS ABOVE
logical_plan after replace_distinct_aggregate SAME TEXT AS ABOVE
logical_plan after eliminate_join SAME TEXT AS ABOVE
logical_plan after decorrelate_predicate_subquery SAME TEXT AS ABOVE
logical_plan after scalar_subquery_to_join SAME TEXT AS ABOVE
logical_plan after decorrelate_lateral_join SAME TEXT AS ABOVE
logical_plan after extract_equijoin_predicate SAME TEXT AS ABOVE
logical_plan after eliminate_duplicated_expr SAME TEXT AS ABOVE
logical_plan after eliminate_filter SAME TEXT AS ABOVE
logical_plan after eliminate_cross_join SAME TEXT AS ABOVE
logical_plan after eliminate_limit SAME TEXT AS ABOVE
logical_plan after propagate_empty_relation SAME TEXT AS ABOVE
logical_plan after filter_null_join_keys SAME TEXT AS ABOVE
logical_plan after eliminate_outer_join SAME TEXT AS ABOVE
logical_plan after push_down_limit SAME TEXT AS ABOVE
logical_plan after push_down_filter SAME TEXT AS ABOVE
logical_plan after single_distinct_aggregation_to_group_by SAME TEXT AS ABOVE
logical_plan after eliminate_group_by_constant SAME TEXT AS ABOVE
logical_plan after common_sub_expression_eliminate SAME TEXT AS ABOVE
logical_plan after optimize_projections SAME TEXT AS ABOVE
logical_plan
01)Sort: parquet_reverse_test.id DESC NULLS FIRST, fetch=1
02)--TableScan: parquet_reverse_test projection=[id]
initial_physical_plan
01)SortExec: TopK(fetch=1), expr=[id@0 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet
initial_physical_plan_with_stats
01)SortExec: TopK(fetch=1), expr=[id@0 DESC], preserve_partitioning=[false], statistics=[Rows=Exact(1), Bytes=Inexact(27), [(Col[0]: Min=Inexact(Int32(1)) Max=Inexact(Int32(10)) Null=Inexact(0))]]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet, statistics=[Rows=Exact(10), Bytes=Exact(271), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(10)) Null=Exact(0))]]
initial_physical_plan_with_schema
01)SortExec: TopK(fetch=1), expr=[id@0 DESC], preserve_partitioning=[false], schema=[id:Int32]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet, schema=[id:Int32]
physical_plan after OutputRequirements
01)OutputRequirementExec: order_by=[(id@0, desc)], dist_by=SinglePartition
02)--SortExec: TopK(fetch=1), expr=[id@0 DESC], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet
physical_plan after aggregate_statistics SAME TEXT AS ABOVE
physical_plan after join_selection SAME TEXT AS ABOVE
physical_plan after LimitedDistinctAggregation SAME TEXT AS ABOVE
physical_plan after FilterPushdown SAME TEXT AS ABOVE
physical_plan after EnforceDistribution SAME TEXT AS ABOVE
physical_plan after CombinePartialFinalAggregate SAME TEXT AS ABOVE
physical_plan after EnforceSorting SAME TEXT AS ABOVE
physical_plan after OptimizeAggregateOrder SAME TEXT AS ABOVE
physical_plan after ProjectionPushdown SAME TEXT AS ABOVE
physical_plan after coalesce_batches SAME TEXT AS ABOVE
physical_plan after OutputRequirements
01)SortExec: TopK(fetch=1), expr=[id@0 DESC], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], output_ordering=[id@0 ASC NULLS LAST], file_type=parquet
physical_plan after LimitAggregation SAME TEXT AS ABOVE
physical_plan after LimitPushPastWindows SAME TEXT AS ABOVE
physical_plan after LimitPushdown SAME TEXT AS ABOVE
physical_plan after ProjectionPushdown SAME TEXT AS ABOVE
physical_plan after ReverseOrder DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], limit=1, output_ordering=[id@0 DESC], file_type=parquet
physical_plan after EnsureCooperative SAME TEXT AS ABOVE
physical_plan after FilterPushdown(Post) SAME TEXT AS ABOVE
physical_plan after SanityCheckPlan SAME TEXT AS ABOVE
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], limit=1, output_ordering=[id@0 DESC], file_type=parquet
physical_plan_with_stats DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], limit=1, output_ordering=[id@0 DESC], file_type=parquet, statistics=[Rows=Exact(10), Bytes=Exact(271), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(10)) Null=Exact(0))]]
physical_plan_with_schema DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/reverse_parquet_scan/sorted_data.parquet]]}, projection=[id], limit=1, output_ordering=[id@0 DESC], file_type=parquet, schema=[id:Int32]

# Test 9: Test all rows DESC (full table scan with reverse)
query I
SELECT id FROM parquet_reverse_test ORDER BY id DESC;
----
10
9
8
7
6
5
4
3
2
1

# Test 10: Test all rows ASC (verify correctness)
query I
SELECT id FROM parquet_reverse_test ORDER BY id ASC;
----
1
2
3
4
5
6
7
8
9
10

# Cleanup
statement ok
DROP TABLE test_reverse_scan;

statement ok
DROP TABLE parquet_reverse_test;
