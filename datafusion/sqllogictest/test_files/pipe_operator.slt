# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

# http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# BigQuery supports the pipe operator syntax
# TODO: Make the Generic dialect support the pipe operator syntax
statement ok
set datafusion.sql_parser.dialect = 'BigQuery';

statement ok
CREATE TABLE test(
    a INT,
    b FLOAT,
    c VARCHAR,
    n VARCHAR
) AS VALUES
  (1, 1.1, 'a', NULL),
  (2, 2.2, 'b', NULL),
  (3, 3.3, 'c', NULL)
;

# WHERE pipe
query IRTT
SELECT *
FROM test
|> WHERE a > 1
----
2 2.2 b NULL
3 3.3 c NULL

# ORDER BY pipe
query IRTT
SELECT *
FROM test
|> ORDER BY a DESC
----
3 3.3 c NULL
2 2.2 b NULL
1 1.1 a NULL

# ORDER BY pipe, limit
query IRTT
SELECT *
FROM test
|> ORDER BY a DESC
|> LIMIT 1
----
3 3.3 c NULL

# SELECT pipe
query I
SELECT *
FROM test
|> SELECT a
----
1
2
3

# EXTEND pipe
query IRR
SELECT *
FROM test
|> SELECT a, b
|> EXTEND a + b AS a_plus_b
----
1 1.1 2.1
2 2.2 4.2
3 3.3 6.3

query IRR
SELECT *
FROM test
|> SELECT a, b
|> where a = 1
|> EXTEND a + b AS a_plus_b
----
1 1.1 2.1

# AS pipe
query I
SELECT *
FROM test
|> as test_pipe
|> select test_pipe.a
----
1
2
3

# UNION pipe
query I
SELECT *
FROM test
|> select a
|> UNION ALL (
  SELECT a FROM test
);
----
1
2
3
1
2
3

# INTERSECT pipe
query I rowsort
SELECT * FROM range(0,3)
|> INTERSECT DISTINCT
    (SELECT * FROM range(1,3));
----
1
2

# EXCEPT pipe
query I rowsort
select * from range(0,10)
|> EXCEPT DISTINCT (select * from range(5,10));
----
0
1
2
3
4

# AGGREGATE pipe
query II
(
  SELECT 'apples' AS item, 2 AS sales
  UNION ALL
  SELECT 'bananas' AS item, 5 AS sales
  UNION ALL
  SELECT 'apples' AS item, 7 AS sales
)
|> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales;
----
3 14

query TII rowsort
(
  SELECT 'apples' AS item, 2 AS sales
  UNION ALL
  SELECT 'bananas' AS item, 5 AS sales
  UNION ALL
  SELECT 'apples' AS item, 7 AS sales
)
|> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales
   GROUP BY item;
----
apples 2 9
bananas 1 5

query TII rowsort
(
  SELECT 'apples' AS item, 2 AS sales
  UNION ALL
  SELECT 'bananas' AS item, 5 AS sales
  UNION ALL
  SELECT 'apples' AS item, 7 AS sales
)
|> AGGREGATE COUNT(*) AS num_items, SUM(sales) AS total_sales
   GROUP BY item
|> WHERE num_items > 1;
----
apples 2 9

# JOIN pipe
query TII
(
  SELECT 'apples' AS item, 2 AS sales
  UNION ALL
  SELECT 'bananas' AS item, 5 AS sales
)
|> AS produce_sales
|> LEFT JOIN
     (
       SELECT "apples" AS item, 123 AS id
     ) AS produce_data
   ON produce_sales.item = produce_data.item
|> SELECT produce_sales.item, sales, id;
----
apples 2 123
bananas 5 NULL

# PIVOT pipe

statement ok
CREATE TABLE pipe_test(
    product VARCHAR,
    sales INT,
    quarter VARCHAR,
    year INT
) AS VALUES
   ('Kale', 51, 'Q1', 2020),
   ('Kale', 23, 'Q2', 2020),
   ('Kale', 45, 'Q3', 2020),
   ('Kale', 3, 'Q4', 2020),
   ('Kale', 70, 'Q1', 2021),
   ('Kale', 85, 'Q2', 2021),
   ('Apple', 77, 'Q1', 2020),
   ('Apple', 0, 'Q2', 2020),
   ('Apple', 1, 'Q1', 2021)
;

query TIIIII rowsort
SELECT * FROM pipe_test
|> PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'));
----
Apple 2020 77 0 NULL NULL
Apple 2021 1 NULL NULL NULL
Kale 2020 51 23 45 3
Kale 2021 70 85 NULL NULL

query TIIII rowsort
SELECT * FROM pipe_test
|> select product, sales, quarter
|> PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'));
----
Apple 78 0 NULL NULL
Kale 121 108 45 3

query TIII rowsort
SELECT * FROM pipe_test
|> select product, sales, quarter
|> PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3'));
----
Apple 78 0 NULL
Kale 121 108 45

query TIIII rowsort
SELECT * FROM pipe_test
|> select product, sales, quarter
|> PIVOT(SUM(sales) as total_sales, count(*) as num_records FOR quarter IN ('Q1', 'Q2'));
----
Apple 78 2 0 1
Kale 121 2 108 2


query TT
EXPLAIN SELECT * FROM pipe_test
|> select product, sales, quarter
|> PIVOT(SUM(sales) as total_sales, count(*) as num_records FOR quarter IN ('Q1', 'Q2'));
----
logical_plan
01)Aggregate: groupBy=[[pipe_test.product]], aggr=[[sum(__common_expr_1) FILTER (WHERE __common_expr_2) AS total_sales_Q1, count(Int64(1)) FILTER (WHERE __common_expr_2) AS num_records_Q1, sum(__common_expr_1) FILTER (WHERE __common_expr_3) AS total_sales_Q2, count(Int64(1)) FILTER (WHERE __common_expr_3) AS num_records_Q2]]
02)--Projection: CAST(pipe_test.sales AS Int64) AS __common_expr_1, pipe_test.quarter = Utf8View("Q1") AS __common_expr_2, pipe_test.quarter = Utf8View("Q2") AS __common_expr_3, pipe_test.product
03)----TableScan: pipe_test projection=[product, sales, quarter]
physical_plan
01)AggregateExec: mode=FinalPartitioned, gby=[product@0 as product], aggr=[total_sales_Q1, num_records_Q1, total_sales_Q2, num_records_Q2]
02)--CoalesceBatchesExec: target_batch_size=8192
03)----RepartitionExec: partitioning=Hash([product@0], 4), input_partitions=4
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------AggregateExec: mode=Partial, gby=[product@3 as product], aggr=[total_sales_Q1, num_records_Q1, total_sales_Q2, num_records_Q2]
06)----------ProjectionExec: expr=[CAST(sales@1 AS Int64) as __common_expr_1, quarter@2 = Q1 as __common_expr_2, quarter@2 = Q2 as __common_expr_3, product@0 as product]
07)------------DataSourceExec: partitions=1, partition_sizes=[1]

# With explicit pivot value alias
query TT
EXPLAIN SELECT * FROM pipe_test
|> select product, sales, quarter
|> PIVOT(SUM(sales) as total_sales, count(*) as num_records FOR quarter IN ('Q1' as q1, 'Q2'));
----
logical_plan
01)Aggregate: groupBy=[[pipe_test.product]], aggr=[[sum(__common_expr_1) FILTER (WHERE __common_expr_2) AS total_sales_q1, count(Int64(1)) FILTER (WHERE __common_expr_2) AS num_records_q1, sum(__common_expr_1) FILTER (WHERE __common_expr_3) AS total_sales_Q2, count(Int64(1)) FILTER (WHERE __common_expr_3) AS num_records_Q2]]
02)--Projection: CAST(pipe_test.sales AS Int64) AS __common_expr_1, pipe_test.quarter = Utf8View("Q1") AS __common_expr_2, pipe_test.quarter = Utf8View("Q2") AS __common_expr_3, pipe_test.product
03)----TableScan: pipe_test projection=[product, sales, quarter]
physical_plan
01)AggregateExec: mode=FinalPartitioned, gby=[product@0 as product], aggr=[total_sales_q1, num_records_q1, total_sales_Q2, num_records_Q2]
02)--CoalesceBatchesExec: target_batch_size=8192
03)----RepartitionExec: partitioning=Hash([product@0], 4), input_partitions=4
04)------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
05)--------AggregateExec: mode=Partial, gby=[product@3 as product], aggr=[total_sales_q1, num_records_q1, total_sales_Q2, num_records_Q2]
06)----------ProjectionExec: expr=[CAST(sales@1 AS Int64) as __common_expr_1, quarter@2 = Q1 as __common_expr_2, quarter@2 = Q2 as __common_expr_3, product@0 as product]
07)------------DataSourceExec: partitions=1, partition_sizes=[1]

# Aggregation functions with multiple parameters
query TTT rowsort
SELECT product, sales, quarter FROM pipe_test
|> PIVOT(string_agg(sales, '_' order by sales) as agg FOR quarter IN ('Q1', 'Q2'));
----
Apple 1_77 0
Kale 51_70 23_85
