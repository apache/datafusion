# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# create test data
statement ok
create table foo (a int, b int) as values (1, 2), (3, 4), (5, 6), (null, null), (6, null), (null, 7);

# CASE WHEN with condition
query T
SELECT CASE a WHEN 1 THEN 'one' WHEN 3 THEN 'three' ELSE '?' END FROM foo
----
one
three
?
?
?
?

# CASE WHEN with no condition
query I
SELECT CASE WHEN a > 2 THEN a ELSE b END FROM foo
----
2
3
5
NULL
6
7

# column or explicit null
query I
SELECT CASE WHEN a > 2 THEN b ELSE null END FROM foo
----
NULL
4
6
NULL
NULL
NULL

# column or implicit null
query I
SELECT CASE WHEN a > 2 THEN b END FROM foo
----
NULL
4
6
NULL
NULL
NULL

# column or implicit null (no nulls)
query I
SELECT CASE WHEN NULLIF(NVL(a, 0) >= 0, FALSE) THEN b END FROM foo
----
2
4
6
NULL
NULL
7

# column or implicit null (all nulls)
query I
SELECT CASE WHEN NULLIF(NVL(a, 0) >= 0, TRUE) THEN b END FROM foo
----
NULL
NULL
NULL
NULL
NULL
NULL

# scalar or scalar (string)
query T
SELECT CASE WHEN a > 2 THEN 'even' ELSE 'odd' END FROM foo
----
odd
even
even
odd
even
odd

# scalar or scalar (int)
query I
SELECT CASE WHEN a > 2 THEN 1 ELSE 0 END FROM foo
----
0
1
1
0
1
0

# predicate binary expression with scalars (does not make much sense because the expression in
# this case is always false, so this expression could be rewritten as a literal 0 during planning
query I
SELECT CASE WHEN 1 > 2 THEN 1 ELSE 0 END FROM foo
----
0
0
0
0
0
0

# predicate using boolean literal (does not make much sense because the expression in
# this case is always false, so this expression could be rewritten as a literal 0 during planning
query I
SELECT CASE WHEN false THEN 1 ELSE 0 END FROM foo
----
0
0
0
0
0
0

# test then value type coercion
# List(Utf8) will be casted to List(Int64)
query ?
SELECT CASE 1 WHEN 1 THEN ['1', '2', '3'] WHEN 2 THEN [1, 2, 3] ELSE null END;
----
[1, 2, 3]

query ?
SELECT CASE 1 WHEN 1 THEN [[1,2], [2,4]] WHEN 2 THEN [['1','2'], ['2','4']] ELSE null END;
----
[[1, 2], [2, 4]]

query ?
SELECT CASE 1 WHEN 1 THEN [1,2,3] WHEN 2 THEN arrow_cast([1,2,3], 'LargeList(Int64)') WHEN 3 THEN arrow_cast([1,2,3], 'FixedSizeList(3, Int32)') ELSE null END;
----
[1, 2, 3]

query ?
SELECT CASE 1 WHEN 1 THEN [[1,2], [2,4]] WHEN 2 THEN arrow_cast([[1,2], [2,4]], 'LargeList(LargeList(Int64))') WHEN 3 THEN arrow_cast([[1,2], [2,4]], 'FixedSizeList(2, FixedSizeList(2, Int32))') ELSE null END;
----
[[1, 2], [2, 4]]

query ?
SELECT CASE 1 WHEN 1 THEN [1,2,3] WHEN 2 THEN arrow_cast(['1','2','3'], 'LargeList(Utf8)') WHEN 3 THEN arrow_cast(['1','2','3'], 'FixedSizeList(3, Utf8)') ELSE null END;
----
[1, 2, 3]

query ?
SELECT CASE 1 WHEN 1 THEN [[1,2], [2,4]] WHEN 2 THEN arrow_cast([['1','2'], ['2','4']], 'LargeList(LargeList(Utf8))') WHEN 3 THEN arrow_cast([['1','2'], ['2','4']], 'FixedSizeList(2, FixedSizeList(2, Utf8))') ELSE null END;
----
[[1, 2], [2, 4]]

query ?
SELECT CASE 1 WHEN 1 THEN arrow_cast([1,2,3], 'LargeList(Int64)') WHEN 2 THEN arrow_cast(['1','2','3'], 'LargeList(Utf8)') ELSE null END;
----
[1, 2, 3]

query ?
SELECT CASE 1 WHEN 1 THEN arrow_cast([1, 2], 'FixedSizeList(2, Int64)') WHEN 2 THEN arrow_cast(['1', '2', '3'], 'FixedSizeList(3, Utf8)') ELSE null END;
----
[1, 2]

query error DataFusion error: type_coercion
SELECT CASE 1 WHEN 1 THEN [1,2,3] WHEN 2 THEN 'test' ELSE null END;

# test case when type coercion
query I
SELECT CASE [1,2,3] WHEN arrow_cast([1,2,3], 'LargeList(Int64)') THEN 1 ELSE 0 END;
----
1

query I
SELECT CASE [1,2,3] WHEN arrow_cast(['1','2','3'], 'LargeList(Int64)') THEN 1 ELSE 0 END;
----
1

query I
SELECT CASE arrow_cast([1,2,3], 'LargeList(Int64)') WHEN [1,2,3] THEN 1 ELSE 0 END;
----
1

query I
SELECT CASE [[1,2],[2,4]] WHEN arrow_cast([[1,2],[2,4]], 'LargeList(LargeList(Int64))') THEN 1 ELSE 0 END;
----
1

query I
SELECT CASE arrow_cast([1,2,3], 'FixedSizeList(3, Int64)') WHEN [1,2,3] THEN 1 ELSE 0 END;
----
1

query error DataFusion error: type_coercion
SELECT CASE [1,2,3] WHEN 'test' THEN 1 ELSE 0 END;

query I
SELECT CASE arrow_cast([1,2], 'FixedSizeList(2, Int64)') WHEN arrow_cast([1,2,3], 'FixedSizeList(3, Int64)') THEN 1 ELSE 0 END;
----
0

query I
SELECT CASE arrow_cast([1,2], 'FixedSizeList(2, Int64)') WHEN arrow_cast(['1','2','3'], 'FixedSizeList(3, Utf8)') THEN 1 ELSE 0 END;
----
0

query I
SELECT CASE arrow_cast(['1','2'], 'FixedSizeList(2, Utf8)') WHEN arrow_cast([1,2,3], 'FixedSizeList(3, Int64)') THEN 1 ELSE 0 END;
----
0

query I
SELECT CASE arrow_cast([1,2,3], 'FixedSizeList(3, Int64)') WHEN arrow_cast([1,2,3], 'FixedSizeList(3, Int64)') THEN 1 ELSE 0 END;
----
1

# CASE WHEN with single predicate and two non-trivial branches (expr or expr usage)
query I
SELECT CASE WHEN a < 5 THEN a + b ELSE b - NVL(a, 0) END FROM foo
----
3
7
1
NULL
NULL
7

# Reproducer for
# https://github.com/apache/datafusion/issues/14099
query I
SELECT - 79 * + 91 * - COUNT ( * ) * + - 2 * + - NULLIF ( - 49, - COALESCE ( - + 69, - COALESCE ( + COALESCE ( - 20, ( - 18 ) * + COUNT ( * ) + - 93, - CASE 51 WHEN + COUNT ( * ) + 28 THEN 0 ELSE + 29 * + CASE ( 50 ) WHEN - ( - ( CASE WHEN NOT + 37 IS NULL THEN + COUNT ( * ) END ) ) THEN NULL WHEN - 46 + 87 * - 28 THEN 85 WHEN - COUNT ( * ) THEN NULL END END ), COUNT ( * ) - 39 ) * + 22 ) / - COUNT ( * ) )
----
-704522


query B
select case when true then false end from foo;
----
false
false
false
false
false
false

query I
select case when true then a end from foo;
----
1
3
5
NULL
6
NULL

query I
select case when false then a end from foo;
----
NULL
NULL
NULL
NULL
NULL
NULL

query I
select case when null then a end from foo;
----
NULL
NULL
NULL
NULL
NULL
NULL


query B
select case when a=1 then false end from foo;
----
false
NULL
NULL
NULL
NULL
NULL

query IBB
SELECT c,
    CASE WHEN c > 0 THEN true END AS c1,
    CASE WHEN c > 0 THEN true ELSE false END AS c2
FROM (VALUES (1), (0), (-1), (NULL)) AS t(c)
----
1 true true
0 NULL false
-1 NULL false
NULL NULL false

statement ok
drop table foo


# Test coercion of inner struct field names
# Reproducer for https://github.com/apache/datafusion/issues/14383
statement ok
create table t as values
(
 100,                                       -- column1 int (so the case isn't constant folded)
 { 'foo': 'bar' },                          -- column2 has List of Struct w/ Utf8
 { 'foo': arrow_cast('baz', 'Utf8View') },  -- column3 has List of Struct w/ Utf8View
 { 'foo': arrow_cast('blarg', 'Utf8View') } -- column4 has List of Struct w/ Utf8View
);


# Note field name is foo
query ???
SELECT column2, column3, column4  FROM t;
----
{foo: bar} {foo: baz} {foo: blarg}

# Coerce fields, expect the field name to be the name of the first arg to case
# the field should not be named 'c0'
query ?
SELECT
  case
    when column1 > 0 then column2
    when column1 < 0 then column3
    else column4
  end
FROM t;
----
{foo: bar}

query ?
SELECT
  case
    when column1 > 0 then column3 -- different arg order shouldn't affect name
    when column1 < 0 then column4
    else column2
  end
FROM t;
----
{foo: baz}

query ?
SELECT
  case
    when column1 > 0 then column4 -- different arg order shouldn't affect name
    when column1 < 0 then column2
    else column3
  end
FROM t;
----
{foo: blarg}

statement ok
drop table t


# Test coercion of inner struct field names with different orders / missing fields
statement ok
create table t as values
(
 100,                        -- column1 int (so the case isn't constant folded)
 { 'foo': 'a', 'xxx': 'b' }, -- column2: Struct with fields foo, xxx
 { 'xxx': 'c', 'foo': 'd' }, -- column3: Struct with fields xxx, foo
 { 'xxx': 'e'             }  -- column4: Struct with field xxx (no second field)
);

# Note field names are in different orders
query ???
SELECT column2, column3, column4  FROM t;
----
{foo: a, xxx: b} {xxx: c, foo: d} {xxx: e}

# coerce structs with different field orders
# With name-based struct coercion, matching fields by name:
# column2={foo:a, xxx:b} unified with column3={xxx:c, foo:d}
# Result uses the THEN branch's field order (when executed): {xxx: b, foo: a}
query ?
SELECT
  case
    when column1 > 0 then column2 -- always true
    else column3
  end
FROM t;
----
{xxx: b, foo: a}

# coerce structs with different field orders
# When ELSE branch executes, uses its field order: {xxx: c, foo: d}
query ?
SELECT
  case
    when column1 < 0 then column2 -- always false
    else column3
  end
FROM t;
----
{xxx: c, foo: d}

# coerce structs with subset of fields - field count mismatch causes type coercion failure
# column3 has 2 fields but column4 has only 1 field
query error DataFusion error: type_coercion\ncaused by\nError during planning: Failed to coerce then .* and else .* to common types in CASE WHEN expression
SELECT
  case
    when column1 > 0 then column3
    else column4
  end
FROM t;

statement ok
drop table t

# Fix coercion of lists of structs
# https://github.com/apache/datafusion/issues/14154

statement ok
create or replace table t as values
(
 100,                                         -- column1 int (so the case isn't constant folded)
 [{ 'foo': arrow_cast('baz', 'Utf8View') }],  -- column2 has List of Struct w/ Utf8View
 [{ 'foo': 'bar' }],                          -- column3 has List of Struct w/ Utf8
 [{ 'foo': 'blarg' }]                         -- column4 has List of Struct w/ Utf8
);

# This case forces all branches to be coerced to the same type
query ?
SELECT
  case
    when column1 > 0 then column2
    when column1 < 0 then column3
    else column4
  end
FROM t;
----
[{foo: baz}]

# different orders of the branches
query ?
SELECT
  case
    when column1 > 0 then column3 -- NB different order
    when column1 < 0 then column4
    else column2
  end
FROM t;
----
[{foo: bar}]

# different orders of the branches
query ?
SELECT
  case
    when column1 > 0 then column4 -- NB different order
    when column1 < 0 then column2
    else column3
  end
FROM t;
----
[{foo: blarg}]

# mix of then and else
query II
SELECT v, CASE WHEN v != 0 THEN 10/v ELSE 42 END FROM (VALUES (0), (1), (2)) t(v)
----
0 42
1 10
2 5

# when expressions is always false, then branch should never be evaluated
query II
SELECT v, CASE WHEN v < 0 THEN 10/0 ELSE 1 END FROM (VALUES (1), (2)) t(v)
----
1 1
2 1

# when expressions is always true, else branch should never be evaluated
query II
SELECT v, CASE WHEN v > 0 THEN 1 ELSE 10/0 END FROM (VALUES (1), (2)) t(v)
----
1 1
2 1


# lazy evaluation of multiple when branches, else branch should never be evaluated
query II
SELECT v, CASE WHEN v == 1 THEN -1 WHEN v == 2 THEN -2 WHEN v == 3 THEN -3  ELSE 10/0 END FROM (VALUES (1), (2), (3)) t(v)
----
1 -1
2 -2
3 -3

# covers the InfallibleExprOrNull evaluation strategy
query II
SELECT v, CASE WHEN v THEN 1 END FROM (VALUES (1), (2), (3), (NULL)) t(v)
----
1 1
2 1
3 1
NULL NULL

statement ok
drop table t

query I
SELECT case when true then 1 / 1 else 1 / 0 end;
----
1

query I
SELECT case when false then 1 / 0 else 1 / 1 end;
----
1

# Else branch evaluation with case expression, 1 when branch, null input
query I
SELECT CASE a WHEN 'a' THEN 0 ELSE 1 END FROM (VALUES (NULL)) t(a)
----
1

# Else branch evaluation with case expression, 2 when branches, null input
query I
SELECT CASE a WHEN 'a' THEN 0 WHEN 'b' THEN 1 ELSE 2 END FROM (VALUES (NULL)) t(a)
----
2

# Else branch evaluation without case expression, 1 when branch, null input
query I
SELECT CASE WHEN a = 'a' THEN 0 ELSE 1 END FROM (VALUES (NULL)) t(a)
----
1

# Else branch evaluation without case expression, 2 when branches, null input
query I
SELECT CASE WHEN a = 'a' THEN 0 WHEN a = 'b' THEN 1 ELSE 2 END FROM (VALUES (NULL)) t(a)
----
2

# Else branch evaluation with case expression, 1 when branch, non-null input
query I
SELECT CASE a WHEN 'a' THEN 0 ELSE 1 END FROM (VALUES ('z')) t(a)
----
1

# Else branch evaluation with case expression, 2 when branches, non-null input
query I
SELECT CASE a WHEN 'a' THEN 0 WHEN 'b' THEN 1 ELSE 2 END FROM (VALUES ('z')) t(a)
----
2

# Else branch evaluation without case expression, 1 when branch, non-null input
query I
SELECT CASE WHEN a = 'a' THEN 0 ELSE 1 END FROM (VALUES ('z')) t(a)
----
1

# Else branch evaluation without case expression, 2 when branches, non-null input
query I
SELECT CASE WHEN a = 'a' THEN 0 WHEN a = 'b' THEN 1 ELSE 2 END FROM (VALUES ('z')) t(a)
----
2

# Else branch evaluation with case expression, 1 when branch, mixed input
query I
SELECT CASE a WHEN 'a' THEN 0 ELSE 1 END FROM (VALUES (NULL), ('z')) t(a)
----
1
1

# Else branch evaluation with case expression, 2 when branches, mixed input
query I
SELECT CASE a WHEN 'a' THEN 0 WHEN 'b' THEN 1 ELSE 2 END FROM (VALUES (NULL), ('z')) t(a)
----
2
2

# Else branch evaluation without case expression, 1 when branch, mixed input
query I
SELECT CASE WHEN a = 'a' THEN 0 ELSE 1 END FROM (VALUES (NULL), ('z')) t(a)
----
1
1

# Else branch evaluation without case expression, 2 when branches, mixed input
query I
SELECT CASE WHEN a = 'a' THEN 0 WHEN a = 'b' THEN 1 ELSE 2 END FROM (VALUES (NULL), ('z')) t(a)
----
2
2

# The `WHEN 1/0` is not effectively reachable in this query and should never be executed
query T
SELECT CASE a WHEN 1 THEN 'a' WHEN 2 THEN 'b' WHEN 1 / 0 THEN 'c' ELSE 'd' END FROM (VALUES (1), (2)) t(a)
----
a
b

# The `WHEN 1/0` is not effectively reachable in this query and should never be executed
query T
SELECT CASE WHEN a = 1 THEN 'a' WHEN a = 2 THEN 'b' WHEN a = 1 / 0 THEN 'c' ELSE 'd' END FROM (VALUES (1), (2)) t(a)
----
a
b

# The `WHEN 1/0` is not effectively reachable in this query and should never be executed
query T
SELECT CASE WHEN a = 0 THEN 'a' WHEN 1 / a = 1 THEN 'b' ELSE 'c' END FROM (VALUES (0), (1), (2)) t(a)
----
a
b
c

# EvalMethod::WithExpression using subset of all selected columns in case expression
query III
SELECT CASE a1 WHEN 1 THEN a1 WHEN 2 THEN a2 WHEN 3 THEN b END, b, c
FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1 10 100
2 20 200
30 30 300

# EvalMethod::NoExpression using subset of all selected columns in case expression
query III
SELECT CASE WHEN a1 = 1 THEN a2 WHEN a2 = 2 THEN a1 WHEN 3 THEN b END, b, c
FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1 10 100
2 20 200
30 30 300

# EvalMethod::ExpressionOrExpression using subset of all selected columns in case expression
query III
SELECT CASE WHEN a1 = 1 THEN a2 ELSE b END, b, c
FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1 10 100
20 20 200
30 30 300

# EvalMethod::WithExpression using all selected columns in case expression
query I
SELECT CASE a1 WHEN 1 THEN a1 WHEN 2 THEN a2 WHEN 3 THEN NULL END
FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1
2
NULL

# EvalMethod::NoExpression using all selected columns in case expression
query I
SELECT CASE WHEN a1 = 1 THEN a2 WHEN a2 = 2 THEN a1 WHEN 3 THEN NULL END
FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1
2
NULL

# EvalMethod::ExpressionOrExpression using all selected columns in case expression
query I
SELECT CASE WHEN a1 = 1 THEN a2 ELSE NULL END
FROM (SELECT a as a1, a as a2 FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c));
----
1
NULL
NULL

# Nested case with projection
query III
SELECT CASE WHEN a = -1 THEN b WHEN a = -2 THEN -b END, b, c
FROM (
  SELECT b, c, CASE WHEN a1 = 1 THEN -a2 WHEN a1 = 2 THEN -a1 END as a
  FROM (SELECT a as a1, a as a2, b, c FROM (VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)) t(a, b, c))
);
----
10 10 100
-20 20 200
NULL 30 300

# Case-with-expression that was incorrectly classified as not-nullable, but evaluates to null
query I
SELECT CASE 0 WHEN 0 THEN NULL WHEN SUM(1) + COUNT(*) THEN 10 ELSE 20 END
----
NULL

query TT
EXPLAIN SELECT CASE WHEN CASE WHEN a IS NOT NULL THEN a ELSE 1 END IS NOT NULL THEN a ELSE 1 END FROM (
    VALUES (10), (20), (30)
  ) t(a);
----
logical_plan
01)Projection: t.a AS CASE WHEN CASE WHEN t.a IS NOT NULL THEN t.a ELSE Int64(1) END IS NOT NULL THEN t.a ELSE Int64(1) END
02)--SubqueryAlias: t
03)----Projection: column1 AS a
04)------Values: (Int64(10)), (Int64(20)), (Int64(30))
physical_plan
01)ProjectionExec: expr=[column1@0 as CASE WHEN CASE WHEN t.a IS NOT NULL THEN t.a ELSE Int64(1) END IS NOT NULL THEN t.a ELSE Int64(1) END]
02)--DataSourceExec: partitions=1, partition_sizes=[1]

#####
# CASE with literal characters (to test lookup table CASE optimization)
#####
statement ok
create table source (letter varchar) as values ('a'), ('b'), (NULL), ('c'), ('a'), ('c'), ('d');

# Table with different string types
statement ok
create table letters as
select
  arrow_cast(letter, 'Utf8') as letter_utf8,
  arrow_cast(letter, 'LargeUtf8') as letter_large_utf8,
  arrow_cast(letter, 'Utf8View') as letter_utf8_view,
  arrow_cast(letter, 'Dictionary(Int32, Utf8)') as letter_string_dict,
from source;


query TIIIII
select
  letter_utf8 as letter
  ,CASE letter_utf8       WHEN 'b' THEN 1 WHEN 'a' THEN 2 WHEN 'd' THEN 3 ELSE 0 END as utf8
  ,CASE letter_large_utf8 WHEN 'b' THEN 1 WHEN 'a' THEN 2 WHEN 'd' THEN 3 ELSE 0 END as large_utf8
  ,CASE letter_utf8_view  WHEN 'b' THEN 1 WHEN 'a' THEN 2 WHEN 'd' THEN 3 ELSE 0 END as utf8_view
  ,CASE letter_string_dict WHEN 'b' THEN 1 WHEN 'a' THEN 2 WHEN 'd' THEN 3 ELSE 0 END as string_dict
  ,CASE letter_utf8       WHEN 'b' THEN 1 WHEN NULL THEN 2 WHEN 'd' THEN 3 ELSE 0 END as utf8_with_null
FROM letters;
----
a 2 2 2 2 0
b 1 1 1 1 1
NULL 0 0 0 0 0
c 0 0 0 0 0
a 2 2 2 2 0
c 0 0 0 0 0
d 3 3 3 3 3

statement ok
create table letters_binary as
select
  arrow_cast(letter, 'Binary') as letter_binary,
  arrow_cast(letter, 'LargeBinary') as letter_large_binary,
  arrow_cast(letter, 'BinaryView') as letter_binary_view,
  arrow_cast(letter, 'Dictionary(Int32, Binary)') as letter_binary_dict,
  arrow_cast(arrow_cast(letter, 'Binary'), 'FixedSizeBinary(1)') as letter_fsb
from source;

query ?IIIII
select
    letter_binary as letter
    ,CASE letter_binary       WHEN X'62' THEN 1 WHEN X'61' THEN 2 WHEN X'64' THEN 3 ELSE 0 END as binary
    ,CASE letter_large_binary WHEN X'62' THEN 1 WHEN X'61' THEN 2 WHEN X'64' THEN 3 ELSE 0 END as large_binary
    ,CASE letter_binary_view  WHEN X'62' THEN 1 WHEN X'61' THEN 2 WHEN X'64' THEN 3 ELSE 0 END as binary_view
    ,CASE letter_binary_dict  WHEN X'62' THEN 1 WHEN X'61' THEN 2 WHEN X'64' THEN 3 ELSE 0 END as binary_dict
    ,CASE letter_fsb          WHEN X'62' THEN 1 WHEN X'61' THEN 2 WHEN X'64' THEN 3 ELSE 0 END as fsb
FROM letters_binary;
----
61 2 2 2 2 2
62 1 1 1 1 1
NULL 0 0 0 0 0
63 0 0 0 0 0
61 2 2 2 2 2
63 0 0 0 0 0
64 3 3 3 3 3

statement ok
drop table source;


statement ok
drop table letters;

statement ok
drop table letters_binary;

# Tests for CASE with boolean expressions
statement ok
create table booleans (b boolean) as values (true), (false), (null), (true), (null), (false);

query BIII
select
    b as boolean_value
    ,CASE b WHEN true THEN 1 WHEN false THEN 2 ELSE 0 END as boolean_case
    ,CASE b WHEN false THEN 1 WHEN true THEN 2 ELSE 0 END as boolean_case_rev
    ,CASE b WHEN true THEN 1 WHEN NULL THEN 2 WHEN false THEN 3 ELSE 0 END as boolean_with_nulls
FROM booleans;
----
true 1 2 1
false 2 1 3
NULL 0 0 0
true 1 2 1
NULL 0 0 0
false 2 1 3

statement ok
drop table booleans;

# Tests for CASE with floating point literals
statement ok
create table float_source (f float) as values (1.0), (2.0), (null), (3.5), (2.0), (null);

statement ok
create table floats as
select
    arrow_cast(f, 'Float16') as f16,
    arrow_cast(f, 'Float32') as f32,
    arrow_cast(f, 'Float64') as f64,
    arrow_cast(f, 'Dictionary(Int32, Float32)') as f32_dict,
from float_source;

query RTTTT
select
    f32 as float_value
    ,CASE f16      WHEN 1.0 THEN 'one'  WHEN 3.5 THEN 'three_point_five' WHEN 2.0 THEN 'two' ELSE 'N/A' END as f16_case
    ,CASE f32      WHEN 1.0 THEN 'one'  WHEN 3.5 THEN 'three_point_five' WHEN 2.0 THEN 'two' ELSE 'N/A' END as f32_case
    ,CASE f64      WHEN 1.0 THEN 'one'  WHEN 3.5 THEN 'three_point_five' WHEN 2.0 THEN 'two' ELSE 'N/A' END as f64_case
    ,CASE f32_dict WHEN 1.0 THEN 'one'  WHEN 3.5 THEN 'three_point_five' WHEN 2.0 THEN 'two' ELSE 'N/A' END as f32_dict_case
FROM floats;
----
1 one one one one
2 two two two two
NULL N/A N/A N/A N/A
3.5 three_point_five three_point_five three_point_five three_point_five
2 two two two two
NULL N/A N/A N/A N/A

statement ok
drop table float_source;

statement ok
drop table floats;

#####
# End of lookup table CASE tests
#####
