# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

##########
# Tests for projection pushdown behavior with get_field expressions
#
# This file tests the ExtractTrivialProjections optimizer rule and
# physical projection pushdown for:
# - get_field expressions (struct field access like s['foo'])
# - Pushdown through Filter, Sort, and TopK operators
# - Multi-partition scenarios with SortPreservingMergeExec
##########

#####################
# Section 1: Setup - Single Partition Tests
#####################

# Set target_partitions = 1 for deterministic plan output
statement ok
SET datafusion.execution.target_partitions = 1;

# Create parquet file with struct column containing value and label fields
statement ok
COPY (
    SELECT
        column1 as id,
        column2 as s
    FROM VALUES
        (1, {value: 100, label: 'alpha'}),
        (2, {value: 200, label: 'beta'}),
        (3, {value: 150, label: 'gamma'}),
        (4, {value: 300, label: 'delta'}),
        (5, {value: 250, label: 'epsilon'})
) TO 'test_files/scratch/projection_pushdown/simple.parquet'
STORED AS PARQUET;

# Create table for simple struct tests
statement ok
CREATE EXTERNAL TABLE simple_struct STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/simple.parquet';

# Create parquet file with nested struct column
statement ok
COPY (
    SELECT
        column1 as id,
        column2 as nested
    FROM VALUES
        (1, {outer: {inner: 10, name: 'one'}, extra: 'x'}),
        (2, {outer: {inner: 20, name: 'two'}, extra: 'y'}),
        (3, {outer: {inner: 30, name: 'three'}, extra: 'z'})
) TO 'test_files/scratch/projection_pushdown/nested.parquet'
STORED AS PARQUET;

# Create table for nested struct tests
statement ok
CREATE EXTERNAL TABLE nested_struct STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/nested.parquet';

# Create parquet file with nullable struct column
statement ok
COPY (
    SELECT
        column1 as id,
        column2 as s
    FROM VALUES
        (1, {value: 100, label: 'alpha'}),
        (2, NULL),
        (3, {value: 150, label: 'gamma'}),
        (4, NULL),
        (5, {value: 250, label: 'epsilon'})
) TO 'test_files/scratch/projection_pushdown/nullable.parquet'
STORED AS PARQUET;

# Create table for nullable struct tests
statement ok
CREATE EXTERNAL TABLE nullable_struct STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/nullable.parquet';


#####################
# Section 2: Basic get_field Pushdown (Projection above scan)
#####################

###
# Test 2.1: Simple s['value']
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct;
----
logical_plan
01)Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value"))
02)--TableScan: simple_struct projection=[id, s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value]], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY id;
----
1 100
2 200
3 150
4 300
5 250

query TT
EXPLAIN SELECT s['label'] FROM simple_struct;
----
logical_plan
01)Projection: get_field(simple_struct.s, Utf8("label"))
02)--TableScan: simple_struct projection=[s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, label) as simple_struct.s[label]], file_type=parquet

# Verify correctness
query T
SELECT s['label'] FROM simple_struct ORDER BY s['label'];
----
alpha
beta
delta
epsilon
gamma

###
# Test 2.2: Multiple get_field expressions
###

query TT
EXPLAIN SELECT id, s['value'], s['label'] FROM simple_struct;
----
logical_plan
01)Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")), get_field(simple_struct.s, Utf8("label"))
02)--TableScan: simple_struct projection=[id, s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value], get_field(s@1, label) as simple_struct.s[label]], file_type=parquet

# Verify correctness
query IIT
SELECT id, s['value'], s['label'] FROM simple_struct ORDER BY id;
----
1 100 alpha
2 200 beta
3 150 gamma
4 300 delta
5 250 epsilon

###
# Test 2.3: Nested s['outer']['inner']
###

query TT
EXPLAIN SELECT id, nested['outer']['inner'] FROM nested_struct;
----
logical_plan
01)Projection: nested_struct.id, get_field(nested_struct.nested, Utf8("outer"), Utf8("inner"))
02)--TableScan: nested_struct projection=[id, nested]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/nested.parquet]]}, projection=[id, get_field(nested@1, outer, inner) as nested_struct.nested[outer][inner]], file_type=parquet

# Verify correctness
query II
SELECT id, nested['outer']['inner'] FROM nested_struct ORDER BY id;
----
1 10
2 20
3 30

###
# Test 2.4: s['value'] + 1
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM simple_struct;
----
logical_plan
01)Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) + Int64(1)
02)--TableScan: simple_struct projection=[id, s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) + 1 as simple_struct.s[value] + Int64(1)], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM simple_struct ORDER BY id;
----
1 101
2 201
3 151
4 301
5 251

###
# Test 2.5: s['label'] || '_suffix'
###

query TT
EXPLAIN SELECT id, s['label'] || '_suffix' FROM simple_struct;
----
logical_plan
01)Projection: simple_struct.id, get_field(simple_struct.s, Utf8("label")) || Utf8("_suffix")
02)--TableScan: simple_struct projection=[id, s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, label) || _suffix as simple_struct.s[label] || Utf8("_suffix")], file_type=parquet

# Verify correctness
query IT
SELECT id, s['label'] || '_suffix' FROM simple_struct ORDER BY id;
----
1 alpha_suffix
2 beta_suffix
3 gamma_suffix
4 delta_suffix
5 epsilon_suffix


#####################
# Section 3: Projection Pushdown Through FilterExec
#####################

###
# Test 3.1: Simple get_field through Filter
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_1 AS simple_struct.s[value]
02)--Filter: simple_struct.id > Int64(2)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as simple_struct.s[value]]
02)--FilterExec: id@1 > 2
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct WHERE id > 2 ORDER BY id;
----
3 150
4 300
5 250

###
# Test 3.2: s['value'] + 1 through Filter
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_1 + Int64(1) AS simple_struct.s[value] + Int64(1)
02)--Filter: simple_struct.id > Int64(2)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 + 1 as simple_struct.s[value] + Int64(1)]
02)--FilterExec: id@1 > 2
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM simple_struct WHERE id > 2 ORDER BY id;
----
3 151
4 301
5 251

###
# Test 3.3: Filter on get_field expression
###

query TT
EXPLAIN SELECT id, s['label'] FROM simple_struct WHERE s['value'] > 150;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_2 AS simple_struct.s[label]
02)--Filter: __datafusion_extracted_1 > Int64(150)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2
04)------TableScan: simple_struct projection=[id, s], partial_filters=[get_field(simple_struct.s, Utf8("value")) > Int64(150)]
physical_plan
01)ProjectionExec: expr=[id@0 as id, __datafusion_extracted_2@1 as simple_struct.s[label]]
02)--FilterExec: __datafusion_extracted_1@0 > 150, projection=[id@1, __datafusion_extracted_2@2]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id, get_field(s@1, label) as __datafusion_extracted_2], file_type=parquet

# Verify correctness
query IT
SELECT id, s['label'] FROM simple_struct WHERE s['value'] > 150 ORDER BY id;
----
2 beta
4 delta
5 epsilon


#####################
# Section 4: Projection Pushdown Through SortExec (no LIMIT)
#####################

###
# Test 4.1: Simple get_field through Sort
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct ORDER BY id;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value]], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY id;
----
1 100
2 200
3 150
4 300
5 250

###
# Test 4.2: s['value'] + 1 through Sort - split projection
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM simple_struct ORDER BY id;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) + Int64(1)
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) + 1 as simple_struct.s[value] + Int64(1)], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM simple_struct ORDER BY id;
----
1 101
2 201
3 151
4 301
5 251

###
# Test 4.3: Sort by get_field expression
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct ORDER BY s['value'];
----
logical_plan
01)Sort: simple_struct.s[value] ASC NULLS LAST
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: expr=[simple_struct.s[value]@1 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value]], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY s['value'];
----
1 100
3 150
2 200
5 250
4 300

###
# Test 4.4: Projection with duplicate column through Sort
# The projection expands the number of columns from 3 to 4 by introducing `col_b_dup`
###

statement ok
COPY (
    SELECT
        column1 as col_a,
        column2 as col_b,
        column3 as col_c
    FROM VALUES
        (1, 2, 3),
        (4, 5, 6),
        (7, 8, 9)
) TO 'test_files/scratch/projection_pushdown/three_cols.parquet'
STORED AS PARQUET;

statement ok
CREATE EXTERNAL TABLE three_cols STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/three_cols.parquet';

query TT
EXPLAIN SELECT col_a, col_b, col_c, col_b as col_b_dup FROM three_cols ORDER BY col_a;
----
logical_plan
01)Sort: three_cols.col_a ASC NULLS LAST
02)--Projection: three_cols.col_a, three_cols.col_b, three_cols.col_c, three_cols.col_b AS col_b_dup
03)----TableScan: three_cols projection=[col_a, col_b, col_c]
physical_plan
01)SortExec: expr=[col_a@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/three_cols.parquet]]}, projection=[col_a, col_b, col_c, col_b@1 as col_b_dup], file_type=parquet

# Verify correctness
query IIII
SELECT col_a, col_b, col_c, col_b as col_b_dup FROM three_cols ORDER BY col_a DESC;
----
7 8 9 8
4 5 6 5
1 2 3 2

statement ok
DROP TABLE three_cols;


#####################
# Section 5: Projection Pushdown Through TopK (ORDER BY + LIMIT)
#####################

###
# Test 5.1: Simple get_field through TopK
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY id LIMIT 3;
----
1 100
2 200
3 150

###
# Test 5.2: s['value'] + 1 through TopK
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) + Int64(1)
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) + 1 as simple_struct.s[value] + Int64(1)], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM simple_struct ORDER BY id LIMIT 3;
----
1 101
2 201
3 151

###
# Test 5.3: Multiple get_field through TopK
###

query TT
EXPLAIN SELECT id, s['value'], s['label'] FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")), get_field(simple_struct.s, Utf8("label"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value], get_field(s@1, label) as simple_struct.s[label]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query IIT
SELECT id, s['value'], s['label'] FROM simple_struct ORDER BY id LIMIT 3;
----
1 100 alpha
2 200 beta
3 150 gamma

###
# Test 5.4: Nested get_field through TopK
###

query TT
EXPLAIN SELECT id, nested['outer']['inner'] FROM nested_struct ORDER BY id LIMIT 2;
----
logical_plan
01)Sort: nested_struct.id ASC NULLS LAST, fetch=2
02)--Projection: nested_struct.id, get_field(nested_struct.nested, Utf8("outer"), Utf8("inner"))
03)----TableScan: nested_struct projection=[id, nested]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/nested.parquet]]}, projection=[id, get_field(nested@1, outer, inner) as nested_struct.nested[outer][inner]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, nested['outer']['inner'] FROM nested_struct ORDER BY id LIMIT 2;
----
1 10
2 20

###
# Test 5.5: String concat through TopK
###

query TT
EXPLAIN SELECT id, s['label'] || '_suffix' FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("label")) || Utf8("_suffix")
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, label) || _suffix as simple_struct.s[label] || Utf8("_suffix")], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query IT
SELECT id, s['label'] || '_suffix' FROM simple_struct ORDER BY id LIMIT 3;
----
1 alpha_suffix
2 beta_suffix
3 gamma_suffix


#####################
# Section 6: Combined Operators (Filter + Sort/TopK)
#####################

###
# Test 6.1: Filter + Sort + get_field
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct WHERE id > 1 ORDER BY s['value'];
----
logical_plan
01)Sort: simple_struct.s[value] ASC NULLS LAST
02)--Projection: simple_struct.id, __datafusion_extracted_1 AS simple_struct.s[value]
03)----Filter: simple_struct.id > Int64(1)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)SortExec: expr=[simple_struct.s[value]@1 ASC NULLS LAST], preserve_partitioning=[false]
02)--ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as simple_struct.s[value]]
03)----FilterExec: id@1 > 1
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct WHERE id > 1 ORDER BY s['value'];
----
3 150
2 200
5 250
4 300

###
# Test 6.2: Filter + TopK + get_field
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct WHERE id > 1 ORDER BY s['value'] LIMIT 2;
----
logical_plan
01)Sort: simple_struct.s[value] ASC NULLS LAST, fetch=2
02)--Projection: simple_struct.id, __datafusion_extracted_1 AS simple_struct.s[value]
03)----Filter: simple_struct.id > Int64(1)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)SortExec: TopK(fetch=2), expr=[simple_struct.s[value]@1 ASC NULLS LAST], preserve_partitioning=[false]
02)--ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as simple_struct.s[value]]
03)----FilterExec: id@1 > 1
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct WHERE id > 1 ORDER BY s['value'] LIMIT 2;
----
3 150
2 200

###
# Test 6.3: Filter + TopK + get_field with arithmetic
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM simple_struct WHERE id > 1 ORDER BY id LIMIT 2;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=2
02)--Projection: simple_struct.id, __datafusion_extracted_1 + Int64(1) AS simple_struct.s[value] + Int64(1)
03)----Filter: simple_struct.id > Int64(1)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 + 1 as simple_struct.s[value] + Int64(1)]
03)----FilterExec: id@1 > 1
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1 AND DynamicFilter [ empty ], pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM simple_struct WHERE id > 1 ORDER BY id LIMIT 2;
----
2 201
3 151


#####################
# Section 7: Multi-Partition Tests
#####################

# Set target_partitions = 4 for parallel execution
statement ok
SET datafusion.execution.target_partitions = 4;

# Create 5 parquet files (more than partitions) for parallel tests
statement ok
COPY (SELECT 1 as id, {value: 100, label: 'alpha'} as s)
TO 'test_files/scratch/projection_pushdown/multi/part1.parquet'
STORED AS PARQUET;

statement ok
COPY (SELECT 2 as id, {value: 200, label: 'beta'} as s)
TO 'test_files/scratch/projection_pushdown/multi/part2.parquet'
STORED AS PARQUET;

statement ok
COPY (SELECT 3 as id, {value: 150, label: 'gamma'} as s)
TO 'test_files/scratch/projection_pushdown/multi/part3.parquet'
STORED AS PARQUET;

statement ok
COPY (SELECT 4 as id, {value: 300, label: 'delta'} as s)
TO 'test_files/scratch/projection_pushdown/multi/part4.parquet'
STORED AS PARQUET;

statement ok
COPY (SELECT 5 as id, {value: 250, label: 'epsilon'} as s)
TO 'test_files/scratch/projection_pushdown/multi/part5.parquet'
STORED AS PARQUET;

# Create table from multiple parquet files
statement ok
CREATE EXTERNAL TABLE multi_struct STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/multi/';

###
# Test 7.1: Multi-partition Sort with get_field
###

query TT
EXPLAIN SELECT id, s['value'] FROM multi_struct ORDER BY id;
----
logical_plan
01)Sort: multi_struct.id ASC NULLS LAST
02)--Projection: multi_struct.id, get_field(multi_struct.s, Utf8("value"))
03)----TableScan: multi_struct projection=[id, s]
physical_plan
01)SortPreservingMergeExec: [id@0 ASC NULLS LAST]
02)--SortExec: expr=[id@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part1.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part3.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part4.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part5.parquet]]}, projection=[id, get_field(s@1, value) as multi_struct.s[value]], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM multi_struct ORDER BY id;
----
1 100
2 200
3 150
4 300
5 250

###
# Test 7.2: Multi-partition TopK with get_field
###

query TT
EXPLAIN SELECT id, s['value'] FROM multi_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: multi_struct.id ASC NULLS LAST, fetch=3
02)--Projection: multi_struct.id, get_field(multi_struct.s, Utf8("value"))
03)----TableScan: multi_struct projection=[id, s]
physical_plan
01)SortPreservingMergeExec: [id@0 ASC NULLS LAST], fetch=3
02)--SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part1.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part3.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part4.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part5.parquet]]}, projection=[id, get_field(s@1, value) as multi_struct.s[value]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, s['value'] FROM multi_struct ORDER BY id LIMIT 3;
----
1 100
2 200
3 150

###
# Test 7.3: Multi-partition TopK with arithmetic (non-trivial stays above merge)
###

query TT
EXPLAIN SELECT id, s['value'] + 1 FROM multi_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: multi_struct.id ASC NULLS LAST, fetch=3
02)--Projection: multi_struct.id, get_field(multi_struct.s, Utf8("value")) + Int64(1)
03)----TableScan: multi_struct projection=[id, s]
physical_plan
01)SortPreservingMergeExec: [id@0 ASC NULLS LAST], fetch=3
02)--SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part1.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part3.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part4.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part5.parquet]]}, projection=[id, get_field(s@1, value) + 1 as multi_struct.s[value] + Int64(1)], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, s['value'] + 1 FROM multi_struct ORDER BY id LIMIT 3;
----
1 101
2 201
3 151

###
# Test 7.4: Multi-partition Filter with get_field
###

query TT
EXPLAIN SELECT id, s['value'] FROM multi_struct WHERE id > 2 ORDER BY id;
----
logical_plan
01)Sort: multi_struct.id ASC NULLS LAST
02)--Projection: multi_struct.id, __datafusion_extracted_1 AS multi_struct.s[value]
03)----Filter: multi_struct.id > Int64(2)
04)------Projection: get_field(multi_struct.s, Utf8("value")) AS __datafusion_extracted_1, multi_struct.id
05)--------TableScan: multi_struct projection=[id, s], partial_filters=[multi_struct.id > Int64(2)]
physical_plan
01)SortPreservingMergeExec: [id@0 ASC NULLS LAST]
02)--SortExec: expr=[id@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as multi_struct.s[value]]
04)------FilterExec: id@1 > 2
05)--------RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=3
06)----------DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part1.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part3.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part4.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part5.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] FROM multi_struct WHERE id > 2 ORDER BY id;
----
3 150
4 300
5 250

###
# Test 7.5: Aggregation with get_field (CoalescePartitions)
###

query TT
EXPLAIN SELECT s['label'], SUM(s['value']) FROM multi_struct GROUP BY s['label'];
----
logical_plan
01)Projection: __datafusion_extracted_1 AS multi_struct.s[label], sum(__datafusion_extracted_2) AS sum(multi_struct.s[value])
02)--Aggregate: groupBy=[[__datafusion_extracted_1]], aggr=[[sum(__datafusion_extracted_2)]]
03)----Projection: get_field(multi_struct.s, Utf8("label")) AS __datafusion_extracted_1, get_field(multi_struct.s, Utf8("value")) AS __datafusion_extracted_2
04)------TableScan: multi_struct projection=[s]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as multi_struct.s[label], sum(__datafusion_extracted_2)@1 as sum(multi_struct.s[value])]
02)--AggregateExec: mode=FinalPartitioned, gby=[__datafusion_extracted_1@0 as __datafusion_extracted_1], aggr=[sum(__datafusion_extracted_2)]
03)----RepartitionExec: partitioning=Hash([__datafusion_extracted_1@0], 4), input_partitions=3
04)------AggregateExec: mode=Partial, gby=[__datafusion_extracted_1@0 as __datafusion_extracted_1], aggr=[sum(__datafusion_extracted_2)]
05)--------DataSourceExec: file_groups={3 groups: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part1.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part2.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part3.parquet, WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part4.parquet], [WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/multi/part5.parquet]]}, projection=[get_field(s@1, label) as __datafusion_extracted_1, get_field(s@1, value) as __datafusion_extracted_2], file_type=parquet

# Verify correctness
query TI
SELECT s['label'], SUM(s['value']) FROM multi_struct GROUP BY s['label'] ORDER BY s['label'];
----
alpha 100
beta 200
delta 300
epsilon 250
gamma 150


#####################
# Section 8: Edge Cases
#####################

# Reset to single partition for edge case tests
statement ok
SET datafusion.execution.target_partitions = 1;

###
# Test 8.1: get_field on nullable struct column
###

query TT
EXPLAIN SELECT id, s['value'] FROM nullable_struct;
----
logical_plan
01)Projection: nullable_struct.id, get_field(nullable_struct.s, Utf8("value"))
02)--TableScan: nullable_struct projection=[id, s]
physical_plan DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/nullable.parquet]]}, projection=[id, get_field(s@1, value) as nullable_struct.s[value]], file_type=parquet

# Verify correctness (NULL struct returns NULL field)
query II
SELECT id, s['value'] FROM nullable_struct ORDER BY id;
----
1 100
2 NULL
3 150
4 NULL
5 250

###
# Test 8.2: get_field returning NULL values
###

query TT
EXPLAIN SELECT id, s['label'] FROM nullable_struct WHERE s['value'] IS NOT NULL;
----
logical_plan
01)Projection: nullable_struct.id, __datafusion_extracted_2 AS nullable_struct.s[label]
02)--Filter: __datafusion_extracted_1 IS NOT NULL
03)----Projection: get_field(nullable_struct.s, Utf8("value")) AS __datafusion_extracted_1, nullable_struct.id, get_field(nullable_struct.s, Utf8("label")) AS __datafusion_extracted_2
04)------TableScan: nullable_struct projection=[id, s], partial_filters=[get_field(nullable_struct.s, Utf8("value")) IS NOT NULL]
physical_plan
01)ProjectionExec: expr=[id@0 as id, __datafusion_extracted_2@1 as nullable_struct.s[label]]
02)--FilterExec: __datafusion_extracted_1@0 IS NOT NULL, projection=[id@1, __datafusion_extracted_2@2]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/nullable.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id, get_field(s@1, label) as __datafusion_extracted_2], file_type=parquet

# Verify correctness
query IT
SELECT id, s['label'] FROM nullable_struct WHERE s['value'] IS NOT NULL ORDER BY id;
----
1 alpha
3 gamma
5 epsilon

###
# Test 8.3: Mixed trivial and non-trivial in same projection
###

query TT
EXPLAIN SELECT id, s['value'], s['value'] + 10, s['label'] FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")), get_field(simple_struct.s, Utf8("value")) + Int64(10), get_field(simple_struct.s, Utf8("label"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value], get_field(s@1, value) + 10 as simple_struct.s[value] + Int64(10), get_field(s@1, label) as simple_struct.s[label]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query IIIT
SELECT id, s['value'], s['value'] + 10, s['label'] FROM simple_struct ORDER BY id LIMIT 3;
----
1 100 110 alpha
2 200 210 beta
3 150 160 gamma

###
# Test 8.4: Literal projection through TopK
###

query TT
EXPLAIN SELECT id, 42 as constant FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, Int64(42) AS constant
03)----TableScan: simple_struct projection=[id]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, 42 as constant], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, 42 as constant FROM simple_struct ORDER BY id LIMIT 3;
----
1 42
2 42
3 42

###
# Test 8.5: Simple column through TopK (baseline comparison)
###

query TT
EXPLAIN SELECT id FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--TableScan: simple_struct projection=[id]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query I
SELECT id FROM simple_struct ORDER BY id LIMIT 3;
----
1
2
3


#####################
# Section 9: Coverage Tests - Edge Cases for Uncovered Code Paths
#####################

###
# Test 9.1: TopK with computed projection
###

query TT
EXPLAIN SELECT id, id + 100 as computed FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, simple_struct.id + Int64(100) AS computed
03)----TableScan: simple_struct projection=[id]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, id@0 + 100 as computed], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, id + 100 as computed FROM simple_struct ORDER BY id LIMIT 3;
----
1 101
2 102
3 103

###
# Test 9.2: Duplicate get_field expressions (same expression referenced twice)
# Common subexpression elimination happens in the logical plan, and the physical
# plan extracts the shared get_field for efficient computation
###

query TT
EXPLAIN SELECT (id + s['value']) * (id + s['value']) as id_and_value FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: __common_expr_1 * __common_expr_1 AS id_and_value
02)--Projection: simple_struct.id + __datafusion_extracted_2 AS __common_expr_1
03)----Filter: simple_struct.id > Int64(2)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_2, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__common_expr_1@0 * __common_expr_1@0 as id_and_value]
02)--ProjectionExec: expr=[id@1 + __datafusion_extracted_2@0 as __common_expr_1]
03)----FilterExec: id@1 > 2
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]


query TT
EXPLAIN SELECT s['value'] + s['value'] as doubled FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: __datafusion_extracted_1 + __datafusion_extracted_1 AS doubled
02)--Filter: simple_struct.id > Int64(2)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 + __datafusion_extracted_1@0 as doubled]
02)--FilterExec: id@1 > 2, projection=[__datafusion_extracted_1@0]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query I
SELECT s['value'] + s['value'] as doubled FROM simple_struct WHERE id > 2 ORDER BY doubled;
----
300
500
600

###
# Test 9.3: Projection with only get_field expressions through Filter
###

query TT
EXPLAIN SELECT s['value'], s['label'] FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS simple_struct.s[value], __datafusion_extracted_2 AS simple_struct.s[label]
02)--Filter: simple_struct.id > Int64(2)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as simple_struct.s[value], __datafusion_extracted_2@1 as simple_struct.s[label]]
02)--FilterExec: id@2 > 2, projection=[__datafusion_extracted_1@0, __datafusion_extracted_2@1]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, label) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query IT
SELECT s['value'], s['label'] FROM simple_struct WHERE id > 2 ORDER BY s['value'];
----
150 gamma
250 epsilon
300 delta

###
# Test 9.4: Mixed column reference with get_field in expression through TopK
# Tests column remapping in finalize_outer_exprs when outer expr references both extracted and original columns
###

query TT
EXPLAIN SELECT id, s['value'] + id as combined FROM simple_struct ORDER BY id LIMIT 3;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=3
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) + simple_struct.id AS combined
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=3), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) + id@0 as combined], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT id, s['value'] + id as combined FROM simple_struct ORDER BY id LIMIT 3;
----
1 101
2 202
3 153

###
# Test 9.5: Multiple get_field from same struct in expression through Filter
# Tests extraction when base struct is shared across multiple get_field calls
###

query TT
EXPLAIN SELECT s['value'] * 2 + length(s['label']) as score FROM simple_struct WHERE id > 1;
----
logical_plan
01)Projection: __datafusion_extracted_1 * Int64(2) + CAST(character_length(__datafusion_extracted_2) AS Int64) AS score
02)--Filter: simple_struct.id > Int64(1)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 * 2 + CAST(character_length(__datafusion_extracted_2@1) AS Int64) as score]
02)--FilterExec: id@2 > 1, projection=[__datafusion_extracted_1@0, __datafusion_extracted_2@1]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, label) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 > 1, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness
query I
SELECT s['value'] * 2 + length(s['label']) as score FROM simple_struct WHERE id > 1 ORDER BY score;
----
305
404
507
605


#####################
# Section 10: Literal with get_field Expressions
#####################

###
# Test 10.1: Literal constant + get_field in same projection
# Tests projection with both trivial (literal) and get_field expressions
###

query TT
EXPLAIN SELECT id, 42 as answer, s['label'] FROM simple_struct ORDER BY id LIMIT 2;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=2
02)--Projection: simple_struct.id, Int64(42) AS answer, get_field(simple_struct.s, Utf8("label"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, 42 as answer, get_field(s@1, label) as simple_struct.s[label]], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query IIT
SELECT id, 42 as answer, s['label'] FROM simple_struct ORDER BY id LIMIT 2;
----
1 42 alpha
2 42 beta

###
# Test 10.2: Multiple non-trivial get_field expressions together
# Tests arithmetic on one field and string concat on another in same projection
###

query TT
EXPLAIN SELECT id, s['value'] + 100, s['label'] || '_test' FROM simple_struct ORDER BY id LIMIT 2;
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, fetch=2
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) + Int64(100), get_field(simple_struct.s, Utf8("label")) || Utf8("_test")
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: TopK(fetch=2), expr=[id@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) + 100 as simple_struct.s[value] + Int64(100), get_field(s@1, label) || _test as simple_struct.s[label] || Utf8("_test")], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query IIT
SELECT id, s['value'] + 100, s['label'] || '_test' FROM simple_struct ORDER BY id LIMIT 2;
----
1 200 alpha_test
2 300 beta_test

#####################
# Section 11: FilterExec Projection Pushdown - Handling Predicate Column Requirements
#####################

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct WHERE id > 1;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_1 AS simple_struct.s[value]
02)--Filter: simple_struct.id > Int64(1)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as simple_struct.s[value]]
02)--FilterExec: id@1 > 1
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct WHERE id > 1 ORDER BY id LIMIT 2;
----
2 200
3 150

query TT
EXPLAIN SELECT s['value'] FROM simple_struct WHERE id > 1 AND (id < 4 OR id = 5);
----
logical_plan
01)Projection: __datafusion_extracted_1 AS simple_struct.s[value]
02)--Filter: simple_struct.id > Int64(1) AND (simple_struct.id < Int64(4) OR simple_struct.id = Int64(5))
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1), simple_struct.id < Int64(4) OR simple_struct.id = Int64(5)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as simple_struct.s[value]]
02)--FilterExec: id@1 > 1 AND (id@1 < 4 OR id@1 = 5), projection=[__datafusion_extracted_1@0]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1 AND (id@0 < 4 OR id@0 = 5), pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1 AND (id_null_count@1 != row_count@2 AND id_min@3 < 4 OR id_null_count@1 != row_count@2 AND id_min@3 <= 5 AND 5 <= id_max@0), required_guarantees=[]

# Verify correctness - should return rows where (id > 1) AND ((id < 4) OR (id = 5))
# That's: id=2,3 (1<id<4) and id=5 (id=5 from second branch)
query I
SELECT s['value'] FROM simple_struct WHERE id > 1 AND (id < 4 OR id = 5) ORDER BY s['value'];
----
150
200
250

query TT
EXPLAIN SELECT s['value'] FROM simple_struct WHERE id > 1 AND id < 5;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS simple_struct.s[value]
02)--Filter: simple_struct.id > Int64(1) AND simple_struct.id < Int64(5)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1), simple_struct.id < Int64(5)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as simple_struct.s[value]]
02)--FilterExec: id@1 > 1 AND id@1 < 5, projection=[__datafusion_extracted_1@0]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 1 AND id@0 < 5, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1 AND id_null_count@1 != row_count@2 AND id_min@3 < 5, required_guarantees=[]

# Verify correctness - should return rows where 1 < id < 5 (id=2,3,4)
query I
SELECT s['value'] FROM simple_struct WHERE id > 1 AND id < 5 ORDER BY s['value'];
----
150
200
300

query TT
EXPLAIN SELECT s['value'], s['label'], id FROM simple_struct WHERE id > 1;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS simple_struct.s[value], __datafusion_extracted_2 AS simple_struct.s[label], simple_struct.id
02)--Filter: simple_struct.id > Int64(1)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(1)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as simple_struct.s[value], __datafusion_extracted_2@1 as simple_struct.s[label], id@2 as id]
02)--FilterExec: id@2 > 1
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, label) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 > 1, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 1, required_guarantees=[]

# Verify correctness - note that id is now at index 2 in the augmented projection
query ITI
SELECT s['value'], s['label'], id FROM simple_struct WHERE id > 1 ORDER BY id LIMIT 3;
----
200 beta 2
150 gamma 3
300 delta 4

query TT
EXPLAIN SELECT s['value'] FROM simple_struct WHERE length(s['label']) > 4;
----
logical_plan
01)Projection: __datafusion_extracted_2 AS simple_struct.s[value]
02)--Filter: character_length(__datafusion_extracted_1) > Int32(4)
03)----Projection: get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_2
04)------TableScan: simple_struct projection=[s], partial_filters=[character_length(get_field(simple_struct.s, Utf8("label"))) > Int32(4)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_2@0 as simple_struct.s[value]]
02)--FilterExec: character_length(__datafusion_extracted_1@0) > 4, projection=[__datafusion_extracted_2@1]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, label) as __datafusion_extracted_1, get_field(s@1, value) as __datafusion_extracted_2], file_type=parquet

# Verify correctness - filter on rows where label length > 4 (all have length 5, except 'one' has 3)
# Wait, from the data: alpha(5), beta(4), gamma(5), delta(5), epsilon(7)
# So: alpha, gamma, delta, epsilon (not beta which has 4 characters)
query I
SELECT s['value'] FROM simple_struct WHERE length(s['label']) > 4 ORDER BY s['value'];
----
100
150
250
300

#####################
# Section 11a: ProjectionExec on top of a SortExec with missing Sort Columns
#####################

###
# Test 11a.1: Sort by dropped column
# Selects only id, drops s entirely, but sorts by s['value']
###

query TT
EXPLAIN SELECT id FROM simple_struct ORDER BY s['value'];
----
logical_plan
01)Projection: simple_struct.id
02)--Sort: __datafusion_extracted_1 ASC NULLS LAST
03)----Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1
04)------TableScan: simple_struct projection=[id, s]
physical_plan
01)ProjectionExec: expr=[id@0 as id]
02)--SortExec: expr=[__datafusion_extracted_1@1 ASC NULLS LAST], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as __datafusion_extracted_1], file_type=parquet

# Verify correctness
query I
SELECT id FROM simple_struct ORDER BY s['value'];
----
1
3
2
5
4

###
# Test 11a.2: Multiple sort columns with partial selection
# Selects only id and s['value'], but sorts by id and s['label']
# One sort column (s['label']) is not selected but needed for ordering
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct ORDER BY id, s['label'];
----
logical_plan
01)Projection: simple_struct.id, simple_struct.s[value]
02)--Sort: simple_struct.id ASC NULLS LAST, __datafusion_extracted_1 ASC NULLS LAST
03)----Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")), get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_1
04)------TableScan: simple_struct projection=[id, s]
physical_plan
01)ProjectionExec: expr=[id@0 as id, simple_struct.s[value]@1 as simple_struct.s[value]]
02)--SortExec: expr=[id@0 ASC NULLS LAST, __datafusion_extracted_1@2 ASC NULLS LAST], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value], get_field(s@1, label) as __datafusion_extracted_1], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY id, s['label'];
----
1 100
2 200
3 150
4 300
5 250


###
# Test 11a.3: TopK with dropped sort column
# Same as test 11a.1 but with LIMIT
###

query TT
EXPLAIN SELECT id FROM simple_struct ORDER BY s['value'] LIMIT 2;
----
logical_plan
01)Projection: simple_struct.id
02)--Sort: __datafusion_extracted_1 ASC NULLS LAST, fetch=2
03)----Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1
04)------TableScan: simple_struct projection=[id, s]
physical_plan
01)ProjectionExec: expr=[id@0 as id]
02)--SortExec: TopK(fetch=2), expr=[__datafusion_extracted_1@1 ASC NULLS LAST], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as __datafusion_extracted_1], file_type=parquet

# Verify correctness
query I
SELECT id FROM simple_struct ORDER BY s['value'] LIMIT 2;
----
1
3

###
# Test 11a.4: Sort by derived expression with dropped column
# Projects only id, sorts by s['value'] * 2 (derived expression)
# Sort column is computed but requires base columns not in projection
###

query TT
EXPLAIN SELECT id FROM simple_struct ORDER BY s['value'] * 2;
----
logical_plan
01)Projection: simple_struct.id
02)--Sort: __datafusion_extracted_1 * Int64(2) ASC NULLS LAST
03)----Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1
04)------TableScan: simple_struct projection=[id, s]
physical_plan
01)ProjectionExec: expr=[id@0 as id]
02)--SortExec: expr=[__datafusion_extracted_1@1 * 2 ASC NULLS LAST], preserve_partitioning=[false]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as __datafusion_extracted_1], file_type=parquet

# Verify correctness
query I
SELECT id FROM simple_struct ORDER BY s['value'] * 2;
----
1
3
2
5
4

###
# Test 11a.5: All sort columns selected
# All columns needed for sorting are included in projection
###

query TT
EXPLAIN SELECT id, s['value'] FROM simple_struct ORDER BY id, s['value'];
----
logical_plan
01)Sort: simple_struct.id ASC NULLS LAST, simple_struct.s[value] ASC NULLS LAST
02)--Projection: simple_struct.id, get_field(simple_struct.s, Utf8("value"))
03)----TableScan: simple_struct projection=[id, s]
physical_plan
01)SortExec: expr=[id@0 ASC NULLS LAST, simple_struct.s[value]@1 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id, get_field(s@1, value) as simple_struct.s[value]], file_type=parquet

# Verify correctness
query II
SELECT id, s['value'] FROM simple_struct ORDER BY id, s['value'];
----
1 100
2 200
3 150
4 300
5 250

#####################
# Section 12: Join Tests - get_field Extraction from Join Nodes
#####################

# Create a second table for join tests
statement ok
COPY (
    SELECT
        column1 as id,
        column2 as s
    FROM VALUES
        (1, {role: 'admin', level: 10}),
        (2, {role: 'user', level: 5}),
        (3, {role: 'guest', level: 1}),
        (4, {role: 'admin', level: 8}),
        (5, {role: 'user', level: 3})
) TO 'test_files/scratch/projection_pushdown/join_right.parquet'
STORED AS PARQUET;

statement ok
CREATE EXTERNAL TABLE join_right STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/join_right.parquet';

###
# Test 12.1: Join with get_field in equijoin condition
# Tests extraction from join ON clause - get_field on each side routed appropriately
###

query TT
EXPLAIN SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.s['value'] = join_right.s['level'] * 10;
----
logical_plan
01)Projection: simple_struct.id, join_right.id
02)--Inner Join: __datafusion_extracted_1 = __datafusion_extracted_2 * Int64(10)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s]
05)----Projection: get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_2, join_right.id
06)------TableScan: join_right projection=[id, s]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(__datafusion_extracted_1@0, __datafusion_extracted_2 * Int64(10)@2)], projection=[id@1, id@3]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet
03)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, level) as __datafusion_extracted_2, id, get_field(s@1, level) * 10 as __datafusion_extracted_2 * Int64(10)], file_type=parquet

# Verify correctness - value = level * 10
# simple_struct: (1,100), (2,200), (3,150), (4,300), (5,250)
# join_right: (1,10), (2,5), (3,1), (4,8), (5,3)
# Matches: simple_struct.value=100 matches join_right.level*10=100 (level=10, id=1)
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.s['value'] = join_right.s['level'] * 10
ORDER BY simple_struct.id;
----
1 1

###
# Test 12.2: Join with get_field in non-equi filter
# Tests extraction from join filter expression - left side only
###

query TT
EXPLAIN SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > 150;
----
logical_plan
01)Inner Join: simple_struct.id = join_right.id
02)--Projection: simple_struct.id
03)----Filter: __datafusion_extracted_1 > Int64(150)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[get_field(simple_struct.s, Utf8("value")) > Int64(150)]
06)--TableScan: join_right projection=[id]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)]
02)--FilterExec: __datafusion_extracted_1@0 > 150, projection=[id@1]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet
04)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness - id matches and value > 150
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > 150
ORDER BY simple_struct.id;
----
2 2
4 4
5 5

###
# Test 12.3: Join with get_field from both sides in filter
# Tests extraction routing to both left and right inputs
###

query TT
EXPLAIN SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > 100 AND join_right.s['level'] > 3;
----
logical_plan
01)Inner Join: simple_struct.id = join_right.id
02)--Projection: simple_struct.id
03)----Filter: __datafusion_extracted_1 > Int64(100)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[get_field(simple_struct.s, Utf8("value")) > Int64(100)]
06)--Projection: join_right.id
07)----Filter: __datafusion_extracted_2 > Int64(3)
08)------Projection: get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_2, join_right.id
09)--------TableScan: join_right projection=[id, s], partial_filters=[get_field(join_right.s, Utf8("level")) > Int64(3)]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)]
02)--FilterExec: __datafusion_extracted_1@0 > 100, projection=[id@1]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet
04)--FilterExec: __datafusion_extracted_2@0 > 3, projection=[id@1]
05)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, level) as __datafusion_extracted_2, id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness - id matches, value > 100, and level > 3
# Matching ids where value > 100: 2(200), 3(150), 4(300), 5(250)
# Of those, level > 3: 2(5), 4(8), 5(3) -> only 2 and 4
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > 100 AND join_right.s['level'] > 3
ORDER BY simple_struct.id;
----
2 2
4 4

###
# Test 12.4: Join with get_field in SELECT projection
# Tests that get_field in output columns pushes down through the join
###

query TT
EXPLAIN SELECT simple_struct.id, simple_struct.s['label'], join_right.s['role']
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_1 AS simple_struct.s[label], __datafusion_extracted_2 AS join_right.s[role]
02)--Inner Join: simple_struct.id = join_right.id
03)----Projection: get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s]
05)----Projection: get_field(join_right.s, Utf8("role")) AS __datafusion_extracted_2, join_right.id
06)------TableScan: join_right projection=[id, s]
physical_plan
01)ProjectionExec: expr=[id@1 as id, __datafusion_extracted_1@0 as simple_struct.s[label], __datafusion_extracted_2@2 as join_right.s[role]]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, id@1)], projection=[__datafusion_extracted_1@0, id@1, __datafusion_extracted_2@2]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, label) as __datafusion_extracted_1, id], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, role) as __datafusion_extracted_2, id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query ITT
SELECT simple_struct.id, simple_struct.s['label'], join_right.s['role']
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
ORDER BY simple_struct.id;
----
1 alpha admin
2 beta user
3 gamma guest
4 delta admin
5 epsilon user

###
# Test 12.5: Join without get_field (baseline - no extraction needed)
# Verifies no unnecessary projections are added when there's nothing to extract
###

query TT
EXPLAIN SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id;
----
logical_plan
01)Inner Join: simple_struct.id = join_right.id
02)--TableScan: simple_struct projection=[id]
03)--TableScan: join_right projection=[id]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, id@0)]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[id], file_type=parquet
03)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
ORDER BY simple_struct.id;
----
1 1
2 2
3 3
4 4
5 5

###
# Test 12.6: Left Join with get_field extraction
# Tests extraction works correctly with outer joins
###

query TT
EXPLAIN SELECT simple_struct.id, simple_struct.s['value'], join_right.s['level']
FROM simple_struct
LEFT JOIN join_right ON simple_struct.id = join_right.id AND join_right.s['level'] > 5;
----
logical_plan
01)Projection: simple_struct.id, __datafusion_extracted_2 AS simple_struct.s[value], __datafusion_extracted_3 AS join_right.s[level]
02)--Left Join: simple_struct.id = join_right.id
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_2, simple_struct.id
04)------TableScan: simple_struct projection=[id, s]
05)----Projection: join_right.id, __datafusion_extracted_3
06)------Filter: __datafusion_extracted_1 > Int64(5)
07)--------Projection: get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_1, join_right.id, get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_3
08)----------TableScan: join_right projection=[id, s], partial_filters=[get_field(join_right.s, Utf8("level")) > Int64(5)]
physical_plan
01)ProjectionExec: expr=[id@1 as id, __datafusion_extracted_2@0 as simple_struct.s[value], __datafusion_extracted_3@2 as join_right.s[level]]
02)--HashJoinExec: mode=CollectLeft, join_type=Left, on=[(id@1, id@0)], projection=[__datafusion_extracted_2@0, id@1, __datafusion_extracted_3@3]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_2, id], file_type=parquet
04)----FilterExec: __datafusion_extracted_1@0 > 5, projection=[id@1, __datafusion_extracted_3@2]
05)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, level) as __datafusion_extracted_1, id, get_field(s@1, level) as __datafusion_extracted_3], file_type=parquet

# Verify correctness - left join with level > 5 condition
# Only join_right rows with level > 5 are matched: id=1 (level=10), id=4 (level=8)
query III
SELECT simple_struct.id, simple_struct.s['value'], join_right.s['level']
FROM simple_struct
LEFT JOIN join_right ON simple_struct.id = join_right.id AND join_right.s['level'] > 5
ORDER BY simple_struct.id;
----
1 100 10
2 200 NULL
3 150 NULL
4 300 8
5 250 NULL

#####################
# Section 13: RepartitionExec tests
#####################

# Set target partitions to 32 -> this forces a RepartitionExec
statement ok
SET datafusion.execution.target_partitions = 32;

query TT
EXPLAIN SELECT s['value'] FROM simple_struct WHERE id > 2;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS simple_struct.s[value]
02)--Filter: simple_struct.id > Int64(2)
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as simple_struct.s[value]]
02)--FilterExec: id@1 > 2, projection=[__datafusion_extracted_1@0]
03)----RepartitionExec: partitioning=RoundRobinBatch(32), input_partitions=1
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

#####################
# Section 14: SubqueryAlias tests
#####################

# Reset target partitions
statement ok
SET datafusion.execution.target_partitions = 1;

# get_field pushdown through subquery alias with filter
query TT
EXPLAIN SELECT t.s['value'] FROM (SELECT * FROM simple_struct) t WHERE t.id > 2;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS t.s[value]
02)--SubqueryAlias: t
03)----Projection: __datafusion_extracted_1
04)------Filter: simple_struct.id > Int64(2)
05)--------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
06)----------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as t.s[value]]
02)--FilterExec: id@1 > 2, projection=[__datafusion_extracted_1@0]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query I
SELECT t.s['value'] FROM (SELECT * FROM simple_struct) t WHERE t.id > 2 ORDER BY t.id;
----
150
300
250

# Multiple get_field through subquery alias with sort
query TT
EXPLAIN SELECT t.s['value'], t.s['label'] FROM (SELECT * FROM simple_struct) t ORDER BY t.s['value'];
----
logical_plan
01)Sort: t.s[value] ASC NULLS LAST
02)--Projection: __datafusion_extracted_1 AS t.s[value], __datafusion_extracted_2 AS t.s[label]
03)----SubqueryAlias: t
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2
05)--------TableScan: simple_struct projection=[s]
physical_plan
01)SortExec: expr=[t.s[value]@0 ASC NULLS LAST], preserve_partitioning=[false]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as t.s[value], get_field(s@1, label) as t.s[label]], file_type=parquet

# Verify correctness
query IT
SELECT t.s['value'], t.s['label'] FROM (SELECT * FROM simple_struct) t ORDER BY t.s['value'];
----
100 alpha
150 gamma
200 beta
250 epsilon
300 delta

# Nested subquery aliases
query TT
EXPLAIN SELECT u.s['value'] FROM (SELECT * FROM (SELECT * FROM simple_struct) t) u WHERE u.id > 2;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS u.s[value]
02)--SubqueryAlias: u
03)----SubqueryAlias: t
04)------Projection: __datafusion_extracted_1
05)--------Filter: simple_struct.id > Int64(2)
06)----------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
07)------------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(2)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as u.s[value]]
02)--FilterExec: id@1 > 2, projection=[__datafusion_extracted_1@0]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 2, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 2, required_guarantees=[]

# Verify correctness
query I
SELECT u.s['value'] FROM (SELECT * FROM (SELECT * FROM simple_struct) t) u WHERE u.id > 2 ORDER BY u.id;
----
150
300
250

# get_field in filter through subquery alias
query TT
EXPLAIN SELECT t.id FROM (SELECT * FROM simple_struct) t WHERE t.s['value'] > 200;
----
logical_plan
01)SubqueryAlias: t
02)--Projection: simple_struct.id
03)----Filter: __datafusion_extracted_1 > Int64(200)
04)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
05)--------TableScan: simple_struct projection=[id, s], partial_filters=[get_field(simple_struct.s, Utf8("value")) > Int64(200)]
physical_plan
01)FilterExec: __datafusion_extracted_1@0 > 200, projection=[id@1]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet

# Verify correctness
query I
SELECT t.id FROM (SELECT * FROM simple_struct) t WHERE t.s['value'] > 200 ORDER BY t.id;
----
4
5

#####################
# Section 15: UNION ALL tests
#####################

# get_field on UNION ALL result
query TT
EXPLAIN SELECT s['value'] FROM (
    SELECT s FROM simple_struct WHERE id <= 3
    UNION ALL
    SELECT s FROM simple_struct WHERE id > 3
) t;
----
logical_plan
01)Projection: __datafusion_extracted_1 AS t.s[value]
02)--SubqueryAlias: t
03)----Union
04)------Projection: __datafusion_extracted_1
05)--------Filter: simple_struct.id <= Int64(3)
06)----------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
07)------------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id <= Int64(3)]
08)------Projection: __datafusion_extracted_1
09)--------Filter: simple_struct.id > Int64(3)
10)----------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
11)------------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(3)]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_1@0 as t.s[value]]
02)--UnionExec
03)----FilterExec: id@1 <= 3, projection=[__datafusion_extracted_1@0]
04)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 <= 3, pruning_predicate=id_null_count@1 != row_count@2 AND id_min@0 <= 3, required_guarantees=[]
05)----FilterExec: id@1 > 3, projection=[__datafusion_extracted_1@0]
06)------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet, predicate=id@0 > 3, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 3, required_guarantees=[]

# Verify correctness
query I
SELECT s['value'] FROM (
    SELECT s FROM simple_struct WHERE id <= 3
    UNION ALL
    SELECT s FROM simple_struct WHERE id > 3
) t ORDER BY s['value'];
----
100
150
200
250
300

# Multiple get_field on UNION ALL with ORDER BY
query TT
EXPLAIN SELECT s['value'], s['label'] FROM (
    SELECT s FROM simple_struct WHERE id <= 3
    UNION ALL
    SELECT s FROM simple_struct WHERE id > 3
) t ORDER BY s['value'];
----
logical_plan
01)Sort: t.s[value] ASC NULLS LAST
02)--Projection: __datafusion_extracted_1 AS t.s[value], __datafusion_extracted_2 AS t.s[label]
03)----SubqueryAlias: t
04)------Union
05)--------Projection: __datafusion_extracted_1, __datafusion_extracted_2
06)----------Filter: simple_struct.id <= Int64(3)
07)------------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2, simple_struct.id
08)--------------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id <= Int64(3)]
09)--------Projection: __datafusion_extracted_1, __datafusion_extracted_2
10)----------Filter: simple_struct.id > Int64(3)
11)------------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("label")) AS __datafusion_extracted_2, simple_struct.id
12)--------------TableScan: simple_struct projection=[id, s], partial_filters=[simple_struct.id > Int64(3)]
physical_plan
01)SortPreservingMergeExec: [t.s[value]@0 ASC NULLS LAST]
02)--SortExec: expr=[t.s[value]@0 ASC NULLS LAST], preserve_partitioning=[true]
03)----ProjectionExec: expr=[__datafusion_extracted_1@0 as t.s[value], __datafusion_extracted_2@1 as t.s[label]]
04)------UnionExec
05)--------FilterExec: id@2 <= 3, projection=[__datafusion_extracted_1@0, __datafusion_extracted_2@1]
06)----------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, label) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 <= 3, pruning_predicate=id_null_count@1 != row_count@2 AND id_min@0 <= 3, required_guarantees=[]
07)--------FilterExec: id@2 > 3, projection=[__datafusion_extracted_1@0, __datafusion_extracted_2@1]
08)----------DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, label) as __datafusion_extracted_2, id], file_type=parquet, predicate=id@0 > 3, pruning_predicate=id_null_count@1 != row_count@2 AND id_max@0 > 3, required_guarantees=[]

# Verify correctness
query IT
SELECT s['value'], s['label'] FROM (
    SELECT s FROM simple_struct WHERE id <= 3
    UNION ALL
    SELECT s FROM simple_struct WHERE id > 3
) t ORDER BY s['value'];
----
100 alpha
150 gamma
200 beta
250 epsilon
300 delta

#####################
# Section 16: Aggregate / Join edge-case tests
# Translated from unit tests in extract_leaf_expressions.rs
#####################

###
# Test 16.1: Projection with get_field above Aggregate
# Aggregate blocks pushdown, so the get_field stays in the top projection.
# (mirrors test_projection_with_leaf_expr_above_aggregate)
###

query TT
EXPLAIN SELECT s['label'] IS NOT NULL AS has_label, COUNT(1)
FROM simple_struct GROUP BY s;
----
logical_plan
01)Projection: get_field(simple_struct.s, Utf8("label")) IS NOT NULL AS has_label, count(Int64(1))
02)--Aggregate: groupBy=[[simple_struct.s]], aggr=[[count(Int64(1))]]
03)----TableScan: simple_struct projection=[s]
physical_plan
01)ProjectionExec: expr=[get_field(s@0, label) IS NOT NULL as has_label, count(Int64(1))@1 as count(Int64(1))]
02)--AggregateExec: mode=Single, gby=[s@0 as s], aggr=[count(Int64(1))]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[s], file_type=parquet

# Verify correctness - all labels are non-null
query BI
SELECT s['label'] IS NOT NULL AS has_label, COUNT(1)
FROM simple_struct GROUP BY s ORDER BY COUNT(1);
----
true 1
true 1
true 1
true 1
true 1

###
# Test 16.2: Join with get_field filter on qualified right side
# The get_field on join_right.s['role'] must be routed to the right input only.
# (mirrors test_extract_from_join_qualified_right_side)
###

query TT
EXPLAIN
SELECT s.s['value'], j.s['role']
FROM join_right j
INNER JOIN simple_struct s ON s.id = j.id
WHERE s.s['value'] > j.s['level'];
----
logical_plan
01)Projection: __datafusion_extracted_3 AS s.s[value], __datafusion_extracted_4 AS j.s[role]
02)--Inner Join: j.id = s.id Filter: __datafusion_extracted_1 > __datafusion_extracted_2
03)----SubqueryAlias: j
04)------Projection: get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_2, get_field(join_right.s, Utf8("role")) AS __datafusion_extracted_4, join_right.id
05)--------TableScan: join_right projection=[id, s]
06)----SubqueryAlias: s
07)------Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_3, simple_struct.id
08)--------TableScan: simple_struct projection=[id, s]
physical_plan
01)ProjectionExec: expr=[__datafusion_extracted_3@1 as s.s[value], __datafusion_extracted_4@0 as j.s[role]]
02)--HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@2, id@2)], filter=__datafusion_extracted_1@1 > __datafusion_extracted_2@0, projection=[__datafusion_extracted_4@1, __datafusion_extracted_3@4]
03)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, level) as __datafusion_extracted_2, get_field(s@1, role) as __datafusion_extracted_4, id], file_type=parquet
04)----DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, get_field(s@1, value) as __datafusion_extracted_3, id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness - only admin roles match (ids 1 and 4)
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right
  ON simple_struct.id = join_right.id
  AND join_right.s['role'] = 'admin'
ORDER BY simple_struct.id;
----
1 1
4 4

###
# Test 16.3: Join with cross-input get_field comparison in WHERE
# get_field from each side is extracted and routed to its respective input independently.
# (mirrors test_extract_from_join_cross_input_expression)
###

query TT
EXPLAIN SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > join_right.s['level'];
----
logical_plan
01)Projection: simple_struct.id, join_right.id
02)--Inner Join: simple_struct.id = join_right.id Filter: __datafusion_extracted_1 > __datafusion_extracted_2
03)----Projection: get_field(simple_struct.s, Utf8("value")) AS __datafusion_extracted_1, simple_struct.id
04)------TableScan: simple_struct projection=[id, s]
05)----Projection: get_field(join_right.s, Utf8("level")) AS __datafusion_extracted_2, join_right.id
06)------TableScan: join_right projection=[id, s]
physical_plan
01)HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, id@1)], filter=__datafusion_extracted_1@0 > __datafusion_extracted_2@1, projection=[id@1, id@3]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/simple.parquet]]}, projection=[get_field(s@1, value) as __datafusion_extracted_1, id], file_type=parquet
03)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/join_right.parquet]]}, projection=[get_field(s@1, level) as __datafusion_extracted_2, id], file_type=parquet, predicate=DynamicFilter [ empty ]

# Verify correctness - all rows match since value >> level for all ids
# simple_struct: (1,100), (2,200), (3,150), (4,300), (5,250)
# join_right:    (1,10),  (2,5),   (3,1),   (4,8),   (5,3)
query II
SELECT simple_struct.id, join_right.id
FROM simple_struct
INNER JOIN join_right ON simple_struct.id = join_right.id
WHERE simple_struct.s['value'] > join_right.s['level']
ORDER BY simple_struct.id;
----
1 1
2 2
3 3
4 4
5 5

# =========================================================================
# Regression: user-provided __datafusion_extracted aliases must not
# collide with optimizer-generated ones
# (https://github.com/apache/datafusion/issues/20430)
# =========================================================================

statement ok
COPY ( select {f1: 1, f2: 2} as s
) TO 'test_files/scratch/projection_pushdown/test.parquet'
STORED AS PARQUET;

statement ok
CREATE EXTERNAL TABLE t
STORED AS PARQUET
LOCATION 'test_files/scratch/projection_pushdown/test.parquet';

# Verify that the user-provided __datafusion_extracted_2 alias is preserved
# and the optimizer skips to _3 and _4 for its generated aliases.
query TT
EXPLAIN SELECT
    get_field(s, 'f1') AS __datafusion_extracted_2
FROM t
WHERE COALESCE(get_field(s, 'f1'), get_field(s, 'f2')) = 1;
----
logical_plan
01)Projection: __datafusion_extracted_2
02)--Filter: CASE WHEN __datafusion_extracted_3 IS NOT NULL THEN __datafusion_extracted_3 ELSE __datafusion_extracted_4 END = Int64(1)
03)----Projection: get_field(t.s, Utf8("f1")) AS __datafusion_extracted_3, get_field(t.s, Utf8("f2")) AS __datafusion_extracted_4, get_field(t.s, Utf8("f1")) AS __datafusion_extracted_2
04)------TableScan: t projection=[s], partial_filters=[CASE WHEN get_field(t.s, Utf8("f1")) IS NOT NULL THEN get_field(t.s, Utf8("f1")) ELSE get_field(t.s, Utf8("f2")) END = Int64(1)]
physical_plan
01)FilterExec: CASE WHEN __datafusion_extracted_3@0 IS NOT NULL THEN __datafusion_extracted_3@0 ELSE __datafusion_extracted_4@1 END = 1, projection=[__datafusion_extracted_2@2]
02)--DataSourceExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/sqllogictest/test_files/scratch/projection_pushdown/test.parquet]]}, projection=[get_field(s@0, f1) as __datafusion_extracted_3, get_field(s@0, f2) as __datafusion_extracted_4, get_field(s@0, f1) as __datafusion_extracted_2], file_type=parquet

query I
SELECT
    get_field(s, 'f1') AS __datafusion_extracted_2
FROM t
WHERE COALESCE(get_field(s, 'f1'), get_field(s, 'f2')) = 1;
----
1
